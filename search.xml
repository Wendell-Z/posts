<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kafka集群部署方案&amp;参数推荐配置</title>
      <link href="2021/10/17/kafka-ji-qun-bu-shu-fang-an-can-shu-tui-jian-pei-zhi/"/>
      <url>2021/10/17/kafka-ji-qun-bu-shu-fang-an-can-shu-tui-jian-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka集群部署方案-amp-参数推荐配置"><a href="#Kafka集群部署方案-amp-参数推荐配置" class="headerlink" title="Kafka集群部署方案&amp;参数推荐配置"></a>Kafka集群部署方案&amp;参数推荐配置</h2><h2 id="集群部署选择"><a href="#集群部署选择" class="headerlink" title="集群部署选择"></a>集群部署选择</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><code>Linux</code>在以下3个方面表现更胜一筹:</p><ul><li><code>I/O</code>模型使用</li><li>数据网络传输效率</li><li>社区支持度</li></ul><p><code>Kafka</code>客户端底层使用了<code>Java</code>的<code>Selector</code>,<code>Selector</code>在<code>Linux</code>上实现的机制是<code>epoll</code>，能够获得更高效的<code>I/O</code>性能。</p><p><code>Kafka</code>部署在<code>Linux</code>上能够享受的零拷贝<code>（Zero Copy）</code>技术，即当数据在磁盘和网络进行传输是避免昂贵的内核态数据拷贝从而实现快速数据传输。</p><blockquote><p>I/O模型和零拷贝会单拎出来写文章。</p></blockquote><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>由于<code>Kafka</code>采用的是顺序写，所以一定程度上规避了<code>HDD</code>最大的缺点，即随机写操作慢。</p><p><code>HDD</code>因易损坏造成的可靠性差等缺陷，又由<code>Kafka</code>在软件层面提供机制来保证，因此大部分场景下使用<code>HDD</code>性价比很高。</p><p><code>Kafka</code>在软件层面自行实现了负载均衡，随然很多大厂确实是把<code>Kafka</code>底层的存储交由RAID，但目前<code>Kfafka</code>在存储这方面提供了越来越便捷的高可靠性方案，</p><p>生产中使用<code>RAID</code>似乎不是那么重要了。</p><h3 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h3><p>假设某个业务一天发1亿条消息到<code>Kafka</code>，每条消息存2份防止丢失，消息默认保存2周，消息平均大小为1KB。</p><p>计算：</p><p>每天1亿条，每条1KB，每条2份，保存2周，即：</p><p>每天的数据量：<code>1亿 * 1KB * 2 / 1000 / 1000 = 200GB</code>，另外<code>Kafka</code>集群除了消息数据还有其他类型的数据，比如索引数据等，再为这些数据留出10%的空间。</p><p>因此每天数据量就是220GB。保存两周，即 <code>220GB * 14 ≈  3TB</code>，<code>Kafka</code>支持数据压缩，假设压缩比是0.75，最后要规划的容量是<code>0.75 * 3 = 2.25TB</code>。</p><p>通过上面的分析可以总结，规划磁盘容量时需要考虑以下几个元素：</p><ul><li><p>新增消息数</p></li><li><p>消息留存时间</p></li><li><p>平均消息大小</p></li><li><p>备份数</p></li><li><p>是否启用压缩</p></li></ul><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><code>Kafka</code>是一种通过网络大量进行数据传输的工具，因此带宽特别容易成为瓶颈。</p><p>普通的以太网络，带宽主要有：1Gbps千兆网络（单机带宽），10Gbps万兆网络。</p><p>与其说是带宽规划，实际上是<code>Kafka</code>服务器数量规划。</p><p>假设机房环境是千兆网络，某业务目标是1小时内处理1TB业务数据。</p><p>计算：</p><p>带宽是1Gbps，即每秒处理1G的数据，假设每台<code>Kafka</code>都是单机部署，通常情况下<code>Kafka</code>会用到70%的带宽资源，因为其他进程可能会占用一些带宽资源。</p><p>即单机部署<code>Kafka</code>，每台服务器可以用到700Mb的带宽，但是实际上，这只是它能使用的最大带宽，你不能让<code>Kafka</code>服务器常规性使用这么多资源，故通常要再额外预留出2/3的资源，即单台服务器使用带宽<code>700Mb/3≈240Mbps</code>**(为follower拉取留一些带宽)**。</p><p>这个2/3实际上是相当保守的，需要根据实际情况酌情减少此值。</p><p><code>1T＝1024GB，1GB＝1024MB，1MB＝1024KB，1KB＝1024B（字节）</code><br><code>1TB=1024 * 1024MB = 8 * 1024 * 1024Mb位</code><br>那么<code>8 * 1024 * 1024Mb / 3600s= 2330Mbps</code><br><code>2330Mbps/234Mbps</code> 约等于 10台服务器，如果每天需要2个副本，那么总共需要30台服务器。</p><blockquote><p><strong>A_NATE_👻</strong>:</p><p>我们曾经也认为用普通硬盘就行，换成普通硬盘导致生产者堵塞写入负载偏高，换成SSD就没事了，我们每天消息数大概50亿。</p><p><strong>胡夕</strong>: 专栏里面只是给出一个评估的方法。具体还要结合自己的实际情况来调整。通常我们认为SSD的顺序写TPS大约是HDD的4倍。</p><p>除了纵向扩展使用SSD之外，也可以尝试一下横向扩展，增加更多的broker或HDD分散负载：）</p></blockquote><blockquote><p><strong>胡夕</strong>：没有谈及CPU，是因为通常情况下Kafka不太占用CPU，因此没有这方面的最佳实践出来。</p><p>但有些情况下Kafka broker是很耗CPU的：</p><ol><li>server和client使用了不同的压缩算法；</li><li>server和client版本不一致造成消息格式转换；</li><li>broker端解压缩校验</li></ol><p>其中前两个都能规避，第三个目前无法规避。不过相比带宽资源，CPU通常都不是瓶颈。</p></blockquote><h2 id="集群参数配置"><a href="#集群参数配置" class="headerlink" title="集群参数配置"></a>集群参数配置</h2><h3 id="Broker端参数"><a href="#Broker端参数" class="headerlink" title="Broker端参数"></a>Broker端参数</h3><p><code>Broker</code>端参数也被成为静态参数<code>(Static Configs)</code>，即必须在Kafka的配置文件<code>server.properties</code>中进行配置的参数，增删改都需要重启<code>Broker</code>才能生效。</p><ul><li><code>log.dirs</code> 指定了<code>Broker</code>需要使用的若干个文件目录路径。没有默认值，需要亲自指定。</li><li><code>log.dir </code>用来补充上一个参数</li></ul><p>这两个参数设置第一个即可，并且一定要为其配置多个路径，CSV格式，逗号分隔，比如<code>/home/kakfa1,/home/kafka2,/home/kafka3</code>。</p><p>有条件的话，最好保证目录挂载到不同物理磁盘，好处：</p><ol><li><p>提升读写性能：比起单块磁盘，多块物理磁盘同时读写数据有更高的吞吐量。</p></li><li><p>能够实现故障转移：即<code>Failover</code>。<code>Kafka</code>1.1 开始，坏掉的磁盘上的数据会自动地转移到其他正常的磁盘上，而且 <code>Broker</code> 还能正常工作。这个改进正是舍弃 RAID 方案的基础：如果没有这种 <code>Failover</code> ，只能依靠 RAID 来提供保障。</p></li></ol><ul><li><p><code>zookeeper.connect</code> CSV格式 指定格式<code>zk1:2181,zk2:2181,zk3:2181</code>，如果想让两套<code>Kafka</code>集群使用同一套<code>Zookeeper</code>集群：<code>zk1:2181,zk2:2181,zk3:2181/kafka1和zk1:2181,zk2:2181,zk3:2181/kafka2</code></p></li><li><p><code>listeners</code>：监听器，告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。</p></li><li><p><code>advertise.listeners</code>：和<code>listeners</code>比多了个 <code>advertised</code>。<code>Advertised</code>的含义表示宣称的、公布的，就是说这组监听器是<code>Broker</code>用于对外发布的。</p></li></ul><p>监听器的概念，从构成上来说，它是若干个逗号分隔的三元组，每个三元组的格式为&lt;协议名称，主机名，端口号&gt;。</p><p>这里的协议名称可能是标准的名字，比如 <code>PLAINTEXT</code> 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；</p><p>也可能是你自己定义的协议名字，比如<code>CONTROLLER: //localhost:9092</code>。</p><ul><li><code>listener.security.protocol.map</code></li></ul><p>一旦你自己定义了协议名称，你必须还要指定<code>listener.security.protocol.map</code>参数告诉这个协议底层使用了哪种安全协议，比如指定<code>istener.security.protocol.map=CONTROLLER:PLAINTEXT</code>表示<code>CONTROLLER</code>这个自定义协议底层使用明文不加密传输数据。</p><p><strong>建议：最好全部使用主机名，即 Broker 端和 Client 端应用配置中全部填写主机名。 Broker 源代码中也使用的是主机名，如果你在某些地方使用了 IP 地址进行连接，可能会发生无法连接的问题。</strong></p><ul><li><p><code>auto.create.topics.enable</code>：是否支持自动创建<code>topic</code>。建议为<code>false</code>，避免生产上出现很多未知<code>topic</code></p></li><li><p><code>unclean.leader.election.enable</code>：是否支持脏选举。建议显式设置为<code>false</code>，只能让<code>ISR</code>选举，后果就是出问题的分区不可用。设置为<code>true</code>会引起数据丢失。</p></li><li><p><code>auto.leader.rebalance.enable</code>：是否允许定期进行 <code>Leader</code> 选举。设置它的值为<code>true</code> 表示允许 <code>Kafka</code> 定期地对一些 <code>Topic</code> 分区进行 <code>Leader</code> 重选举，当然这个重选举不是无脑进行的，它要满足一定的条件才会发生。严格来说它与上一个参数中 <code>Leader </code>选举的最大不同在于，它不是选 <code>Leader</code>，而是换 <code>Leader</code>！比如 <code>Leader A</code> 一直表现得很好，但若<code>auto.leader.rebalance.enable=true</code>，那么有可能一段时间后 <code>Leader A</code> 就要被强行卸任换成 <code>Leader B</code>。换一次 <code>Leader</code> 代价很高的，原本向 A 发送请求的所有客户端都要切换成向 B 发送请求，而且这种换 <code>Leader</code> 本质上没有任何性能收益，因此建议在生产环境中把这个参数设置成 <code>false</code>。</p></li><li><p><code>log.retention.&#123;hours|minutes|ms&#125;</code>：控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低。比如<code>log.retention.hours</code>=168表示保存7天。（不同Topic 根据自身业务需要，设置自己的留存时间。如果只能设置全局 <code>Broker</code> 参数，那么势必要提取所有业务留存时间的最大值作为全局参数值，此时应该设置 Topic 级别参数把它覆盖。）</p></li><li><p><code>log.retention.bytes</code>：这是指定 <code>Broker </code>为消息保存的总磁盘容量大小。默认值-1，即想保存多少就多少。</p></li><li><p><code>message.max.bytes</code>：控制 <code>Broker</code> 能够接收的最大消息大小。默认值1000012，不到1MB，太小。根据自身业务调大。</p></li></ul><blockquote><p><strong>第一片心意</strong>：</p><p><code>auto.leader.rebalance.enable</code><br>   关于这个参数的设置，我有一点不同的意见，官网说的是如果某个broker挂了，那分布在他上的leader副本就会自动切换到其他活着的broker上，但是挂掉的broker重启之后，集群并不会将他之前的leader副本再切换回来，这样就会使其他broker上leader副本数较多，而该broker上无leader副本（无新主题创建），从而造成负载不均衡的情况。<br>   这时我们可以通过 <code>kafka-preferred-replica-election.sh </code>脚本来重新平衡集群中的leader副本。但是我们配置这个参数为true的话，controller角色就会每五分钟（默认）检查一下集群不平衡的状态，进而重新平衡leader副本。</p><p>胡夕: 同意。不过实际上，线上环境贸然大面积迁移副本leader是非常有风险的事情：）</p></blockquote><blockquote><p><strong>杨陆伟</strong>:</p><p><code>log.retention.bytes</code>这个参数是针对主题的吧？比如设置为100M，Kafka定期会把每个主题的日志数据留存到100M以下？</p><p>胡夕: 这个参数既有broker端也有topic端，不过最终都是作用于topic的。另外算法上也不是简单的比较大小。举个例子：假设日志段大小是700MB，当前分区共有4个日志段文件，大小分别是700MB，700MB，700MB和1234B——显然1234B那个文件就是active日志段。此时该分区总的日志大小是3*700MB+1234B=2100MB+1234B，如果阈值设置为2000MB，那么超出阈值的部分就是100MB+1234B，小于日志段大小700MB，故Kafka不会执行任何删除操作，即使总大小已经超过了阈值；反之如果阈值设置为1400MB，那么超过阈值的部分就是700MB+1234B &gt; 700MB，此时Kafka会删除最老的那个日志段文件。</p></blockquote><blockquote><p><strong>咸淡一首诗</strong>:</p><p>对于failover机制，kafka会新建副本，从leader处同步最新的数据给新建副本。如果坏掉的盘是leader持久化的盘并且其他副本没有来的及从坏掉的leader分区同步最新数据，重新选举leader后岂不是也会丢失数据？？？</p><p>胡夕: 是的，这种情况会丢失数据。其实Kafka并没有承诺不丢失数据，而是在满足某些条件下才做持久化保证。</p></blockquote><h3 id="Topic级别参数"><a href="#Topic级别参数" class="headerlink" title="Topic级别参数"></a>Topic级别参数</h3><p><code>Topic</code> 级别参数会覆盖全局 <code>Broker</code> 参数的值，而每个 <code>Topic</code> 都能设置自己的参数值，这就是所谓的 <code>Topic</code> 级别参数。</p><ul><li><p><code>retention.ms</code>：该 <code>Topic</code> 消息被保存的时长。默认是 7 天，即该<code>Topic</code> 只保存最近 7 天的消息。一旦设置了这个值，它会覆盖掉 <code>Broker</code> 端的全局参数值。</p></li><li><p><code>retention.bytes</code>：规定了要为该 <code>Topic</code> 预留多大的磁盘空间。和全局参数作用相似，这个值通常在多租户的 <code>Kafka</code> 集群中会有用武之地。默认值是 -1，表示可以无限使用磁盘空间。</p></li><li><p><code>max.message.bytes</code>：决定了 <code>Kafka Broker</code>能够正常接收该 <code>Topic</code> 的最大消息大小</p></li></ul><h3 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h3><p>无脑给出一个通用的建议：将<code>JVM</code>堆大小设置成 6GB ，这是目前业界比较公认的一个合理值。很多人就是使用默认的 <code>Heap Size</code> 来跑 <code>Kafka</code>，默认的 1GB 有点小，毕竟 <code>Kafka Broker</code> 在与客户端进行交互时会在 <code>JVM</code> 堆上创建大量的 <code>ByteBuffer</code> 实例，<code>Heap Size</code> 不能太小。</p><p>Java 8，那么可以手动设置使用 G1 收集器。在没有任何调优的情况下，G1 表现得要比 CMS 出色，主要体现在更少的 Full GC，需要调整的参数更少等。</p><ul><li><code>KAFKA_HEAP_OPTS</code>：指定堆大小。</li><li><code>KAFKA_JVM_PERFORMANCE_OPTS</code>：指定 GC 参数。</li></ul><h3 id="操作系统参数"><a href="#操作系统参数" class="headerlink" title="操作系统参数"></a>操作系统参数</h3><ul><li>文件描述符限制： <code>ulimit -n</code> 通常情况下将它设置成一个超大的值是合理的做法，比如<code>ulimit -n 1000000</code>。其实设置这个参数一点都不重要，但不设置的话后果很严重，比如你会经常看到“Too many open files”的错误。</li><li>文件系统类型： 生产环境最好还是使用 XFS。最近有个 Kafka 使用 ZFS 的数据报告，貌似性能更加强劲，有条件的话不妨一试。</li><li>Swappiness：一旦设置成 0，当物理内存耗尽时，操作系统会触发 OOM killer 这个组件，它会随机挑选一个进程然后 kill 掉，即根本不给用户任何的预警。但如果设置成一个比较小的值，当开始使用 swap 空间时，至少能够观测到 Broker 性能开始出现急剧下降，从而有进一步调优和诊断问题的时间。基于这个考虑，建议将 swappniess 配置成一个接近 0 但不为 0 的值，比如 1。</li><li>提交时间：向 Kafka 发送数据并不是真要等数据被写入磁盘才会认为成功，而是只要数据被写入到操作系统的页缓存（Page Cache）上就可以了，随后操作系统根据 LRU 算法会定期将页缓存上的“脏”数据落盘到物理磁盘上。这个定期就是由提交时间来确定的，默认是 5 秒。一般情况下我们会认为这个时间太频繁了，可以适当地增加提交间隔来降低物理磁盘的写操作。当然你可能会有这样的疑问：如果在页缓存中的数据在写入到磁盘前机器宕机了，那岂不是数据就丢失了。的确，这种情况数据确实就丢失了，但鉴于 Kafka 在软件层面已经提供了多副本的冗余机制，因此这里稍微拉大提交间隔去换取性能还是一个合理的做法。小结</li></ul><blockquote><p><strong>saup007</strong>：</p><p>修改 Topic 级 max.message.bytes，还要考虑以下两个吧？<br>还要修改 Broker的 replica.fetch.max.bytes 保证复制正常<br>消费还要修改配置 fetch.message.max.bytes</p></blockquote><blockquote><p><strong>Hello world</strong>：</p><p>老师说的无脑配置给jvm heap 6G大小，这应该也看机器的吧，现在机器的内存也越来越大，我们这的机器都是64G 内存，配了16G的heap，老师觉得可以优化吗</p><p>胡夕: 虽然无脑推荐6GB，但绝不是无脑推荐&gt;6GB。一个16GB的堆Full GC一次要花多长时间啊，所以我觉得6GB可以是一个初始值，你可以实时监控堆上的live data大小，根据这个值调整heap size。只是因为大内存就直接调整到16GB，个人觉得不可取。</p><p>另外堆越小留给页缓存的空间也就越大，这对Kafka是好事。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka基本概念和常见结构模型</title>
      <link href="2021/10/06/kafka-ru-men-yi/"/>
      <url>2021/10/06/kafka-ru-men-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="Kafka入门一"><a href="#Kafka入门一" class="headerlink" title="Kafka入门一"></a>Kafka入门一</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20211006170052801.png"></p><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><p>生产者，负责创建消息，将其投送到<code>Kafka</code>中。</p><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>消费者，连接到<code>kafka</code>上并接收消息，进行相应的业务处理。</p><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p><code>Kafka</code> 的服务器端由被称为 <code>Broker</code> 的服务进程构成，即一个 <code>Kafka</code> 集群由多个 <code>Broker</code> 组成，<code>Broker</code> 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。虽然多个 <code>Broker</code> 进程能够运行在同一台机器上，但更常见的做法是将不同的 <code>Broker</code> 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 <code>Broker</code> 进程都挂掉了，其他机器上的 <code>Broker</code> 也依然能够对外提供服务。这其实就是 <code>Kafka</code> 提供高可用的手段之一。</p><h4 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h4><p>负责集群元数据管理，控制器的选举等操作。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%2058c35d3ab0921bf0476e3ba14069d291.jpg" alt="img"></p><h4 id="Topic-主题"><a href="#Topic-主题" class="headerlink" title="Topic(主题)"></a>Topic(主题)</h4><p>主题是一个逻辑上的概念。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</p><h4 id="Partition-分区"><a href="#Partition-分区" class="headerlink" title="Partition(分区)"></a>Partition(分区)</h4><p>一个主题下可以有多个分区，一个分区只属于单个主题。分区在存储层面可以看做一个可追加的日志文件。</p><h4 id="Offset-位移"><a href="#Offset-位移" class="headerlink" title="Offset(位移)"></a>Offset(位移)</h4><p>消息在被追加到分区日志文件的时候都会分配一个特定的偏移量。<code>offset</code>是消息在分区中的唯一标识，<code>Kafka</code>通过它来保证消息在分区内的顺序性。</p><p><strong>不过<code>offset</code>并不跨越分区，即<code>Kafka</code>保证的是分区有序而不是主题有序。</strong></p><h4 id="Replica-副本"><a href="#Replica-副本" class="headerlink" title="Replica(副本)"></a>Replica(副本)</h4><p><code>Kafka</code> 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。</p><p>副本还分为领导者副本（<code>Leader Replica</code>）和追随者副本(<code>Follower Replica</code>)，各自有不同的角色划分。</p><p>副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</p><p>副本的工作机制：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。</p><p>至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。</p><h4 id="Consumer-Group-消费者组"><a href="#Consumer-Group-消费者组" class="headerlink" title="Consumer Group(消费者组)"></a>Consumer Group(消费者组)</h4><p>消费者组：消费者实例共同组成一个组来消费一组主题。这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。</p><p>主要是为了提升消费者端的吞吐量。多个消费者实例同时消费，加速整个消费端的吞吐量（<code>TPS</code>）。</p><h4 id="Consumer-Offset"><a href="#Consumer-Offset" class="headerlink" title="Consumer Offset"></a>Consumer Offset</h4><p>每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是消费者位移（<code>Consumer Offset</code>）。</p><p>这和上面所说的位移完全不是一个概念。上面的“位移”表征的是分区内的消息位置，是不变的，即一旦消息被成功写入到一个分区上，它的位移值就是固定的了。</p><p>而消费者位移则不同，它可能是随时变化的，毕竟它是消费者消费进度的指示器嘛。另外每个消费者有着自己的消费者位移，因此一定要区分这两类位移的区别。消息在分区中的位移称为分区位移，而把消费者端的位移称为消费者位移。</p><h4 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h4><p>分区内所有副本被称为AR（<code>Assigned Replicas</code>）。所有与leader副本保持一定程度同步的副本（包括<code>leader</code>副本在内）组成<code>ISR</code>（<code>In-Sync Replicas</code>）。</p><p><code>ISR</code>集合是<code>AR</code>集合的一个子集。消息会先发送到<code>leader</code>副本，然后<code>follower</code>副本才能从<code>leader</code>副本中拉取消息进行同步，同步期间内<code>follower</code>副本相对<code>leader</code>副本而言会有一定程度的滞后。</p><p>“一定程度的同步”是指可忍受的滞后范围，这个范围可以通过参数进行配置。与<code>leader</code>副本同步滞后过多的副本（不包括<code>leader</code>副本）组成<code>OSR（Out-Of-Sync Replicas）</code>。</p><p>因此<code>AR=ISR+OSR</code>，正常情况下，所有的<code>follower</code>副本都应该与<code>leader</code>副本保持一定程度的同步，即<code>AR=ISR</code>，<code>OSR</code>集合为空。</p><p><code>leader</code>副本负责维护和跟踪<code>ISR</code>集合中所有的<code>follower</code>副本的滞后状态，当<code>follower</code>副本落后太多或失效时，<code>leader</code>副本会把他从<code>ISR</code>集合中剔除。</p><p>如果OSR集合中有<code>follower</code>副本追上了<code>leader</code>副本，那么副本会把它从<code>OSR</code>集合转移至<code>ISR</code>集合。默认情况下，当<code>leader</code>副本发生故障时，只有在<code>ISR</code>集合中的副本才有资格被选举为新的<code>leader</code>，而在<code>OSR</code>集合中的副本则没有任何机会（但是可以通过修改相应的参数配置来改变）。</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch索引流程</title>
      <link href="2021/10/03/elasticsearch-suo-yin-liu-cheng/"/>
      <url>2021/10/03/elasticsearch-suo-yin-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="Elasticsearch索引流程"><a href="#Elasticsearch索引流程" class="headerlink" title="Elasticsearch索引流程"></a>Elasticsearch索引流程</h3><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>分片是<code>Elasticsearch</code>中最小的工作单元，本质上是一个<code>Lucene</code>的<code>Index</code>。</p><p>对于一个<code>Lucene Index</code>它在ES中的基本结构是这样：</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20211003171434016.png" alt="image-20211003171434016"></p><p>一个<code>Lucene Index</code>中，单个倒排索引文件被称为<code>Segment</code>，其包含多个<code>Segment</code>，<code>Segment</code>是不可变更的。</p><p>在分片中查询时，会一次查询所有的<code>Segment</code>，然后汇总数据并返回。</p><p><code>Lucene</code>中有一个<code>Commit Point</code>文件，用来记录所有<code>Segment</code>的信息。另外一个是<code>.del</code>文件，该文件记录了被删除的文档的信息。</p><h4 id="索引步骤"><a href="#索引步骤" class="headerlink" title="索引步骤"></a>索引步骤</h4><p>当一个文档被写入时，它会经历以下几个步骤：<code>refresh</code> –&gt; <code>flush</code> –&gt; <code>merge</code>。</p><h5 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h5><p>当文档最初被写入时，会被写入一个叫<code>Index Buffer</code>的数据结构中，<code>Index Buffer</code>存在于<code>JVM</code>内存中。</p><p>此时文档是无法被搜索到的，它只是一个<code>buffer</code>，还没有形成倒排索引。</p><p>接着，ES会默认每隔1秒将<code>Index Buffer</code>清空，写入到<code>Segment</code>中，上面说了<code>Segment</code>就是一个倒排索引。</p><p>因此，此时文档已经被索引，即可以被搜索。</p><p>将<code>Index Buffer</code>写入到<code>Segment</code>的过程，就是<code>refresh</code>。</p><blockquote><p><code>refresh</code>的触发条件：</p><ul><li>通过**<code>index.refresh.interval</code>**控制<code>refresh</code>的执行时间间隔，默认是1秒。这也是为什么ES被称为近实时搜索的原因，因为数据要1秒后才能被搜到。</li><li>如果<code>Index buffer</code>空间被占满，也会触发<code>refresh</code>，即使执行时间间隔没到。<code>Index buffer</code>默认空间大小时<code>JVM</code>大小的10%</li></ul><p>Note:</p><p>可以通过API，进行手动<code>refresh</code>，使得数据能够立即被搜索到。</p></blockquote><h5 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h5><p>文档数据被写入<code>Index buffer</code>的同时，也会写入一个叫<code>Transaction log</code>（每个分片有一个）的文件中，这个文件存在的目的是为了保证ES数据的正确性。</p><p><code>Transaction log</code>这个文件，默认每5秒落一次盘，并且是顺序写。在ES断电重启时，会从这个文件中恢复数据进行<code>recover</code>。</p><p>但由于这个文件是5秒落一次盘，因此重启了还是可能丢掉5秒的数据。不过这个落盘间隔是可以配置的，最小是100ms。</p><p>显然，配置的落盘时间越小，数据准确性就越高，但同样会带来更多的性能成本。</p><p>默认每隔30分钟或者<code>Transaction log</code>满(默认512M)的时候，会触发<code>flush</code>。</p><p>当<code>flush</code>发生时，会执行以下几个步骤：</p><ul><li>调用一次<code>refresh</code>，清空<code>index buffer</code>，将其写入<code>segment</code></li><li>调用<code>fsync</code>，将内存中的<code>Segment</code>写入到磁盘</li><li>清空<code>Transaction log</code>，将其写入磁盘</li></ul><h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p><code>merge</code>是ES定期自动执行的</p><p><code>merge</code>操作主要做的内容：</p><ul><li>将多个segment合并成一个</li><li>将.del文件中要删除的文档进行一个真正的删除</li></ul><blockquote><p>手动<code>merge</code>：</p><p><code>POST my_index/_forcemerge</code></p></blockquote><h3 id="merge优化"><a href="#merge优化" class="headerlink" title="merge优化"></a>merge优化</h3><p><code>merge</code>实际上是一个比较重的操作，因此我们需要着手去优化。</p><p>本质上，<code>merge</code>就是将多个<code>Segment</code>合并成一个大的<code>Segment</code>。</p><p>如果<code>Segment</code>产生的太多太快，就会导致<code>merge</code>频繁发生，影响性能。</p><p>因此我们有2个方向可以优化：</p><p>降低分段产生的数量和频率：</p><ul><li>将<code>refresh interval</code>调整到分钟级别/<code>indices.memory.index_buffer_size</code>大小调大</li><li>尽量避免文档的更新操作</li></ul><p>降低最大分段的大小，避免较大的分段继续参与merge，节省系统资源。(最终会有多个分段)</p><ul><li><p><code>index.merge.policy.segments_per_tier</code> 默认为10，越小需要越多的合并操作</p><p>该属性指定了每层段的数量。较少的值带来较少的段。这意味着更多的合并操作，和更低的索引性能，默认值为10，其值应该不低。</p></li><li><p><code>index.merge.policy.max_merged_segment</code> 默认5GB 超过此大小后，就不再参与后续的合并操作</p></li></ul><p>其他优化点：</p><ul><li><p>当一个<code>index</code>不再有写入操作时，建议对其进行<code>force merge</code></p><p>提升查询速度，减少内存开销</p><p><code>POST my_index/_forcemerge?max_num_segments=1</code><br><code>GET _cat/segments/my_index?v</code></p><p>最好<code>force</code>成一个<code>Segment</code>，但是<code>force merge</code>会占用大量网络/IO/CPU</p><p>如果不能在业务高峰期前<code>merge</code>完，就需要增大最终的分段数</p><p>调整分片的大小/<code>index.merge.policy.max_merged_segment</code>大小</p></li></ul><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>若要优化索引速度，而不注重实时性，可降低<code>refresh</code>频率</li><li>当数据从hot移动到warm，官方建议手动执行以下<code>force merge</code></li><li>当节点数据量很大时，有重启节点的需要时，建议先手动<code>flush</code>，会节省很多时间</li><li><code>Transaction log</code>落盘的频率影响了数据的安全性</li><li><code>refresh</code>的频率影响了数据的实时性</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch选主流程</title>
      <link href="2021/10/03/elasticsearch-xuan-zhu-liu-cheng/"/>
      <url>2021/10/03/elasticsearch-xuan-zhu-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h3 id="Discovery"><a href="#Discovery" class="headerlink" title="Discovery"></a>Discovery</h3><p><code>Discovery</code>是集群组成模块寻找形成集群的其他节点的过程。</p><p>当你启动一个es节点或者一个节点认为master节点挂掉时这个过程就会开始执行了，直到master节点被找到或者选举出一个新master节点。</p><p>这个过程从来自一个或多个<code>seed hosts providers</code>提供的<code>seed addresses</code>开始，这些地址还包括最后一个被发现集群的<code>master-eligible</code>节点中的任何一个地址。</p><p>这个过程包含两步：</p><ol><li>每个节点通过连接<code>seed addresses</code>中的地址来进行探测，并且尝试去认证它连接到的节点，看是探测到的节点否是一个<code>master-eligible</code>节点</li><li>如果是<code>master-eligible</code>，它会探测到的这个<code>master-eligible</code>节点分享它已经发现的所有<code>master-eligible</code>节点，对方节点也会分享它自己同等的信息。然后节点根据获取到的信息，继续探测它没探测过的节点，获取它们的<code>master-eligible</code>节点列表。</li></ol><p>如果某个节点不是<code>master-eligible</code>节点，那么它会继续这个<code>Discovery</code>过程直到它找到master节点。如果一直没有master节点被选出来，那么这个节点会隔<code>discovery.find_peers_interval</code>时间重试，默认1s。</p><h3 id="Quorum-based-decision-making"><a href="#Quorum-based-decision-making" class="headerlink" title="Quorum-based decision making"></a>Quorum-based decision making</h3><p>选举一个主节点并改变集群状态是所有<code>master-eligible</code>节点必须共同完成的两个基础的任务。即使某些节点挂掉，这些任务也需要能够正常执行。</p><p>这种能够正常执行的稳健性，通过仲裁来实现，仲裁节点是<code>master-eligible</code>节点的子集。</p><p>只需要节点的子集进行仲裁优势在于：某些节点可能会发生故障，但不会阻止集群继续运行。</p><p>仲裁节点是经过认真选择的，因此集群不会出现“脑裂”场景。</p><p><strong>随着节点的添加或删除，Elasticsearch 通过更新集群的<code>voting configuration</code>来保持一个最佳的容错水平，<code>voting configuration</code>是一组<code>master-eligible</code>节点，在做出选择新主节点或提交新集群状态等决策时，这些节点的响应会被计算在内。</strong></p><p><strong>只有在<code>voting configuration</code>中超过一半的节点做出响应后，才会做出决定。</strong></p><p><strong>通常<code>voting configuration</code>中配置的节点集合就是当前集群中所有<code>master-eligible</code>节点的集合。但是在某些情况下，<code>voting configuration</code>中配置的节点可能会有所不同。（具体看完下文你就懂了）</strong></p><p><strong>为确保集群保持可用，不能同时停止<code>voting configuration</code>中的一半或更多节点。只要超过一半的投票节点可用，集群仍然可以正常工作。</strong></p><p><strong>这意味着如果有三个或四个<code>master-eligible</code>节点，集群可以容忍其中一个不可用。如果有两个或更少的符合主节点条件的节点，它们必须全部保持可用。</strong></p><p>在一个节点加入或离开集群之前，master节点必须提交一个集群状态更新来调整<code>voting configuration</code>,这个过程会花费短暂的时间。</p><p>在移除更多节点前，等待这个过程完成很重要。</p><h3 id="Master-elections"><a href="#Master-elections" class="headerlink" title="Master elections"></a>Master elections</h3><p>Elasticsearch uses an election process to agree on an elected master node, both at startup and if the existing elected master fails.</p><p>任何<code>master-eligible</code>节点都可以开始选举，通常第一次选举会成功。</p><p>选举通常只有在两个节点几乎同时开始选举时才会失败，因此Elasticsearch在每个节点上随机安排选举以降低发生这种情况的可能性。</p><p>节点会一直重试选举过程，直到选举出一个主节点。最终选举成功（具有任意高的概率）。主选举的调度由<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-settings.html#master-election-settings">master election settings</a>设置控制。</p><h3 id="Voting-configurations"><a href="#Voting-configurations" class="headerlink" title="Voting configurations"></a>Voting configurations</h3><p>每个Elasticsearch集群都有一个<code>voting configuration</code>，这个配置项包含的是一组<code>master-eligible</code>节点。当选举新的master节点或者更新集群状态时，</p><p>这组节点的响应会被考虑进决策的计算之内。只有大多数(超过半数)节点都投票响应时，才会做出对应的决策。</p><p>通常<code>voting configuration</code>的集合就是整个集群中所有的<code>master-eligible</code>节点，在一些特别的情况下回做出调整。</p><p>通过下面这个API获取集群当前的<code>voting configuration</code>:</p><p><code>curl -X GET &quot;localhost:9200/_cluster/state?filter_path=metadata.cluster_coordination.last_committed_config&amp;pretty&quot;</code></p><blockquote><p>有时候<code>voting configuration</code>中的配置甚至会包括一些不可用节点，可用的节点却不在里面。</p></blockquote><p>在选举master或者更新集群状态这种需要投票做决策的操作中，一般情况下，有资格投票的节点越多越好。所以当有新的<code>master-eligible </code>节点加入集群时，<code>Elasticsearch</code>倾向于将它加入<code>voting configuration</code>里。另一种情况是，如果集群中，一台属于<code>voting configuration</code>节点下线了，如果此时集群中有不存在于<code>voting configuration</code>的<code>master-eligible </code>节点存活，<code>Elasticsearch</code>会把那台下线的节点移出<code>voting configuration</code>,把存活的这台加进来。这样保证了<code>voting configuration</code>的弹性。</p><p>只有在整个集群第一次启动时才需要初始仲裁。 加入建立群集的新节点可以安全地获取所需的所有信息。节点将在重新启动时将所需的所有信息存储到磁盘中。</p><p>下面这段文章复制的，写的不错了，不需要改了。</p><h3 id="Raft算法选主流程"><a href="#Raft算法选主流程" class="headerlink" title="Raft算法选主流程"></a>Raft算法选主流程</h3><p>其设计原则如下：</p><ul><li>容易理解</li><li>减少状态的数量，尽可能消除不确定性</li></ul><p>在Raft中，节点可能的状态有三种，其转换关系如下：</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%2059o7j7ca4j.png"></p><p>正常情况下，集群中只有一个Leader，其他节点全是Follower。Follower 都是被动接收请求，从不主动发送任何请求。Candidate  [ˈkændɪdət; ˈkændɪdeɪt] n. 候选人，候补者；应试者  是从Follower到Leader的中间状态。</p><p><strong>Raft中引入任期(term) 的概念，每个term内最多只有一个Leader。term 在Raft算法中充当逻辑时钟的作用。服务器之间通信的时候会携带这个term，如果节点发现消息中的term小于自己的term，则拒绝这个消息；如果大于本节点的term，则更新自己的term。如果一个Candidate或者Leader发现自己的任期过期了，它会立即回到Follower状态。</strong></p><p>Raft选举流程为：</p><ul><li><strong>增加当前节点本地的current term，切换到Candidate状态；</strong></li><li><strong>当前节点投自己一票，并且并行给其他节点发送RequestVote RPC (让大家投他) ；</strong></li></ul><p>然后等待其他节点的响应，会有如下三种结果：</p><ul><li><strong>如果接收到大多数服务器的选票，那么就变成Leader。成为Leader后，向其他节点发送心跳消息来确定自己的地位并阻止新的选举。</strong></li><li><strong>如果收到了别人的投票请求，且别人的term比自己的大，那么候选者退化为Follower；</strong></li><li><strong>如果选举过程超时，再次发起一轮选举；</strong></li></ul><h3 id="ES实现Raft算法选主流程"><a href="#ES实现Raft算法选主流程" class="headerlink" title="ES实现Raft算法选主流程"></a>ES实现Raft算法选主流程</h3><p><strong>ES实现中，候选人不先投自己，而是直接并行发起RequestVote，这相当于候选人有投票给其他候选人的机会。这样的好处是可以在一定程度上避免3个节点同时成为候选人时，都投自己，无法成功选主的情况。</strong></p><p><strong>ES不限制每个节点在某个term上只能投一票， 节点可以投多票，这样会产生选出多个主的情况：</strong></p><ul><li>Node2被选为主，收到的投票为：Node2、 Node3；</li><li>Node3被选为主，收到的投票为：Node3、 Node1；</li></ul><p>对于这种情况，ES的处理是让最后当选的Leader成功，作为Leader。如果收到RequestVote请求，他会无条件退出Leader状态。在本例中，Node2先被选为主，随后他收到Node3的RequestVote请求，那么他退出Leader状态，切换为CANDIDATE，并同意向发起RequestVote候选人投票。因此最终Node3成功当选为Leader。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%202acsf1tnyf.png"></p><h3 id="动态维护参选节点列表"><a href="#动态维护参选节点列表" class="headerlink" title="动态维护参选节点列表"></a>动态维护参选节点列表</h3><p>在此之前，我们讨论的前提是在集群节点数量不变的情况下，现在考虑下集群扩容、缩容、节点临时或永久离线时是如何处理的。在7.x之前的版本中，用户需要手工配置<code>minimum_master_nodes</code>, 来明确告诉集群过半节点数应该是多少，并在集群扩缩容时调整他。现在，集群可以自行维护。</p><p>在取消了<code>discovery.zen.minimum_master_nodes</code> 配置后，现在的做法不再记录“quorum”法定数量的具体数值，取而代之的是记录一个节点列表，这个列表中保存所有具备master资格的节点(有些情况下不是这样，例如集群原本只有1个节点，当增加到2个的时候，这个列表维持不变，因为如果变成2，当集群任意节点离线，都会导致无法选主。这时如果再增加一个节点，集群变成3个，这个列表中就会更新为3个节点)，称为<code>VotingConfiguration</code>，他会持久化到集群状态中。</p><p><strong>在节点加入或离开集群之后，Elasticsearch 会自动对<code>VotingConfiguration</code> 做出相应的更改，以确保集群具有尽可能高的弹性。</strong>在从集群中删除更多节点之前，等待这个调整完成是很重要的。你不能一次性停止半数或更多的节点。(感觉大面积缩容时候这个操作就比较感人了，一部分一部分缩)。<strong>默认情况下，ES自动维护VotingConfiguration。</strong>有新节点加入的时候比较好办，但是当有节点离开的时候，他可能是暂时的重启，也可能是永久下线。你也可以人工维护VotingConfiguration，配置项为：<code>cluster.auto_shrink_voting_configuration</code>，当你选择人工维护时，有节点永久下线，需要通过<code>voting exclusions API</code>将节点排除出去。如果使用默认的自动维护<code>VotingConfiguration</code>，也可以使用<code>voting exclusions API</code>来排除节点，例如一次性下线半数以上的节点。</p><p>如果在维护<code>VotingConfiguration</code>时发现节点数量为偶数，ES会将其中一个排除在外，保证<code>VotingConfiguration</code>是奇数。因为当是偶数的情况下，网络分区将集群划分为大小相等的两部分，那么两个子集群都无法达到“多数”的条件。</p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/voting-config-exclusions.html">Voting configuration exclusions API</a></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">POST</span> <span class="token operator">/</span>_cluster<span class="token operator">/</span>voting_config_exclusions<span class="token operator">?</span>node_names<span class="token operator">=</span><span class="token operator">&lt;</span>node_names<span class="token operator">></span><span class="token constant">POST</span> <span class="token operator">/</span>_cluster<span class="token operator">/</span>voting_config_exclusions<span class="token operator">?</span>node_ids<span class="token operator">=</span><span class="token operator">&lt;</span>node_ids<span class="token operator">></span><span class="token constant">DELETE</span> <span class="token operator">/</span>_cluster<span class="token operator">/</span>voting_config_exclusionsAdds nodes named nodeName1 and nodeName2 to the voting configuration exclusions list<span class="token operator">:</span><span class="token constant">POST</span> <span class="token operator">/</span>_cluster<span class="token operator">/</span>voting_config_exclusions<span class="token operator">?</span>node_names<span class="token operator">=</span>nodeName1<span class="token punctuation">,</span>nodeName2Remove all exclusions from the list<span class="token operator">:</span><span class="token constant">DELETE</span> <span class="token operator">/</span>_cluster<span class="token operator">/</span>voting_config_exclusions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-hosts-providers.html">Elasticsearch Guide [7.15] » Set up Elasticsearch » Discovery and cluster formation » Discovery</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-quorums.html">Elasticsearch Guide [7.15] » Set up Elasticsearch » Discovery and cluster formation » Quorum-based decision making</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-voting.html">Elasticsearch Guide [7.15] » Set up Elasticsearch » Discovery and cluster formation » Voting configurations</a></p><p><a href="https://cloud.tencent.com/developer/article/1826426">ElasticSearch 7.x之后选主流程</a></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档的父子关系</title>
      <link href="2021/09/23/wen-dang-de-fu-zi-guan-xi/"/>
      <url>2021/09/23/wen-dang-de-fu-zi-guan-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="文档的父子关系"><a href="#文档的父子关系" class="headerlink" title="文档的父子关系"></a>文档的父子关系</h1><h3 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">DELETE my_blogs# 设定 Parent/Child MappingPUT my_blogs<span class="token punctuation">&#123;</span>  <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"number_of_shards"</span><span class="token operator">:</span> <span class="token number">2</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"properties"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"blog_comments_relation"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"join"</span><span class="token punctuation">,</span>        <span class="token property">"relations"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token property">"blog"</span><span class="token operator">:</span> <span class="token string">"comment"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token property">"title"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>#索引父文档PUT my_blogs/_doc/blog1<span class="token punctuation">&#123;</span>  <span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"Learning Elasticsearch"</span><span class="token punctuation">,</span>  <span class="token property">"content"</span><span class="token operator">:</span><span class="token string">"learning ELK @ geektime"</span><span class="token punctuation">,</span>  <span class="token property">"blog_comments_relation"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"blog"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>#索引父文档PUT my_blogs/_doc/blog2<span class="token punctuation">&#123;</span>  <span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"Learning Hadoop"</span><span class="token punctuation">,</span>  <span class="token property">"content"</span><span class="token operator">:</span><span class="token string">"learning Hadoop"</span><span class="token punctuation">,</span>    <span class="token property">"blog_comments_relation"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"blog"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>#索引子文档PUT my_blogs/_doc/comment1?routing=blog1<span class="token punctuation">&#123;</span>  <span class="token property">"comment"</span><span class="token operator">:</span><span class="token string">"I am learning ELK"</span><span class="token punctuation">,</span>  <span class="token property">"username"</span><span class="token operator">:</span><span class="token string">"Jack"</span><span class="token punctuation">,</span>  <span class="token property">"blog_comments_relation"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"comment"</span><span class="token punctuation">,</span>    <span class="token property">"parent"</span><span class="token operator">:</span><span class="token string">"blog1"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>#索引子文档PUT my_blogs/_doc/comment2?routing=blog2<span class="token punctuation">&#123;</span>  <span class="token property">"comment"</span><span class="token operator">:</span><span class="token string">"I like Hadoop!!!!!"</span><span class="token punctuation">,</span>  <span class="token property">"username"</span><span class="token operator">:</span><span class="token string">"Jack"</span><span class="token punctuation">,</span>  <span class="token property">"blog_comments_relation"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"comment"</span><span class="token punctuation">,</span>    <span class="token property">"parent"</span><span class="token operator">:</span><span class="token string">"blog2"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>#索引子文档PUT my_blogs/_doc/comment3?routing=blog2<span class="token punctuation">&#123;</span>  <span class="token property">"comment"</span><span class="token operator">:</span><span class="token string">"Hello Hadoop"</span><span class="token punctuation">,</span>  <span class="token property">"username"</span><span class="token operator">:</span><span class="token string">"Bob"</span><span class="token punctuation">,</span>  <span class="token property">"blog_comments_relation"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>    <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"comment"</span><span class="token punctuation">,</span>    <span class="token property">"parent"</span><span class="token operator">:</span><span class="token string">"blog2"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span># 查询所有文档POST my_blogs/_search<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>#根据父文档ID查看GET my_blogs/_doc/blog2# Parent Id 查询POST my_blogs/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"parent_id"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"comment"</span><span class="token punctuation">,</span>      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"blog2"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span># Has Child 查询<span class="token punctuation">,</span>返回父文档POST my_blogs/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"has_child"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"comment"</span><span class="token punctuation">,</span>      <span class="token property">"query"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                    <span class="token property">"username"</span> <span class="token operator">:</span> <span class="token string">"Jack"</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span># Has Parent 查询，返回相关的子文档POST my_blogs/_search<span class="token punctuation">&#123;</span>  <span class="token property">"query"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"has_parent"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"parent_type"</span><span class="token operator">:</span> <span class="token string">"blog"</span><span class="token punctuation">,</span>      <span class="token property">"query"</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"match"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                    <span class="token property">"title"</span> <span class="token operator">:</span> <span class="token string">"Learning Hadoop"</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>#通过ID ，访问子文档GET my_blogs/_doc/comment3#通过ID和routing ，访问子文档GET my_blogs/_doc/comment3?routing=blog2#更新子文档PUT my_blogs/_doc/comment3?routing=blog2<span class="token punctuation">&#123;</span>    <span class="token property">"comment"</span><span class="token operator">:</span> <span class="token string">"Hello Hadoop??"</span><span class="token punctuation">,</span>    <span class="token property">"blog_comments_relation"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"comment"</span><span class="token punctuation">,</span>      <span class="token property">"parent"</span><span class="token operator">:</span> <span class="token string">"blog2"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-has-child-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-has-child-query.html</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-has-parent-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-has-parent-query.html</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-parent-id-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-parent-id-query.html</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-parent-id-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-parent-id-query.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倒排索引</title>
      <link href="2021/08/27/dao-pai-suo-yin/"/>
      <url>2021/08/27/dao-pai-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>倒排索引或反向索引(Inverted Index)，是一种索引数据结构。与倒排索引相对的叫正排索引或正向索引(forward index)。</p><p>现在借助阐述正排索引来更好理解倒排索引。</p><h2 id="正排索引"><a href="#正排索引" class="headerlink" title="正排索引"></a>正排索引</h2><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210826212916989.png" alt="正排索引数据结构示例"></p><p>如上图，我们可以通过<code>doc_id =2</code>很快查到<code>&#123;&quot;name&quot;:&quot;zwl&quot;,&quot;age&quot;:21&#125;</code>这条数据。</p><p>这意味着我们可以通过<code>doc_id</code>很快查到一个具体的数据对象。</p><pre class="line-numbers language-none"><code class="language-none">Document                          wordsdoc1                              hello, sky, morning      doc2                              tea, coffee, hidoc3                              greetings, sky<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或如上面所示，假设我们有3个文档，我们将文档和文档中的单词建立映射关系。</p><p>这样我们可以通过文档ID，快速得到这篇文档中有哪些单词。</p><p><strong>但是，如果要找出有哪些文档中有<code>sky</code>这个单词，就需要查找所有文档，将有对应单词的文档汇总起来，这无疑是一种很低效的过程。</strong></p><p>像上面举的例子，将文档ID与文档内容映射起来的数据结构，称为正排索引。</p><p>正排索引，本质是通过<code>key</code>来查找<code>value</code>，可以理解为一种散列表的形式。</p><p>如果我们想要在一个博客网站中，找到哪些博客的内容里有单词<code>rich</code>，将所有博客内容遍历再汇总的方法，时间成本很高，实际业务中肯定无法接受。</p><p>这种场景就非常适合倒排索引。</p><h2 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>既然正排索引是文档映射单词，通过文档查找单词，那么触类旁通，倒排索引就是单词映射文档，通过单词找到文档。</p><p>对于上面的3个文档，我们重建一种数据结构，左边是单词，右边是这个单词在哪个文档里出现。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210826215134255.png" alt="倒排索引数据结构示例"></p><p>这时候我们将单词和文档ID映射起来，此时再查找哪些文档中含有<code>sky</code>，就能很快搜索到结果，即<code>[doc1,doc3]</code>，再通过ID就可以找到对应的文档。</p><p>这种结构就是倒排索引。</p><p>由倒排索引，引出来一些相关的术语和概念。</p><h3 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档 Document"></a>文档 Document</h3><p><code>document</code>本质是以文本形式存在的数据对象。但像谷歌，百度这种搜索引擎，处理的是海量的互联网网页，那么文档的概念就要更宽泛一些，像Word，PDF，XML，HTML都属于文档，或者一条微博，一封邮件都属于文档范畴。</p><h3 id="文档ID-Document-ID"><a href="#文档ID-Document-ID" class="headerlink" title="文档ID Document ID"></a>文档ID Document ID</h3><p>文档存储进互联网系统内部，都会为其赋值一个ID，来作为这个文档的唯一标识，通过<code>doc_id</code>，快速的查找文档。</p><h3 id="倒排列表-Posting-list"><a href="#倒排列表-Posting-list" class="headerlink" title="倒排列表 Posting list"></a>倒排列表 Posting list</h3><p>上图中，document就是一个<code>posting list</code>，<code>posting list</code>记录了出现过某个单词的所有文档以及该单词出现在该文档的位置的信息。根据<code>posting list</code>，即可知道哪些文档包含指定单词。<code>posting list</code>由倒排索引项组成。</p><ul><li>倒排索引项<ul><li>文档ID <code>doc_id</code></li><li>词频 <code>TF</code> 该单词在文档中出现的次数，用于文档的相关性评分</li><li>位置 <code>position</code> 单词在文档中分词的位置，可以用来语句搜索(<code>phrase query</code>)</li><li>偏移 <code>offset</code> 记录单词的开始和结束位置，可以用来高亮显示</li></ul></li></ul><h3 id="单词词典-Term-Dictionary"><a href="#单词词典-Term-Dictionary" class="headerlink" title="单词词典 Term Dictionary"></a>单词词典 Term Dictionary</h3><p><code>term dictionary</code>即包含了系统所存储的所有文档中出现的单词，每个单词会指向对应的倒排列表。</p><ul><li><code>term dictionary</code>一般比较大，可以通过B+数或者哈希拉链法实现，以满足高性能的查询。</li></ul><h3 id="单词索引-Term-Index"><a href="#单词索引-Term-Index" class="headerlink" title="单词索引 Term Index"></a>单词索引 Term Index</h3><p><code>term dictionary</code>包含了所有文档出现的所有单词，往往是很大的。很难放到内存中来提供程序查询，但放到磁盘上，多次的IO又降低了查询的性能。</p><p>因此产生了<code>term index</code>，<code>term index</code>就是对<code>term dictionary</code>进行索引，将占用空间小的<code>term index</code>放入内存中，方便我们快速的查找<code>term dictionary</code>。</p><h3 id="分词-Analysis"><a href="#分词-Analysis" class="headerlink" title="分词 Analysis"></a>分词 Analysis</h3><p>如何正确地区分文档中的单词，并和<code>term dictionary</code>形成映射，这一过程成为分词。</p><p>举例：<code>Apple is a company. And i like eat apples.</code>这句话可以分词为<code>apple</code>/<code>is</code>/<code>a</code>/<code>company</code>/<code>and</code>/<code>i</code>/<code>like</code>/<code>eat</code>，<code>apple</code>&amp;<code>apples</code>由于在搜索中几乎没有影响，我们可以全分到单数形式。</p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p>基于上面的概念，我们可以画一个倒排索引在实际应用中大概的结构图。</p><p>假设某文档<code>doc_id=2</code>，其内容是<code>i am a rich man.</code></p><p>那么如下图，我们通过<code>term index</code>找到<code>term diciionary</code>中<code>rich</code>，再通过<code>rich</code>指向的<code>posting list</code>，找到对应的信息。</p><p>对应的信息包含了<code>doc_id</code>为2，出现的位置(<code>offset</code>)是4，词频<code>TF</code>是1。根据<code>posting list</code>的信息，我们就可以找到目标文档。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210826225100195.png" alt="倒排索引结构"></p><h2 id="Lucene中的应用"><a href="#Lucene中的应用" class="headerlink" title="Lucene中的应用"></a>Lucene中的应用</h2><p><code>Elasticsearch</code>是构建在<code>Apache Lucene</code>之上的分布式搜索引擎。</p><p>现在来看下<code>Lucene</code>中的倒排索引是如何构成的，基本的结构其实就是这样：</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210826231235722.png"></p><p>我们通过一个例子来进一步理解：</p><p>假如我们有一些人名的<code>term</code>:</p><p><strong><code>cindy</code>,<code>debbie</code>,<code>erwin</code>,<code>bob</code>,<code>adele</code></strong></p><p>我们要为它们构建<code>posting list</code>。</p><p>但是如果按这样的顺序在<code>term dictionary</code>中查找，由于是无序的，无疑是很慢的。</p><p>如果在排序之后：</p><p><strong><code>adele</code>,<code>bob</code>,<code>cindy</code>,<code>debbie</code>,<code>erwin</code></strong></p><p>我们就可以用二分查找的方式，能够比全部遍历更快地找出目标<code>term</code>，通过<code>O(logN)</code>次磁盘查找得到目标。</p><p>但是磁盘IO是非常昂贵的，所以要尽量少读盘。</p><p>因此必要把一些数据放入内存中。但是又因为<code>term dictionary</code>太大了，无法完整放入内存中，就需要有<code>term index</code>。</p><h3 id="Term-Index的数据结构"><a href="#Term-Index的数据结构" class="headerlink" title="Term Index的数据结构"></a>Term Index的数据结构</h3><p><code>term index</code>实际实现是<code>trie</code>树。(关于<code>trie tree</code>请点击<a href="https://www.geeksforgeeks.org/trie-insert-and-search/">这里</a>）</p><p>这棵树不会包含所有的<code>term</code>，它包含的是一些<code>term</code>的前缀，这样可以通过它快速定位到以某些前缀开头的单词的<code>offset</code>，定位好之后，再从定位的位置查找<code>term dictionary</code>。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20e4632ac1392b01f7a39d963fddb1a1e0.png"></p><p>这种数据结构，再加上压缩技术(Lucene Finite State Transducers)，<code>term index</code>可以只有所有<code>term</code>的几十分之一，以实现能够将<code>term index</code>放入内存中。</p><h3 id="多字段查询下的优化"><a href="#多字段查询下的优化" class="headerlink" title="多字段查询下的优化"></a>多字段查询下的优化</h3><p>如果一个查询，我们要求查询内容包含<code>name = cindy and age = 18</code>的文档，我们可能得到以下的数据。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210826234827883.png"></p><p>显然，满足条件的数据是<code>doc_id = [1,4]</code>。</p><p>我们应该如何找到满足条件的数据？</p><p>最直接的办法，遍历所有满足条件的<code>doc_id</code>集合,找出重复的<code>doc_id</code>，这种方式的效率明显很低。</p><p>有两种优化的办法：</p><ul><li>使用<code>skip list</code>数据结构，同时遍历<code>name</code>和<code>age</code>的<code>posting list</code>，互相<code>skip</code></li><li>使用<code>bitmap</code>数据结构，对<code>name</code>和<code>age</code>两个<code>posting list</code>分别求出<code>bitmap</code>，两个<code>bitmap</code>做与操作</li></ul><h4 id="利用skip-list"><a href="#利用skip-list" class="headerlink" title="利用skip list"></a>利用<code>skip list</code></h4><p>假设我们查询条件为<code>name = zwl and age = 18 and gener = male</code>，得到的结果是3个<code>posting list</code>的文档结果如下：</p><blockquote><p>name = zwl的结果               [3,4,5,6]</p><p>age = 18的结果                    [1,3,5]</p><p>gender = male的结果         [2,3,4,5,9]</p></blockquote><p>很明显，得到的正确结果应该是<code>doc_id = [3,5]</code></p><p>现在来看下<code>Lucene</code>中是如何利用<code>skip list</code>来取出交集的:</p><ol><li><p>将3个<code>posting list</code>抽象化成节点</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210827203206116.png"></p></li><li><p>维护一个链表，里面存储每个<code>posting list</code>的第一个节点，并将存储的节点按<code>doc_id</code>由小到大排序</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210827203527548.png"></p></li><li><p>维护两个指针，一个为<code>min</code>指针，从最小的节点开始从左向右移动，一个为<code>max</code>指针，固定在<code>doc_id</code>最大的节点</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210827204017585.png"></p></li><li><p>此时，指针<code>min</code>指向<code>doc_value=1</code>的节点，与<code>max</code>指向的<code>doc_value</code>=3比较，因为如果想要取得交集，至少需要有<code>doc_id=3</code>的节点。</p><p>在这里我们可以把第一个<code>posting list</code>中<code>doc_id&lt;3</code>的全部移除，让3成为第一个节点，接着<code>min</code>移向下一个节点</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210827211310208.png"></p></li></ol><ol start="5"><li><p>同样，2也无法与3取得交集，重复第4步，此时<code>min</code>走到了最后一个节点，第一轮比较完成，我们发现第一行都是<code>doc_id=3</code>，则3是我们取到的第一个交集。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210827211539429.png"></p></li><li><p>接着我们重新排序，重复上面的步骤，此时<code>min= 4</code>，<code>max=5</code></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210827212100882.png"></p></li><li><p>重复步骤，4可以直接移除，5可以保留，最后得到交集<code>[3,5]</code></p></li></ol><p>这样，利用跳表的思想，可以很快跳过哪些无法取得交集的节点，快速实现取得交集。</p><h4 id="利用bitmap"><a href="#利用bitmap" class="headerlink" title="利用bitmap"></a>利用<code>bitmap</code></h4><p>利用<code>bitmap</code>的思想要更直观一些。</p><p>比如</p><p><code>posting list1 = [1,3,4,7,10]</code>，用<code>bitmap</code>表示就是<code>[1,0,1,1,0,0,1,0,0,1]</code> </p><p><code>posting list2 = [3,4,7]</code>，<code>bitmap</code>就是<code>[0,0,1,1]</code></p><p>两个<code>bitmap</code>进行<code>AND</code>操作就能得到交集<code>[0,0,1,1]</code>，即<code>doc_id = [3,4]</code></p><blockquote><p><code>bitmap</code>自身就有压缩的特点，其用一个<code>byte</code>就可以代表 8 个文档。所以 100 万个文档只需要 12.5 万个 <code>byte</code>。</p><p>但是考虑到文档可能有数十亿之多，在内存里保存 <code>bitmap</code>仍然是很奢侈的事情。</p><p>而且对于个每一个 <code>filter</code> 都要消耗一个 <code>bitmap</code>，比如 age=18 缓存起来的话是一个 <code>bitmap</code>，<code>18&lt;=age&lt;25</code> 是另外一个 <code>filter</code> 缓存起来也要一个 <code>bitmap</code>。</p><p>所以秘诀就在于需要有一个数据结构：</p><ul><li>可以很压缩地保存上亿个 <code>bit</code> 代表对应的文档是否匹配 <code>filter</code>；</li><li>这个压缩的 <code>bitmap</code> 仍然可以很快地进行 <code>AND</code> 和 <code>OR</code> 的逻辑操作。</li></ul><p><code>Lucene</code> 使用的这个数据结构叫做 <code>Roaring Bitmap</code>。</p><p><img src="https://static001.infoq.cn/resource/image/94/7e/9482b84c4aa3fb77a959c1ead553037e.png"></p><p>其压缩的思路其实很简单。与其保存 100 个 0，占用 100 个 <code>bit</code>。还不如保存 0 一次，然后声明这个 0 重复了 100 遍。</p></blockquote><p>关于两种方式性能的对比，<code>Elasticsearch</code>官方做了详细的对比，详情点击<a href="https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps">这里</a>。</p><p>总的来说，跳表的效率要比<code>bitmap</code>好。</p><h2 id="Term-Index与MySQL-B-树的比较"><a href="#Term-Index与MySQL-B-树的比较" class="headerlink" title="Term Index与MySQL B+树的比较"></a>Term Index与MySQL B+树的比较</h2><ul><li><p><code>MySQL</code> 只有 <code>term dictionary </code>这一层，是以 <code>b+ tree </code>排序的方式存储在磁盘上的。</p><p>检索一个<code>term</code> 需要若干次的 <code>random access</code> 的磁盘操作。</p><p>而 <code>Lucene</code> 在 <code>term dictionary</code> 的基础上添加了 <code>term index</code> 来加速检索，<code>term index</code> 以树的形式缓存在内存中。</p><p>从 <code>term index</code> 查到对应的 <code>term dictionary</code> 的 <code>block</code> 位置之后，再去磁盘上找 <code>term</code>，大大减少了磁盘 <code>random access</code> 次数。</p></li><li><p><code>term index</code> 在内存中是以 <code>FST（finite state transducers）</code>的形式保存的，其特点是非常节省内存。</p><p><code>term dictionary</code> 在磁盘上是以分 <code>block</code> 的方式保存的，一个 <code>block</code> 内部利用公共前缀压缩，比如都是 <code>Ab</code> 开头的单词就可以把 <code>Ab</code> 省去。</p><p>这样 <code>term dictionary</code> 可以比 <code>b-tree</code> 更节约磁盘空间</p></li></ul><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/%20images/%20image-20210827214312547.png"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用插件推荐</title>
      <link href="2021/02/04/idea-chang-yong-cha-jian/"/>
      <url>2021/02/04/idea-chang-yong-cha-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA常用插件推荐"><a href="#IDEA常用插件推荐" class="headerlink" title="IDEA常用插件推荐"></a>IDEA常用插件推荐</h3><p>推荐几款常用的IDEA插件：(不定期更新)</p><ul><li>IDE Eval Reset ——曲线救国式获得IDEA专业版永久使用权</li><li>Background Image Plus + ——为你的IDEA设置背景图片</li><li>CodeGlance ——为你的代码生成缩略图，方便浏览</li><li>Grep Console ——为控制台不同级别的日志设置颜色，方便调试</li><li>Rainbow Brackets —— 自动将代码中的括号标签等生成颜色，方便区分</li><li>Statistic —— 统计代码行数</li><li>Translation —— 实时翻译，看源码文档的时候很方便找翻译</li><li>Material Theme UI —— 提供十几种主题和自定义主题，让你的IDEA变得好看起来</li><li>Atom Material Icons —— 替换IDEA中的所有图标，对按钮和文件夹的表现更美观和清晰</li><li>Free MyBatis plugin —— 生成XML文件/提供mapper接口与XML文件跳转按钮/Mybatis自动补全和语法提示</li><li>Easy Code —— 根据数据库中的表一键生成entity/controller/service/dao/mapper</li></ul><h4 id="IDE-Eval-Reset"><a href="#IDE-Eval-Reset" class="headerlink" title="IDE Eval Reset"></a>IDE Eval Reset</h4><p>如何不花钱获得IDEA专业版的使用权？</p><ul><li><del>网上找激活码</del></li><li><del>用破解软件</del></li><li><del>试用30天</del></li></ul><p>如果有一种方法，能够无限延长IDEA专业版的试用时间，其实就跟永久使用一样。</p><ul><li><p>获得方式</p><ol><li>插件市场安装<ul><li>在<code>Settings/Preferences...</code> -&gt; <code>Plugins</code> 内手动添加第三方插件仓库地址：<code>https://plugins.zhile.io</code></li><li>搜索：<code>IDE Eval Reset</code>插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？</li><li>插件会提示安装成功。</li></ul></li><li>下载安装<ul><li>点击这个<a href="https://plugins.zhile.io/files/ide-eval-resetter-2.1.13.zip">链接(v2.1.13)</a>下载插件的<code>zip</code>包（macOS可能会自动解压，然后把<code>zip</code>包丢进回收站）</li><li>通常可以直接把<code>zip</code>包拖进IDE的窗口来进行插件的安装。如果无法拖动安装，你可以在<code>Settings/Preferences...</code> -&gt; <code>Plugins</code> 里手动安装插件（<code>Install Plugin From Disk...</code>）</li><li>插件会提示安装成功。</li></ul></li></ol></li><li><p>使用方式</p><ul><li><p>安装好插件，重启IDEA后，插件就已经开始工作，它会获取你当前IDEA的试用信息，用于重置试用时间。</p></li><li><p>当你超过25天没有重置试用时间后，插件会自动弹出通知框通知你是否重置试用时间。重置后，会继续获得30天的试用时间。</p></li><li><p>也可以主动唤起插件界面</p><ul><li><p>如果IDE没有打开项目，在<code>Welcome</code>界面点击菜单：<code>Get Help</code> -&gt; <code>Eval Reset</code></p></li><li><p>如果IDE打开了项目，点击菜单：<code>Help</code> -&gt; <code>Eval Reset</code></p></li><li><p>如图所示</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204205019356.png" alt="插件主界面"></p></li><li><p>左边两个红色框，显示了上次重置时间和试用到期时间</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204205209606.png" alt="试用时间信息"></p><p>也可以通过<code>Help</code> -&gt; <code>About</code>查看</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204205315856.png" alt="验证试用时间"></p></li><li><p>右下角勾选<code>Auto reset before per start</code>，即插件在每次重启的时候都会重置试用信息。（一劳永逸式操作）</p></li><li><p><code>RESET</code>按钮是手动重置试用信息，<code>RELOAD</code>按钮是重置后加载试用信息。</p></li></ul></li></ul></li><li><p>更新方式</p><ul><li>IDEA会自动检查插件更新，提示更新</li><li>从<a href="https://zhile.io/2020/11/18/jetbrains-eval-reset.html">Jetbrains系列产品重置试用方法</a>页面获取最新zip包</li></ul></li><li><p>注意</p><p><strong>重置需要重启IDEA!</strong></p><p><strong>别乱更新升级IDEA！</strong></p></li><li><p>插件作者</p><p><a href="https://zhile.io/">知了</a></p></li></ul><h4 id="Background-Image-Plus"><a href="#Background-Image-Plus" class="headerlink" title="Background Image Plus +"></a>Background Image Plus +</h4><ul><li><p>功能点：</p><ul><li>设置背景图片</li><li>固定时间随机切换</li><li>设置图片透明度</li></ul></li><li><p>获得方式</p><p>插件市场搜索并安装</p></li><li><p>使用</p><ul><li><p><code>File</code> -&gt; <code>Settings</code> -&gt; <code>Appearance &amp; Behavior</code> -&gt;<code>Background Image Plus</code></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204210835871.png" alt="插件设置页面"></p><p>如图，可以设置图片所在的文件夹，图片切换时间，图片切换模式，是否保持一张图片不变等。</p></li><li><p><code>File</code> -&gt; <code>Settings</code> -&gt; <code>Appearance &amp; Behavior</code> -&gt; <code>Background Image</code>按钮</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204211344200.png" alt="设置图片属性"></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204211425263.png" alt="image-20210204211425263"></p><p>点击<code>BACKGROUND IMAGE</code>按钮可以设置单张图片的属性，如透明度，填充模式等。</p></li><li><p><code>View</code> -&gt; <code>Background Image Plus</code> 可以切换图片</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204211657140.png" alt="点击切换图片"></p></li></ul></li><li><p>效果图</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204211740084.png" alt="效果图"></p></li></ul><h4 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h4><ul><li><p>使用</p><p>插件市场搜索安装后即可使用</p></li><li><p>设置</p><p><code>File</code> -&gt; <code>Settings</code> -&gt; <code>Other Settings</code> -&gt; <code>CodeGlance</code>进行自定义化的设置</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204215601337.png" alt="设置选项"></p></li><li><p>效果</p><p>这样查找代码和拖动十分方便</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204213138304.png" alt="效果图"></p></li></ul><h4 id="Grep-Console"><a href="#Grep-Console" class="headerlink" title="Grep Console"></a>Grep Console</h4><ul><li><p>插件市场搜索安装</p></li><li><p>设置</p><p><code>File</code> -&gt; <code>Settings</code> -&gt; <code>Other Settings</code> -&gt; <code>Grep Console</code>进行自定义化的设置</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204220101252.png" alt="image-20210204220101252"></p></li><li><p>效果图</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204215336103.png" alt="效果图"></p></li></ul><h4 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h4><ul><li><p>插件市场搜索安装</p></li><li><p>设置</p><p><code>File</code> -&gt; <code>Settings</code> -&gt; <code>Other Settings</code> -&gt; <code>Rainbow Brackets</code>进行自定义化的设置</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204215641644.png" alt="效果图"></p></li><li><p>效果图</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204215440484.png" alt="效果图"></p></li></ul><h4 id="Statistic"><a href="#Statistic" class="headerlink" title="Statistic"></a>Statistic</h4><ul><li><p>插件市场搜索安装</p></li><li><p>更多的功能可以自己去探索啦</p></li><li><p>效果图</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204220707662.png" alt="效果图"></p></li></ul><h4 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h4><ul><li><p>插件市场搜索安装</p></li><li><p>设置</p><p><code>File</code> -&gt; <code>Settings</code> -&gt; <code>Tools</code> -&gt; <code>Translation</code></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204220941832.png" alt="设置界面"></p></li><li><p>效果图</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204221120095.png" alt="效果图1"></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204221101972.png" alt="效果图2"></p></li></ul><h4 id="Material-Theme-UI"><a href="#Material-Theme-UI" class="headerlink" title="Material Theme UI"></a>Material Theme UI</h4><ul><li><p>插件市场安装下载</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204221353291.png" alt="默认十几种主题"></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204221527635.png" alt="自定义主题"></p></li><li><p>效果图<img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204221958146.png" alt="效果图"></p></li></ul><h4 id="Atom-Material-Icons"><a href="#Atom-Material-Icons" class="headerlink" title="Atom Material Icons"></a>Atom Material Icons</h4><ul><li><p>插件市场搜索下载安装</p></li><li><p>效果图（图标）</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/image-20210204224912942.png" alt="效果图"></p></li></ul><h4 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h4>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 敏捷开发 </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发21-原子类：无锁工具类的典范</title>
      <link href="2020/12/16/java-bing-fa-21-yuan-zi-lei-wu-suo-gong-ju-lei-de-dian-fan/"/>
      <url>2020/12/16/java-bing-fa-21-yuan-zi-lei-wu-suo-gong-ju-lei-de-dian-fan/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发21-原子类：无锁工具类的典范"><a href="#Java并发21-原子类：无锁工具类的典范" class="headerlink" title="Java并发21-原子类：无锁工具类的典范"></a>Java并发21-原子类：无锁工具类的典范</h3><p><code>JDK</code>提供了原子类，基本上是基于<code>CAS</code>原理实现的无锁下保证线程安全。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%BB%84%E6%88%90%E6%A6%82%E8%A7%88%E5%9B%BE.png" alt="原子类组成概览图"></p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁方案相对互斥锁方案，最大的好处就是<strong>性能</strong>。</p><p>互斥锁方案为了保证互斥性，需要执行加锁、解锁操作，而加锁、解锁操作本身就消耗性能；</p><p>同时拿不到锁的线程还会进入阻塞状态，进而触发线程切换，线程切换对性能的消耗也很大。 </p><p>而无锁方案则完全没有加锁、解锁的性能消耗，同时还能保证互斥性，相比互斥锁方案性能大大提升。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><code>CAS</code>即<code>Compare And Swap</code>，就是比较并交换。<code>CAS</code>是一种CPU指令，<strong>作为CPU指令，<code>CAS</code>本身是可以保证原子性的</strong>，所以<code>CAS</code>是通过硬件层面上的支持来保障数据更新的线程安全。</p><p><strong><code>CAS</code>有3个参数，共享变量内存地址<code>A</code>（旧值），用于比较值<code>B</code>(期望值)，共享变量新值<code>C</code>(更新值)。只有当期望值<code>B</code>和旧值<code>A</code>相等时，才会将旧值更新为新值<code>C</code>。</strong></p><h4 id="如何理解这句话？"><a href="#如何理解这句话？" class="headerlink" title="如何理解这句话？"></a>如何理解这句话？</h4><p>设有一值<code>v</code>=1，有多个线程同时对该值进行+1或-1操作。</p><p><code>CAS</code>指令会先把旧值取出来，计算得到新值，并将旧值赋值给期望值。因为在计算新值的过程中，可能其他的线程已经将原内存地址的值修改过，所以需要通过更新值与当前内存地址的值进行比较，只有当期望值与内存地址的值相同时，才会将新值进行赋值。若期望值和内存地址的值不相同，那么说明已经有线程修改过该值了。所以当前线程的修改就失败了，这样保证了线程安全。</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>接上文，若期望值和内存地址值相同。是否能说明该值未被其他线程修改过？</p><p>在计算新值期间，<code>v</code>可能被加1又被减1，所以导致该值最终未发生变化，但实际上它是变化过的。这就是<code>ABA</code>问题。</p><h3 id="原子类源码"><a href="#原子类源码" class="headerlink" title="原子类源码"></a>原子类源码</h3><p>我们取一个原子类底层的<code>unsafe</code>类的源码来看<code>CAS</code>在<code>Java</code>中如何实现的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> oldValue<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> offset<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> oldValue <span class="token operator">+</span> delta<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，通过<code>this</code>和<code>offset</code>可以确定值的具体位置，<code>delta</code>是要增加的值。</p><p>代码先定位到值的位置，取出值作为<code>oldValue</code>，然后通过<code>comapreAndSwap</code>方法进行赋值。</p><p>其中参数<code>this</code>和<code>offset</code>可以定位值的内存地址，传入<code>oldValue</code>作为期望值，传入<code>oldValue+delta</code>作为新值。</p><p>只有当内存地址的值和期望值相等时才会将新值赋值，并返回<code>true</code>，结束循环。否则，返回<code>false</code>并继续自旋进行赋值。 </p><h3 id="原子类概览"><a href="#原子类概览" class="headerlink" title="原子类概览"></a>原子类概览</h3><h4 id="原子化的基本数据类型"><a href="#原子化的基本数据类型" class="headerlink" title="原子化的基本数据类型"></a>原子化的基本数据类型</h4><p> <code>AtomicBoolean</code>、<code>AtomicInteger</code> 和 <code>AtomicLong</code> API比较简单</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//原子化i++</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//原子化的i--</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//原子化的++i</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//原子化的--i</span><span class="token comment">// 当前值+=delta，返回+=前的值</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token comment">// 当前值+=delta，返回+=后的值</span><span class="token function">addAndGet</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span><span class="token comment">// CAS操作，返回是否成功</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token comment">// 以下四个方法</span><span class="token comment">// 新值可以通过传入func函数来计算</span><span class="token function">getAndUpdate</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token function">updateAndGet</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token function">getAndAccumulate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>func<span class="token punctuation">)</span><span class="token function">accumulateAndGet</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>func<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="原子化的对象引用类型"><a href="#原子化的对象引用类型" class="headerlink" title="原子化的对象引用类型"></a>原子化的对象引用类型</h4><p><code>AtomicReference</code>、<code>AtomicStampedReference</code> 和 <code>AtomicMarkableReference</code>，可以实现对象引用的原子化更新。</p><p><code>AtomicReference</code> 提供的方法和原子化的基本数据类型差不多。</p><p>对象引用的更新需要重点关注 <code>ABA</code> 问题，<code>AtomicStampedReference</code> 和 <code>AtomicMarkableReference</code> 这两个原子类可以解决 <code>ABA</code> 问题。</p><p>每次执行 <code>CAS</code> 操作，附加再更新一个版本号，只要保证版本号是递增的，那么即便 <code>A</code> 变成 <code>B</code> 之后再变回 <code>A</code>，版本号也不会变回来（版本号递增的）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span>  <span class="token class-name">V</span> expectedReference<span class="token punctuation">,</span>  <span class="token class-name">V</span> newReference<span class="token punctuation">,</span>  <span class="token keyword">int</span> expectedStamp<span class="token punctuation">,</span>  <span class="token keyword">int</span> newStamp<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="原子化数组"><a href="#原子化数组" class="headerlink" title="原子化数组"></a>原子化数组</h4><p><code>AtomicIntegerArray</code>、<code>AtomicLongArray</code> 和 <code>AtomicReferenceArray</code>，这样可以原子化地更新数组里面的每一个元素。</p><p>这些类提供的方法和原子化的基本数据类型的区别是：每个方法多了一个数组的索引参数。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayBlckingQueue构造函数加锁问题</title>
      <link href="2020/06/14/arrayblckingqueue-gou-zao-han-shu-jia-suo-wen-ti/"/>
      <url>2020/06/14/arrayblckingqueue-gou-zao-han-shu-jia-suo-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayBlckingQueue构造方法加锁问题"><a href="#ArrayBlckingQueue构造方法加锁问题" class="headerlink" title="ArrayBlckingQueue构造方法加锁问题"></a>ArrayBlckingQueue构造方法加锁问题</h3><h3 id="构造方法加锁"><a href="#构造方法加锁" class="headerlink" title="构造方法加锁"></a>构造方法加锁</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 该方法为ArrayBlckingQueue的其中一个构造方法</span><span class="token comment">// 源码作者在line15加了一行注释：加锁仅为了保证可见性，不是为了互斥。</span><span class="token comment">// 构造方法数功能描述如下，比较容易理解，不再解释</span><span class="token comment">/**  * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed)  * capacity, the specified access policy and initially containing the  * elements of the given collection,  * added in traversal order of the collection's iterator.  */</span><span class="token keyword">public</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">,</span>                          <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> fair<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Lock only for visibility, not mutual exclusion</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                items<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArrayIndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        count <span class="token operator">=</span> i<span class="token punctuation">;</span>        putIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 构造函数中涉及到了对成员变量 items[] count putIndex的初始化</span><span class="token comment">// 以下为这几个成员变量在类中的声明</span><span class="token comment">/** The queued items */</span><span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span><span class="token comment">/** items index for next put, offer, or add */</span><span class="token keyword">int</span> putIndex<span class="token punctuation">;</span><span class="token comment">/** Number of elements in the queue */</span><span class="token keyword">int</span> count<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>为什么在构造中需要对代码加锁，并且为什么仅是为了保证可见性？</strong></p><ol><li>数组变量<code>items</code>是用<code>final</code>修饰的。</li></ol><p>在一个对象的构造过程中，如果构造器没有出现外部指针引用当前对象的情况，即没有出现引用逃逸，那么<code>final</code>修饰的变量在在构造方法中被初始化时，JVM会保证其他线程对<code>final</code>修饰变量的可见性。</p><p>即在不出现引用逃逸的情况下，<code>final</code>会保证在构造器对<code>final</code>变量的初0始化不会出现指令重排，并且在构造器完成后，其他线程访问<code>final</code>修饰的变量时，能够看到构造器完成时<code>final</code>修饰变量的最新值。<strong>也就是说在构造器中对<code>final</code>变量的初始化是线程安全的，但final变量指向对象中的值如果没有被<code>final</code>修饰，不保证它们的可见性，比如代码line20对数组元素赋值的操作。</strong></p><p>这里列出部分规范和解释，详情可以去链接或者看我之前文章<a href="http://blog.justcoder.tech/2020/03/29/java-bing-fa-2-happens-before-gui-ze/">[Java并发-Happens-Before规则-final关键字]</a></p><blockquote><p>Set the <code>final</code> fields for an object in that object’s constructor; and do not write a reference to the object being constructed in a place where another thread can see it before the object’s constructor is finished. If this is followed, then when the object is seen by another thread, that thread will always see the correctly constructed version of that object’s <code>final</code> fields. <strong>It will also see versions of any object or array referenced by those <code>final</code> fields that are at least as up-to-date as the <code>final</code> fields are.</strong></p><p>[<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5">Java Language Specification-Chapter 17. Threads and Locks-17.5</a>]</p><p>What does it mean for an object to be properly constructed? It simply means that no reference to the object being constructed is allowed to <strong>“escape”</strong> during construction. (See <a href="http://www-106.ibm.com/developerworks/java/library/j-jtp0618.html">Safe Construction Techniques</a> for examples.) In other words, do not place a reference to the object being constructed anywhere where another thread might be able to see it; do not assign it to a static field, do not register it as a listener with any other object, and so on. These tasks should be done after the constructor completes, not in the constructor.</p><p>**you can have a final pointer to an array and not have to worry about other threads seeing the correct values for the array reference, but incorrect  values for the contents of the array. **</p><p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong">How do final fields work under the new JMM?</a></p><p><strong>Presence of <code>final</code> guarantees that other threads would see values in the map after constructor finished without any external synchronization. Without <code>final</code> it cannot be guaranteed in all cases.</strong></p><p><a href="https://stackoverflow.com/questions/6457109/java-concurrency-is-final-field-initialized-in-constructor-thread-safe">Java concurrency: is final field (initialized in constructor) thread-safe?</a></p></blockquote><p>根据第一点的分析结论，可以得出：</p><p>代码中为了保证对<code>items</code>写操作的可见性，又因为<code>final</code>和<code>volatile</code>不能并列修饰，所以需要加锁</p><ol start="2"><li><p>对于<code>putIndex</code>和<code>count</code>，可能会出现指令重排现象，也需要保证可见性。<a href="http://blog.justcoder.tech/2020/03/29/java-bing-fa-2-happens-before-gui-ze/">[Java并发-Happens-Before规则-final关键字]</a></p><p> 首先这两个字段不能用<code>final</code>来保证可见性，因为这两个字段的值还要变化。</p><p> 用<code>volatile</code>确实也可以保证可见性，但是<code>putIndex</code>和<code>count</code>在本类的其他方法的代码中，会频繁地在加锁的情况下进行读写。</p><p> 加锁本身已经保证了<code>putIndex</code>和<code>count</code>的可见性，如果再加上<code>volatile</code>，会导致这两个变量频繁地从内存中读写，反而会降低方法的效率。</p></li></ol><p>结合第1点和第2点：<code>items</code>必须要用锁来保证可见性，<code>putIndex</code>和<code>count</code>用锁保证可见性效率更好。</p><p>因此，这个构造方法中需要对涉及到<code>items</code>的写，<code>putIndex</code>和<code>count</code>初始化的代码加锁。</p><hr><p>附上我在StackOverFlow的一个相关提问：[<a href="https://stackoverflow.com/questions/62370945/why-arrayblocking-constructor-use-reentrantlock-for-visibility">Why ArrayBlockingQueue constructor use ReentrantLock for visibility?</a>]</p><blockquote><p>The lock guarantees the visibility of all writes during: to <code>count</code>, to <code>putIndex</code>, and to the elements of <code>items</code> that it changes.</p><p>It doesn’t need to guarantee mutual exclusion, as it is in the constructor and since the reference to <code>this</code> hasn’t been given to other threads, there is no need for mutual exclusion (but it would guarantee that as well if the reference to <code>this</code> was given out before that point)</p><p>The comment is merely saying that the <strong>purpose</strong> of the lock is the visibility effects.</p><p>As to why you can’t use <code>volatile</code>:</p><p>The methods that retrieve values from the queue, like <code>poll</code>, <code>take</code> and <code>peek</code> do need to lock for mutual exclusion. Making a variable <code>volatile</code> is not necessary; it could have an adverse performance impact.</p><p>It would also be hard to get it right because of the ordering: a volatile read <em>happens before</em> (JLS terminology) a volatile write on the same variable. That means that the constructor would have to write to the volatile variable as its last action, while all code that needs to be correctly synchronized needs to read that volatile variable first before doing anything else.</p><p>Locks are much easier to reason about and to get the ordering of accesses right, and, in this case - they are required in any case to execute multiple writes as one atomic action.</p><p>—— <strong><a href="https://stackoverflow.com/users/981744/erwin-bolwidt">Erwin Bolwidt</a></strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Queue </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CyclicBarrier简单模拟订单对账流程</title>
      <link href="2020/06/11/cyclicbarrier-jian-dan-mo-ni-ding-dan-dui-zhang-liu-cheng/"/>
      <url>2020/06/11/cyclicbarrier-jian-dan-mo-ni-ding-dan-dui-zhang-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="CyclicBarrier简单模拟订单对账流程"><a href="#CyclicBarrier简单模拟订单对账流程" class="headerlink" title="CyclicBarrier简单模拟订单对账流程"></a>CyclicBarrier简单模拟订单对账流程</h3><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E6%9F%90%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="某对账系统流程图"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 主要针对CyclicBarrier的使用进行模拟 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierDemo</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//预先设定好模拟数据量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TICKET_NUM <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment">//模拟数据库中的订单和发货单数据</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> ORDER <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> SENDER <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//假设订单库中每个订单都需要去比较是否相同，模拟需要被比较的数据的队列</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> DIFFER_ORDER <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> DIFFER_SENDER <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//给订单和发货单计数</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ORDER_COUNT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span>TICKET_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> SENDER_COUNT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span>TICKET_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//为什么用Pool而不直接传Runnable,若直接传R，是同步执行，必须要一个订单比较完后才能执行下一个比较</span>    <span class="token comment">//即barrierAction执行完后才能执行下一次barrierAction</span>    <span class="token comment">//为什么POOL的大小置为一，因为check()方法线程不安全，置为1保证，每次只有一个线程去队列中取数据</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> POOL <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">)</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">CyclicBarrier</span> notify <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        POOL<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">::</span><span class="token function">check</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//初始化订单和发货单</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ORDER<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            SENDER<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>TICKET_NUM<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化订单数据: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ORDER<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化发货单数据: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SENDER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> orderNum <span class="token operator">=</span> DIFFER_ORDER<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> senderNum <span class="token operator">=</span> DIFFER_SENDER<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>orderNum <span class="token operator">==</span> senderNum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>orderNum <span class="token operator">+</span> <span class="token string">" == "</span> <span class="token operator">+</span> senderNum <span class="token operator">+</span> <span class="token string">" 订单和发货单无差异，无需处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>orderNum <span class="token operator">+</span> <span class="token string">" != "</span> <span class="token operator">+</span> senderNum <span class="token operator">+</span> <span class="token string">", Order = "</span> <span class="token operator">+</span> orderNum <span class="token operator">+</span> <span class="token string">" 订单和发货单存在差异，需要调用对账方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">checkAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//有未校验订单时，将未校验订单放入比较队列</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>ORDER_COUNT<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    DIFFER_ORDER<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ORDER<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>TICKET_NUM <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> ORDER_COUNT<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    notify<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//有未校验发货单时，将未校验订单放入比较队列</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>SENDER_COUNT<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    DIFFER_SENDER<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>SENDER<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>TICKET_NUM <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> SENDER_COUNT<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    notify<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CyclicBarrierDemo</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrierDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demo<span class="token punctuation">.</span><span class="token function">checkAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/RunPic.png" alt="运行截图"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁总结</title>
      <link href="2020/05/11/redis-fen-bu-shi-suo-zong-jie/"/>
      <url>2020/05/11/redis-fen-bu-shi-suo-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis分布式锁总结"><a href="#Redis分布式锁总结" class="headerlink" title="Redis分布式锁总结"></a>Redis分布式锁总结</h3><h3 id="原子操作问题-Lua脚本"><a href="#原子操作问题-Lua脚本" class="headerlink" title="原子操作问题-Lua脚本"></a>原子操作问题-Lua脚本</h3><p>利用<code>Lua</code>脚本执行命令，可以保证命令式原子性执行。</p><p><code>eval</code>执行时，是将脚本发送到<code>Redis</code>服务器上，<code>Redis</code>将其排入命令队列等待执行。</p><p>脚本会生成对应的<code>SHA1</code>校验和，<code>evalsha</code>执行时，发送<code>SHA1</code>校验和即可执行<code>Redis</code>上的脚本，省去网络开销。</p><p><code>redis.call(&#39;key&#39;,KEYS[1],ARGV[1],...)</code>：执行失败就返回。</p><p><code>redis.pcall(&#39;key&#39;,KEYS[1],ARGV[1],...)</code>：中间失败继续执行。</p><ul><li>编写<code>Lua</code>脚本</li></ul><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- SET KEY VAL PX NX</span><span class="token comment">-- Lock方式1</span><span class="token keyword">local</span> result <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'SETNX'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> result <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token keyword">then</span>    <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token keyword">end</span>result <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"PEXPIRE"</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> result <span class="token operator">==</span> <span class="token number">1</span><span class="token keyword">then</span>    <span class="token keyword">return</span> <span class="token keyword">true</span><span class="token keyword">else</span><span class="token comment">--  把锁删了</span>    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"DEL"</span><span class="token punctuation">,</span> KEY<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- SET KEY VAL PX NX</span><span class="token comment">-- Lock方式2</span><span class="token keyword">return</span> result <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'SET'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'EX'</span><span class="token punctuation">,</span>ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'NX'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- Unlock</span><span class="token keyword">local</span> val <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> val <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token keyword">local</span> result <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'DEL'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> result <span class="token operator">==</span> <span class="token number">1</span>    <span class="token keyword">then</span>        <span class="token keyword">return</span> <span class="token keyword">true</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token keyword">false</span>    <span class="token keyword">end</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置<code>RedisScript</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">RedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">></span></span> <span class="token function">redisLockScript</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">></span></span> redisScript <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    redisScript<span class="token punctuation">.</span><span class="token function">setScriptSource</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ResourceScriptSource</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">"lockScript.lua"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    redisScript<span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> redisScript<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过<code>RedisTemplate</code>调用</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisLockScript<span class="token punctuation">,</span>keys<span class="token punctuation">,</span>token<span class="token punctuation">,</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="误删锁-Value指定唯一值"><a href="#误删锁-Value指定唯一值" class="headerlink" title="误删锁-Value指定唯一值"></a>误删锁-Value指定唯一值</h3><p>情景：若A线程业务代码执行超期，锁被释放，B线程获取到锁，等到A线程业务执行完后，执行<code>unlock()</code>，会把线程B的锁释放掉。</p><ul><li>为锁指定唯一<code>token</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> token <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>先比较是否是对应的锁，再删除。</li></ul><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token comment">-- Unlock</span><span class="token keyword">local</span> val <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> val <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">then</span>    <span class="token keyword">local</span> result <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'DEL'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> result <span class="token operator">==</span> <span class="token number">1</span>    <span class="token keyword">then</span>        <span class="token keyword">return</span> <span class="token keyword">true</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token keyword">false</span>    <span class="token keyword">end</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="超时并发"><a href="#超时并发" class="headerlink" title="超时并发"></a>超时并发</h3><p>情景：由于线程执行时间太长导致多个线程的锁被释放，一起并发执行使得出现并发BUG。</p><ul><li><p>为线程开启守护线程，自动续加时间。</p><p>  根据业务，每X秒从<code>Redis</code>里找锁，查看锁剩余时间，如果小于一定阈值，<code>expire key</code>&amp;<code>pexpire key</code>重新设置键的时间。</p></li><li><p>为锁设置足够长的时间保证不会超时释放。</p></li></ul><h3 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h3><ul><li>利用<code>ThreadLocal</code>，每次加锁，先看<code>TheadLocal</code>中有无，有加1，没有就<code>put()</code>；解锁时，每解一次减1，直到计数为0。</li><li>高效，但是考虑到过期时间和本地、<code>Redis</code>一致性的问题，会增加代码的复杂性。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> LOCKERS <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 加锁</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> lockers <span class="token operator">=</span> LOCKERS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockers<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    lockers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> lockers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>SET key uuid NX <span class="token class-name">EX</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      lockers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 解锁</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> lockers <span class="token operator">=</span> LOCKERS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockers<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    lockers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    DEL key  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    lockers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> lockers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Redis</code>的<code>hash</code>数据结构实现(Redisson源码中的Lua脚本)</li></ul><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">//</span> 如果 lock_key 不存在<span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'exists'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">then</span>    <span class="token operator">//</span> 设置 lock_key 线程标识 <span class="token number">1</span> 进行加锁    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hset'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">//</span> 设置过期时间    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'pexpire'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token punctuation">;</span><span class="token operator">//</span> 如果 lock_key 存在且线程标识是当前欲加锁的线程标识<span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hexists'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token operator">//</span> 自增    <span class="token keyword">then</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hincrby'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">//</span> 重置过期时间    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'pexpire'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token punctuation">;</span><span class="token operator">//</span> 如果加锁失败，返回锁剩余时间<span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'pttl'</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><ul><li>轮询等待</li><li>逻辑简单但并发量大时耗费资源</li></ul><pre class="line-numbers language-none"><code class="language-none">while (!disturbedLock(keyToken, expireMillSeconds, waitTime)) ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>利用<code>Redis</code>发布订阅实现等待锁功能</li></ul><p><strong>不会，Redission已实现？</strong></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主从状态下，主节点挂掉，从节点切换到主节点，主从复制过程中，新切换的节点还未同步锁，导致其他线程获取到锁，出现并发BUG。</p><h3 id="集群脑裂"><a href="#集群脑裂" class="headerlink" title="集群脑裂"></a>集群脑裂</h3><p>集群脑裂指因为网络问题，导致<code>Redis master</code>节点跟<code>slave</code>节点和<code>sentinel</code>集群处于不同的网络分区，因为<code>sentinel</code>集群无法感知到<code>master</code>的存在，所以将<code>slave</code>节点提升为<code>master</code>节点，此时存在两个不同的<code>master</code>节点。<code>Redis Cluster</code>集群部署方式同理。</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>自造轮子 未基于Redssion</p><p>未实现守护线程续时，未实现发布订阅等待。</p><p>具备原子性，具备不被误删性，具备获取锁超时放弃特性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> keyToken <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token class-name">CommunityUtil</span><span class="token punctuation">.</span><span class="token function">generateUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> waitTime <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">+</span> <span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//尝试获取锁</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">disturbedLock</span><span class="token punctuation">(</span>keyToken<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">++</span>id<span class="token punctuation">;</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//释放锁</span>        <span class="token function">disturbedUnlock</span><span class="token punctuation">(</span>keyToken<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">disturbedLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyToken<span class="token punctuation">,</span> <span class="token keyword">long</span> expireMillSeconds<span class="token punctuation">,</span> <span class="token keyword">long</span> waitTimeout<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> lock <span class="token operator">=</span> <span class="token string">"test:lock"</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    keys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisLockScript<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> keyToken<span class="token punctuation">,</span> expireMillSeconds<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//获取到了锁但超过了等待时间</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">></span> waitTimeout<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" timeout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//未获取到锁且超过等待时间</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">></span> expireMillSeconds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" timeout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">disturbedUnlock</span><span class="token punctuation">(</span><span class="token class-name">String</span> token<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> unlock <span class="token operator">=</span> <span class="token string">"test:lock"</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    keys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>unlock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> token <span class="token operator">+</span> <span class="token string">" del "</span> <span class="token operator">+</span> redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisUnlockScript<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h3><h4 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h4><blockquote><p>In the distributed version of the algorithm we assume we have N Redis masters. <strong>Those nodes are totally independent, so we don’t use replication or any other implicit coordination system.</strong> We already described how to acquire and release the lock safely in a single instance. We take for granted that the algorithm will use this method to acquire and release the lock in a single instance. In our examples we set N=5, which is a reasonable value, so we need to run 5 Redis masters on different computers or virtual machines in order to ensure that they’ll fail in a mostly independent way.</p><ol><li>It gets the current time in milliseconds.</li><li>It tries to acquire the lock in all the N instances sequentially, using the same key name and random value in all the instances. During step 2, when setting the lock in each instance, the client uses a timeout which is small compared to the total lock auto-release time in order to acquire it. For example if the auto-release time is 10 seconds, the timeout could be in the ~ 5-50 milliseconds range. This prevents the client from remaining blocked for a long time trying to talk with a Redis node which is down: if an instance is not available, we should try to talk with the next instance ASAP.</li><li>The client computes how much time elapsed in order to acquire the lock, by subtracting from the current time the timestamp obtained in step 1. If and only if the client was able to acquire the lock in the majority of the instances (at least 3), and the total time elapsed to acquire the lock is less than lock validity time, the lock is considered to be acquired.</li><li>If the lock was acquired, its validity time is considered to be the initial validity time minus the time elapsed, as computed in step 3.</li><li>If the client failed to acquire the lock for some reason (either it was not able to lock N/2+1 instances or the validity time is negative), it will try to unlock all the instances (even the instances it believed it was not able to lock).</li></ol></blockquote><p>假设现在有5个Redis实例，这5个实例可以是5个互不相干的主节点；5个哨兵或5不同集群中的节点。</p><ul><li><p>首先获取当前时间，毫秒</p></li><li><p>生成相同的key和不同的随机value，按序从5个实例尝试获取锁。当然还会设置一个超时时间。</p><p>  如果一直获取成功，直到获取完5把锁后，看下总共获取锁的时间是否超过的设置超时时间。</p><p>  若没超过，即获取成功，执行业务代码。若超过时间，释放所有获取到的锁，获取失败。</p><p>  如果一个Redis获取锁失败，就赶紧尝试获取下一个节点的锁。</p><p>  如果此时获取到锁的数量&gt;3，耗费时间小于超时时间，立即返回获取成功，大于就返回失败。</p><p>  如果此时获取失败的次数&gt;=3，耗费时间大于超时时间，返回获取失败，小于就重新开始新一轮获取锁。</p></li><li><p>如果获取失败，就要删除所有已获得的锁。</p></li></ul><p><strong>疑问</strong>：若<code>trylock</code>成功，但返回超时，<code>redisson</code>会认为获取失败，但是Redis上确实有对应的锁。这样会造成其他线程尝试获取锁失败。为什么不在获取失败时删除所有节点上的锁，而只删除已获取的锁？</p><p><code>redlock.unlock()</code>会把所有锁给释放。</p><p>原子性保证，误删除保证，可重入保证，锁等待保证。</p><p>若指定锁超时时间，业务超时导致锁释放会出现并发BUG。<code>watchdog</code>只有在不指定超时时间时才会使用，<code>watchdog</code>的时间会被设置到锁中。</p><p>隐患1：业务代码中出现死锁，造成<code>watchdog</code>一直为该锁续时，其他线程无法获取到锁饿死。要想办法感知死锁。</p><p>隐患2：<code>master</code>在同步<code>salve</code>的时候<code>master </code>挂了<code>salve </code>并没有同步到锁，这时候一个服务实例刚好获取到了新的<code>master</code>锁，这个时候怎么处理？</p><p>被锁的服务操作如果是核心服务要保证操作幂等性，这样子可以保证不出现业务逻辑的重复执行导致错误。</p><p><code>RedLock</code>继承了<code>multiLock</code>。</p><p><code>redission</code>默认锁时间是30s</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blow a Cube</title>
      <link href="2020/05/10/blowacube/"/>
      <url>2020/05/10/blowacube/</url>
      
        <content type="html"><![CDATA[<h3 id="Blow-a-Cube"><a href="#Blow-a-Cube" class="headerlink" title="Blow a Cube"></a>Blow a Cube</h3><h3 id="定义立体的数据结构"><a href="#定义立体的数据结构" class="headerlink" title="定义立体的数据结构"></a>定义立体的数据结构</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 1024 * describe a cube or a box */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cube</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Coordinate</span> top1<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Coordinate</span> top2<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Coordinate</span> top3<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Coordinate</span> top4<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Coordinate</span> bottom1<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Coordinate</span> bottom2<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Coordinate</span> bottom3<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Coordinate</span> bottom4<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">XLength</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">YLength</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">ZLength</span><span class="token punctuation">;</span>    <span class="token comment">/**     * construct cube     * @param coordinates     */</span>    <span class="token keyword">public</span> <span class="token class-name">Cube</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Coordinate</span><span class="token punctuation">></span></span> coordinates<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>top1 <span class="token operator">=</span> coordinates<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"top1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>top2 <span class="token operator">=</span> coordinates<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"top2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>top3 <span class="token operator">=</span> coordinates<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"top3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>top4 <span class="token operator">=</span> coordinates<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"top4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bottom1 <span class="token operator">=</span> coordinates<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"bottom1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bottom2 <span class="token operator">=</span> coordinates<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"bottom2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bottom3 <span class="token operator">=</span> coordinates<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"bottom3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bottom4 <span class="token operator">=</span> coordinates<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"bottom4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token class-name">XLength</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> top1<span class="token punctuation">.</span><span class="token function">getDistance</span><span class="token punctuation">(</span>top4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token class-name">YLength</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> top1<span class="token punctuation">.</span><span class="token function">getDistance</span><span class="token punctuation">(</span>top2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token class-name">ZLength</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> top1<span class="token punctuation">.</span><span class="token function">getDistance</span><span class="token punctuation">(</span>bottom1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isCube</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">XLength</span> <span class="token operator">==</span> <span class="token class-name">YLength</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">YLength</span> <span class="token operator">==</span> <span class="token class-name">ZLength</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义坐标的数据结构"><a href="#定义坐标的数据结构" class="headerlink" title="定义坐标的数据结构"></a>定义坐标的数据结构</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * describe a coordinate */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coordinate</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span>    <span class="token comment">/**     * construct coordinate     * @param x     * @param y     * @param z     */</span>    <span class="token keyword">public</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getXDistance</span><span class="token punctuation">(</span><span class="token class-name">Coordinate</span> coordinate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> coordinate<span class="token punctuation">.</span>x <span class="token operator">-</span> x<span class="token punctuation">;</span>        <span class="token keyword">return</span> result <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> result <span class="token operator">:</span> <span class="token operator">-</span>result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getYDistance</span><span class="token punctuation">(</span><span class="token class-name">Coordinate</span> coordinate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> coordinate<span class="token punctuation">.</span>y <span class="token operator">-</span> y<span class="token punctuation">;</span>        <span class="token keyword">return</span> result <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> result <span class="token operator">:</span> <span class="token operator">-</span>result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getZDistance</span><span class="token punctuation">(</span><span class="token class-name">Coordinate</span> coordinate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> coordinate<span class="token punctuation">.</span>z <span class="token operator">-</span> z<span class="token punctuation">;</span>        <span class="token keyword">return</span> result <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> result <span class="token operator">:</span> <span class="token operator">-</span>result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getDistance</span><span class="token punctuation">(</span><span class="token class-name">Coordinate</span> coordinate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">double</span> xdSquare <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">getXDistance</span><span class="token punctuation">(</span>coordinate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> ydSquare <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">getYDistance</span><span class="token punctuation">(</span>coordinate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> zdSquare <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">getZDistance</span><span class="token punctuation">(</span>coordinate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>xdSquare <span class="token operator">+</span> ydSquare <span class="token operator">+</span> zdSquare<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tests</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// define a box </span>        <span class="token class-name">Cube</span> box <span class="token operator">=</span> <span class="token function">defineBox</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// define a cube</span>        <span class="token comment">// 这个需要根据box和气球的相对位置去初始化坐标</span>        <span class="token class-name">Cube</span> cube <span class="token operator">=</span> <span class="token function">defineCube</span><span class="token punctuation">(</span>我没想好传什么参<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>box<span class="token punctuation">.</span><span class="token function">isCube</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cube<span class="token punctuation">.</span><span class="token function">isCube</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 吹一次之后返回吹后气球的形状 下次吹的时候就传这个</span>        <span class="token class-name">Cube</span> afterBlow <span class="token operator">=</span> <span class="token function">blow</span><span class="token punctuation">(</span>box<span class="token punctuation">,</span> cube<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 吹一次之后返回新增的那些点</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Coordinate</span><span class="token punctuation">></span></span> afterBlowPoints <span class="token operator">=</span> <span class="token function">afterBlowPoints</span><span class="token punctuation">(</span>afterBlow<span class="token punctuation">,</span> cube<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 重点</span>        <span class="token comment">// 可以循环调用 blow() afterBlowPoints()方法 直到返回的新增的点为空</span>        <span class="token comment">// 那么说明气球已经吹满盒子了 记录调用blow()的次数即吹了几次吹满</span>        <span class="token comment">// 将每次调用afterBlowPoints()返回的新增点的集合合并 就是吹满盒子所有新增的点</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 定义一个盒子     * @param length     * @param width     * @param height     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Cube</span> <span class="token function">defineBox</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Coordinate</span> bottom1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Coordinate</span> bottom2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Coordinate</span> bottom3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Coordinate</span> bottom4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Coordinate</span> top1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Coordinate</span> top2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Coordinate</span> top3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Coordinate</span> top4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Coordinate</span><span class="token punctuation">></span></span> coordinateMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coordinateMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"top1"</span><span class="token punctuation">,</span> top1<span class="token punctuation">)</span><span class="token punctuation">;</span>        coordinateMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"top2"</span><span class="token punctuation">,</span> top2<span class="token punctuation">)</span><span class="token punctuation">;</span>        coordinateMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"top3"</span><span class="token punctuation">,</span> top3<span class="token punctuation">)</span><span class="token punctuation">;</span>        coordinateMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"top4"</span><span class="token punctuation">,</span> top4<span class="token punctuation">)</span><span class="token punctuation">;</span>        coordinateMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bottom1"</span><span class="token punctuation">,</span> bottom1<span class="token punctuation">)</span><span class="token punctuation">;</span>        coordinateMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bottom2"</span><span class="token punctuation">,</span> bottom2<span class="token punctuation">)</span><span class="token punctuation">;</span>        coordinateMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bottom3"</span><span class="token punctuation">,</span> bottom3<span class="token punctuation">)</span><span class="token punctuation">;</span>        coordinateMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bottom4"</span><span class="token punctuation">,</span> bottom4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Cube</span> cube <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cube</span><span class="token punctuation">(</span>coordinateMap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cube<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">/**     *根据盒子和气球初始状态的相对位置 初始化这个气球     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Cube</span> <span class="token function">defineCube</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token comment">/**     * 计算气球吹一次之后 新增的点     * @param afterCube     * @param cube     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Coordinate</span><span class="token punctuation">></span></span> <span class="token function">afterBlowPoints</span><span class="token punctuation">(</span><span class="token class-name">Cube</span> afterCube<span class="token punctuation">,</span> <span class="token class-name">Cube</span> cube<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//这个方法要实现的内容就是，根据当前吹过一次的气球和之前气球 比较得出哪些点是新增的 记录下来</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Coordinate</span><span class="token punctuation">></span></span> newPoints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">/**     * 吹一次之后 返回吹之后气球的形状     * @param box     * @param cube     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Cube</span> <span class="token function">blow</span><span class="token punctuation">(</span><span class="token class-name">Cube</span> box<span class="token punctuation">,</span> <span class="token class-name">Cube</span> cube<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//参数有盒子 和 气球</span>        <span class="token comment">//这个方法要实现的内容就是计算出气球这次吹完后变成什么样子</span>        <span class="token comment">//根据盒子的边界计算即可</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存失效场景&amp;优化</title>
      <link href="2020/04/30/huan-cun-shi-xiao-chang-jing-you-hua/"/>
      <url>2020/04/30/huan-cun-shi-xiao-chang-jing-you-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="缓存失效场景-amp-优化"><a href="#缓存失效场景-amp-优化" class="headerlink" title="缓存失效场景&amp;优化"></a>缓存失效场景&amp;优化</h3><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>查询根本不存在的数据，使请求直达存储层。被恶意攻击者利用，导致负载过高宕机。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li><p>缓存空对象</p><p>  存储层查不到返回空值，将空值也存入缓存中，这样请求就可以打到缓存层。</p><p>  缺点1：如果是攻击，将占用大量缓存空间。</p><p>  解决：将空值键设置较短的过期时间。</p><p>  缺点2：如果缓存层已缓存了空值，此时存储层对应的键已更新了值，会造成缓存层与存储层数据不一致。</p><p>  解决：通过消息系统等方式清除掉缓存层的值。</p></li><li><p>布隆过滤器</p><p>  将所有键存到缓存层之前的一个布隆过滤器中，请求打过来，如果布隆过滤其中没有对应key，就直接返回空，避免数据打到缓存层和存储层。</p><p>  举例：比如一个推荐系统有1亿用户，每个小时后台根据用户的历史行为计算出推荐数据放入缓存层。</p><p>  但新用户没有推荐数据，因此新用户的推荐数据请求会打到存储层。加入布隆过滤器，将1亿用户id放入，新用户di传过来，布隆过滤器中没有，就可以返回空值。</p></li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th align="center">优化方案</th><th align="center">适用场景</th><th align="center">维护成本</th></tr></thead><tbody><tr><td align="center">缓存空值</td><td align="center">数据命中不高/数据频繁变化实时性高</td><td align="center">代码维护简单/需要过多缓存空间/数据不一致</td></tr><tr><td align="center">布隆过滤器</td><td align="center">数据命中不高/数据相对固定实时性低</td><td align="center">代码维护复杂/缓存空间占用少</td></tr></tbody></table><h3 id="缓存击穿-热点key重建"><a href="#缓存击穿-热点key重建" class="headerlink" title="缓存击穿/热点key重建"></a>缓存击穿/热点key重建</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>一份热点数据访问量非常大，在其失效瞬间，大量请求涌向存储层，导致服务崩溃。</p><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><ul><li><p>加互斥锁</p><p>  对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。</p><p>  该线程访问过后，缓存中的数据将被重建，到时其他线程就可以直接从缓存取值。</p></li><li><p>永不过期</p><p>  物理上不设置过期时间。</p><p>  给value设置逻辑过期时间，发现逻辑时间过期时，单独线程重建缓存。</p><p>  下次再访问时，value就是新值。</p></li></ul><h4 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th align="center">优化方案</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">简单分布式锁</td><td align="center">思路简单/保证一致性</td><td align="center">代码复杂度大/存在死锁风险/存在线程池阻塞风险</td></tr><tr><td align="center">永不过期</td><td align="center">基本杜绝热点key问题</td><td align="center">不保证一致性/逻辑过期时间增加代码维护和内存成本</td></tr></tbody></table><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h4><p>某种情况下整个缓存层突然失效，请求全部直达存储层。</p><h4 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h4><ul><li><p>保证高可用，Redis Sentinel&amp;Redis Cluster</p></li><li><p>避免键同时过期，键的过期时间设置为随机数</p></li><li><p>构建多级缓存，如增加本地缓存</p></li><li><p>限流&amp;降级服务：一个服务无法提供后提供降级服务</p><p>  p.s. Hystrix隔离工具</p></li></ul><h3 id="缓存无底洞"><a href="#缓存无底洞" class="headerlink" title="缓存无底洞"></a>缓存无底洞</h3><h4 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h4><p>缓存节点越扩越多，缓存性能反而下降。</p><p>原因：key通过hash算法分布在不同的节点上，如果一次性 <code>mget </code>N个key,N个key会分布在M个节点上，节点越多，M可能越大，网络延时开销就越大。而只在1个节点上 <code>mget</code> N个key，只有一次网络开销。</p><h4 id="优化-3"><a href="#优化-3" class="headerlink" title="优化"></a>优化</h4><p>前提：假设要一次性获取n个key的值。在集群上，直接<code>mget keys</code>会报错，因为key分布在不同的slot上。</p><p>只有key都在同一个slot上才可以。</p><ul><li><p>串行命令，执行n次get key</p><p>  开销：n次网络时间 + n次命令时间</p></li><li><p>串行IO，Smart客户端会保存slot和节点的对应关系，这样可以得到每个节点key的字列表，再通过CRC16算法算出slot。</p><p>  开销：node次网络时间 + n次命令时间</p></li><li><p>并行IO，因节点不同，将上面的串行改为并行。</p><p>  开销：最慢的那次网络时间 + n次命令时间</p></li><li><p>hashtag，存的时候将所有key通过hashtag强制放到同一个槽上，获取的时候就方便获取</p><p>  开销：1次网络时间 + n次命令时间</p><p>  hashtag原理：键中内容含{}，计算slot时是以slot中的内容为准</p><p>  <code>mget user:&#123;10086&#125;:info user:&#123;10086&#125;:video</code></p></li></ul><h4 id="对比-2"><a href="#对比-2" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th align="center">优化方案</th><th align="center">优点</th><th align="center">缺点</th><th align="center">网络IO</th></tr></thead><tbody><tr><td align="center">串行命令</td><td align="center">编程简单/key少可满足性能要求</td><td align="center">大量key请求延迟严重</td><td align="center">O(keys)</td></tr><tr><td align="center">串行IO</td><td align="center">编程简单/节点少可满足性能要求</td><td align="center">大量node请求延迟严重</td><td align="center">O(nodes)</td></tr><tr><td align="center">并行IO</td><td align="center">延迟取决于最慢节点</td><td align="center">编程复杂/多线程定位问题较难</td><td align="center">O(max_slow(nodes))</td></tr><tr><td align="center">hash_tag</td><td align="center">性能最高</td><td align="center">业务维护成本高/易出现数据倾斜</td><td align="center">O(1)</td></tr></tbody></table><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://book.douban.com/subject/26971561/">《 Redis开发与运维 》</a></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现LRU算法</title>
      <link href="2020/04/30/java-shi-xian-lru-suan-fa/"/>
      <url>2020/04/30/java-shi-xian-lru-suan-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p>LRU算法：Latest Recently Used</p><p>即我们认为最近访问的数据就是有用的，就应该更新到队头，这样的话，对尾的就应该是很久未被访问的数据。</p><p>这样就可以淘汰队尾的数据。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>缓存容量：初始化一个缓存容量。</p><p>添加数据：判断缓存是否已满？不满，新数据放表头；满，删除表尾数据，新数据放表头。</p><p>读取数据：判断数据是否存在？存在，放表头，返回数据；不存在，返回错误。</p><p><strong>为了快，添加数据和读取数据的操作应为O(1)。</strong></p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>实现该算法应满足：查找快，插入快，删除快，有顺序之分。</p><p>哈希表查找快，但数据无固定顺序；链表有顺序，插入删除快，但查找慢。</p><p>所以结合形成一种新的数据结构：哈希链表。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/LRU.png" alt="哈希链表示意图"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 链表节点 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span> pre<span class="token punctuation">;</span>    <span class="token class-name">Node</span> next<span class="token punctuation">;</span>    <span class="token class-name">Object</span> val<span class="token punctuation">;</span>    <span class="token class-name">String</span> key<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoubleLinkedList</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        head<span class="token punctuation">.</span>pre <span class="token operator">=</span> tail<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//添加新节点</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token operator">++</span>size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//移除节点</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            node<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>            <span class="token operator">--</span>size<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//移除最后一个数据节点</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">.</span>pre <span class="token operator">!=</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span> last <span class="token operator">=</span> tail<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>            <span class="token function">remove</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> last<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//获取当前缓存size</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">></span></span> nodeMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">DoubleLinkedList</span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nodeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//添加缓存</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Node</span> last <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                nodeMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>last<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        list<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        nodeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//删除缓存</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> node <span class="token operator">=</span> nodeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            nodeMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//获取缓存</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> node <span class="token operator">=</span> nodeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">LRUCache</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token comment">/* 缓存容量 */</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 该操作会使得关键字 2 作废</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 返回 null (未找到)</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 该操作会使得关键字 1 作废</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 -1 (未找到)</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回  3</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回  3</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>为什么使用双向链表？</strong></p><p>因为在删除节点时，需要获取前置节点，将前置节点的后置节点指向当前节点的后置节点。</p><p>如果是单相链表就无法更改。</p><p><strong>为什么使用了哈希集合之后，链表中还需要存key？</strong></p><p>因为在删除尾节点时，需要获取对应节点的key才可以将哈希中key与节点的映射关系删除，所以要从链表的节点中获取。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LFU算法在Redis中的实现机制和应用</title>
      <link href="2020/04/30/lfu-suan-fa-zai-redis-zhong-de-shi-xian-ji-zhi-he-ying-yong/"/>
      <url>2020/04/30/lfu-suan-fa-zai-redis-zhong-de-shi-xian-ji-zhi-he-ying-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="LFU算法在Redis中的实现机制和应用"><a href="#LFU算法在Redis中的实现机制和应用" class="headerlink" title="LFU算法在Redis中的实现机制和应用"></a>LFU算法在Redis中的实现机制和应用</h3><p>Redis 4.0提供了两种新的内存淘汰策略：</p><ul><li><code>volatile-lfu</code>：基于<code>LFU</code>算法对设置了过期时间的key进行删除</li><li><code>allkeys-lfu</code>：基于<code>LFU</code>算法对所有的key进行删除</li></ul><p>Redis 4.0.3正式支持基于<code>LFU</code>算法的热点key发现机制。</p><h3 id="LFU数据结构"><a href="#LFU数据结构" class="headerlink" title="LFU数据结构"></a>LFU数据结构</h3><p><code>redisObject</code>对象中的<code>unsigned lru:LRU_BITS</code>字段为24bit大小，用来记录LRU/LFU的信息。</p><p>记录LFU信息时：</p><p><code>0-15bit</code>：last access time，即上次访问时间，单位分钟</p><p><code>16-24bit</code>：LOG_C，即访问频率，简称counter，显然其最大为255</p><p><strong>显然，<code>LFU</code>算法是通过对<code>key</code>的访问频率来筛选<code>key</code>，那么其内部实现就必然要能区分出不同<code>key</code>的访问频率。</strong></p><h3 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h3><p><code>counter</code>是一个基于概率的计数器，它的作用并非精准地记录某个<code>key</code>的访问次数。</p><p>实际上，在<code>Redis</code>源码中通过一个公式来对<code>counter</code>进行计算来体现<code>key</code>的访问次数。</p><p>公式 :  <code>1 / (( counter - LFU_INIT_VAL ) * server.lfu_log_factor + 1)</code></p><p>其中<code>LFU_INIT_VAL = 5</code> ，下文解释为什么该值为5。</p><p><code>server.lfu_log_factor</code>是<code>Redis</code>配置项中的概率因子，默认为10，通过该公式的计算，可以记录较多的<code>key</code>访问次数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//计算key的访问频率的源码</span>uint8_t <span class="token function">LFULogIncr</span><span class="token punctuation">(</span>uint8_t counter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">255</span><span class="token punctuation">;</span>      <span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>RAND_MAX<span class="token punctuation">;</span>      <span class="token keyword">double</span> baseval <span class="token operator">=</span> counter <span class="token operator">-</span> LFU_INIT_VAL<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>baseval <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> baseval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">double</span> p <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span><span class="token punctuation">(</span>baseval<span class="token operator">*</span>server<span class="token punctuation">.</span>lfu_log_factor<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> p<span class="token punctuation">)</span> counter<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> counter<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">factor</th><th align="center">100hits</th><th align="center">1000hits</th><th align="center">100k hits</th><th align="center">1M hits</th><th align="center">10M hits</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">104</td><td align="center">255</td><td align="center">255</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">1</td><td align="center">18</td><td align="center">49</td><td align="center">255</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">10</td><td align="center">10</td><td align="center">18</td><td align="center">142</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">100</td><td align="center">8</td><td align="center">11</td><td align="center">49</td><td align="center">143</td><td align="center">255</td></tr></tbody></table><p>该表格来自于阿里云团队根据公式计算出的<code>key</code>访问次数与<code>counter</code>的关系，可以看到<code>server.lfu_log_factor</code>越大，就越能记录更高的<code>key</code>访问次数，当<code>server.lfu_log_factor = 10</code>时，<code>counter</code>可体现1百万次的<code>key</code>访问记录。</p><h3 id="counter的衰减因子"><a href="#counter的衰减因子" class="headerlink" title="counter的衰减因子"></a>counter的衰减因子</h3><p>实际上<code>Redis</code>运行中，所有存活已久的<code>key</code>的访问次数都在增加，<code>counter</code>最终都会收敛到<code>255</code>。</p><p>极端情况下，可能存在一些<code>key</code>从<code>Redis</code>第一次启动就存在，一直未消失，但被访问次数并不高，只是因为存活时间久，导致累计访问次数很高，其<code>counter</code>很容易收敛到255，这种情况下，给<code>热点key</code>的筛选带来了干扰。</p><p>即，<code>counter</code>只增长不衰减就无法区分热点<code>key</code>。</p><p>因此Redis提供了衰减因子<code>server.lfu_decay_time</code>，单位是分钟。</p><p>原理：如果一个<code>key</code>很长时间没有被访问，<code>counter</code>就应该减小，具体减小的程度由该衰减因子控制。</p><p>默认<code>server.lfu_decay_time = 1</code>，这种情况下，N分钟没有访问<code>key</code>，<code>key</code>的<code>counter</code>就减N。</p><p><strong>业务中，使用默认值就可以。</strong></p><h3 id="为什么LFU-INIT-VAL-5"><a href="#为什么LFU-INIT-VAL-5" class="headerlink" title="为什么LFU_INIT_VAL = 5"></a>为什么LFU_INIT_VAL = 5</h3><ol><li><p>由衰减因子可得，访问次数很大的<code>key</code>，但由于长时间不被访问，导致其<code>counter</code>变成很小，当<code>counter</code>衰减到0时，<code>Redis</code>淘汰该<code>key</code>。</p></li><li><p>理论上，新创建的<code>key</code>，其<code>counter=0</code>，因为从未被访问过，但这样会导致<code>key</code>被<code>Redis</code>误淘汰。</p></li></ol><p>基于以上2点，对于新生成的<code>key</code>，<code>LFU_INIT_VAL = 5</code>，使得其在创建时<code>counter!=0</code>，其不在被创建时就立即被淘汰。</p><blockquote><p>There is yet another problem, new keys need a chance to survive after<br>all. In vanilla LFU a just added key has an access score of 0, so it<br>is a very good candidate for eviction. In Redis new keys start with<br>an LFU value of 5. This initial value is accounted in the increment<br>and halving algorithms. Simulations show that with this change keys have<br>some time in order to accumulate accesses: keys with a score less than<br>5 will be preferred （non active keys for a long time）.</p></blockquote><h3 id="发现热点key"><a href="#发现热点key" class="headerlink" title="发现热点key"></a>发现热点key</h3><p>通过衰减因子影响<code>counter</code>的计算，对一个<code>key</code>的访问频率可以得到较好的体现。</p><p>因此，<code>Redis</code>会在每次对<code>key</code>进行读写访问时，更新<code>lru:LRU_BITS</code>的访问时间和<code>counter</code>，这样就可以及时地得到正确的LFU值。</p><p>通过<code>OBJECT FREQ KEY</code>可以访问对应key的<code>counter</code>值，通过<code>redis-cli --hotkeys</code>可得到当前热点key列表。</p><p>开发中可以通过渐进式遍历<code>scan</code>获取key，再<code>OBJECT FREQ KEY</code>获取<code>counter</code>值，进行排序后发现热点key。</p><p><strong>注意：使用发现热点<code>key</code>的功能的前提是采用<code>lru</code>内存淘汰策略，通过<code>config get maxmemory-policy</code>查看你设置的<code>Redis</code>的内存淘汰策略。</strong></p><h3 id="内存淘汰"><a href="#内存淘汰" class="headerlink" title="内存淘汰"></a>内存淘汰</h3><p>很显然，当采用<code>lru</code>内存淘汰策略时，内存空间不足时，<code>counter</code>值小的<code>key</code>会被淘汰。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://mysql.taobao.org/monthly/2018/09/08/">Redis · 引擎特性 · 基于 LFU 的热点 key 发现机制</a></p><p><a href="http://antirez.com/news/109">Random notes on improving the Redis LRU algorithm</a></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie树实现敏感词过滤器</title>
      <link href="2020/04/24/trie-shu-shi-xian-min-gan-ci-guo-lu-qi/"/>
      <url>2020/04/24/trie-shu-shi-xian-min-gan-ci-guo-lu-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="Trie树实现敏感词过滤器"><a href="#Trie树实现敏感词过滤器" class="headerlink" title="Trie树实现敏感词过滤器"></a>Trie树实现敏感词过滤器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SensitiveWordsFilter</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 定义敏感词的替换词 每个敏感词均替换为一个***     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> REPLACE_WORD <span class="token operator">=</span> <span class="token string">"***"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 定义根节点 前缀树的根节点为空     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">TrieNode</span> rootNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 定义前缀树的数据结构     */</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 标记当前节点是否为单词的结尾         * 默认不是结尾 即false         * 往树中添加敏感词时遍历到结尾会将该值置为true         */</span>        <span class="token keyword">private</span> <span class="token keyword">boolean</span> isWordEnd <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 定义子节点 子节点可能有多个 因此用map作为数据结构         * key：子节点的字符 value：子节点的指针         */</span>        <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">TrieNode</span><span class="token punctuation">></span></span> subNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 查看当前节点是否是敏感词的结尾         * @return         */</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isWordEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>isWordEnd<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/**         * 将当前节点置为敏感词的结尾         * @param isWordEnd         */</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWordEnd</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isWordEnd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>isWordEnd <span class="token operator">=</span> isWordEnd<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/**         * 根据字符获取当前节点的子节点         * @param c         * @return         */</span>        <span class="token keyword">public</span> <span class="token class-name">TrieNode</span> <span class="token function">getSubNode</span><span class="token punctuation">(</span><span class="token class-name">Character</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/**         * 给当前节点添加子节点         * @param c         * @param subNode         */</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addSubNode</span><span class="token punctuation">(</span><span class="token class-name">Character</span> c<span class="token punctuation">,</span> <span class="token class-name">TrieNode</span> subNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>subNode<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> subNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 首先在类加载实例化后初始化敏感词文件，即将敏感词文件中的所有敏感词构造到前缀树中。     */</span>    <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>                <span class="token comment">// 获取当前类加载的位置 即/target/classes下</span>                <span class="token comment">// sensitive-words.txt/application.properties等文件在经过maven编译后在classes目录下</span>                <span class="token comment">// 定义输入流</span>                <span class="token class-name">InputStream</span> in <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"sensitive-words.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 利用缓存读取</span>                <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 定义敏感词</span>            <span class="token class-name">String</span> keyword<span class="token punctuation">;</span>            <span class="token comment">// 敏感词在文件中是一行一行书写的</span>            <span class="token comment">// 当读到的keyword不为空，就添加到树中</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>keyword <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 将敏感词初始化到树中</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addKeyWord</span><span class="token punctuation">(</span>keyword<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 将敏感词构造到前缀树中     * @param keyword 敏感词文件中的敏感词     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addKeyWord</span><span class="token punctuation">(</span><span class="token class-name">String</span> keyword<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 设置一个临时节点 作为指向当前根节点的指针</span>        <span class="token comment">// 每次构造最开始 tempNode为根节点</span>        <span class="token class-name">TrieNode</span> tempNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>rootNode<span class="token punctuation">;</span>        <span class="token comment">// 遍历敏感词的每一个字符 判断树中是否已经存在</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keyword<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Character</span> c <span class="token operator">=</span> keyword<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 查看当前节点的子节点中是否有该字符</span>            <span class="token class-name">TrieNode</span> subNode <span class="token operator">=</span> tempNode<span class="token punctuation">.</span><span class="token function">getSubNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果没有 给当前节点添加一个子节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>subNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前子节点为空 新添加一个子节点</span>                subNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                tempNode<span class="token punctuation">.</span><span class="token function">addSubNode</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> subNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 有子节点 则将根节点置为该子节点 准备遍历下一个字符</span>            tempNode <span class="token operator">=</span> subNode<span class="token punctuation">;</span>            <span class="token comment">// 如果当前字符是该敏感词的最后一个字符 将wordEnd标记置为true</span>            <span class="token comment">// 执行完if中的语句后 一个敏感词就构造到前缀树中了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> keyword<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                tempNode<span class="token punctuation">.</span><span class="token function">setWordEnd</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 传入字符串，在前缀树中遍历字符串的字符，若遍历过程中找到了目标字符串的敏感词，将其替换为***     * @param text 要过滤的目标字符串     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">sensitiveFilter</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 若是空字符串 返回空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 根节点</span>        <span class="token comment">// 每次在目标字符串中找到一个敏感词，完成替换之后，都要再次从根节点遍历树开始一次新的过滤</span>        <span class="token class-name">TrieNode</span> tempNode <span class="token operator">=</span> rootNode<span class="token punctuation">;</span>        <span class="token comment">// begin指针作用是目标字符串每次过滤的开头</span>        <span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// position指针的作用是指向待过滤的字符</span>        <span class="token comment">// 若position指向字符是敏感词结尾，则text.subString(begin,position+1)就是一个敏感词</span>        <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 过滤后的结果</span>        <span class="token class-name">StringBuilder</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 开始遍历 position移动到目标字符串尾部是 循环结束</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 最开始时begin指向0 是第一次过滤的开始</span>            <span class="token comment">// position也是0</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 忽略用户故意输入的符号 例如嫖※娼 忽略※后 前后字符其实也是敏感词</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSymbol</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 判断当前节点是否为根节点</span>                <span class="token comment">// 若是根节点 则代表目标字符串第一次过滤或者目标字符串中已经被遍历了一部分</span>                <span class="token comment">// 因每过滤掉一个敏感词，都要将tempNode重新置为根节点</span>                <span class="token comment">// 以重新去前缀树中继续过滤目标字符串剩下的部分</span>                <span class="token comment">// 因此若是根节点，代表一次新过滤开始，可以直接将该特殊符号字符放入到结果字符串中</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tempNode <span class="token operator">==</span> rootNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 将用户输入的符号添加到result中</span>                    result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 此时将单词begin指针向后移动一位，以开始新的一个单词过滤</span>                    begin<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 若当前节点不是根节点，那说明符号字符后的字符还需要继续过滤</span>                <span class="token comment">// 所以单词开头位begin不变化，position向后移动一位继续过滤</span>                position<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 判断当前节点的子节点是否有目标字符c</span>            tempNode <span class="token operator">=</span> tempNode<span class="token punctuation">.</span><span class="token function">getSubNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果没有 代表当前beigin-position之间的字符串不是敏感词</span>            <span class="token comment">// 但begin+1-position却不一定不是敏感词</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tempNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 所以只将begin指向的字符放入过滤结果</span>                result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// position和begin都指向begin+1</span>                position <span class="token operator">=</span> <span class="token operator">++</span>begin<span class="token punctuation">;</span>                <span class="token comment">// 再次过滤</span>                tempNode <span class="token operator">=</span> rootNode<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span><span class="token function">isWordEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果找到了子节点且子节点是敏感词的结尾</span>                <span class="token comment">// 则当前begin-position间的字符串是敏感词 将敏感词替换掉</span>                result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>REPLACE_WORD<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// begin移动到敏感词的下一位</span>                begin <span class="token operator">=</span> <span class="token operator">++</span>position<span class="token punctuation">;</span>                <span class="token comment">// 再次过滤</span>                tempNode <span class="token operator">=</span> rootNode<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 特殊情况</span>                <span class="token comment">// 虽position指向字符在树中存在，但非敏感词结尾</span>                <span class="token comment">// 且position指向字符为目标字符串末尾</span>                <span class="token comment">// 因此begin-position之间的字符串不是敏感词</span>                <span class="token comment">// 但begin+1-position之间的不一定不存在敏感词</span>                <span class="token comment">// 所以只将begin指向的字符放入过滤结果</span>                result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// position和begin都指向begin+1</span>                position <span class="token operator">=</span> <span class="token operator">++</span>begin<span class="token punctuation">;</span>                <span class="token comment">// 再次过滤</span>                tempNode <span class="token operator">=</span> rootNode<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// position指向的字符在树中存在，但非敏感词结尾，且position没到目标字符串末尾</span>                position<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> begin <span class="token operator">&lt;</span> text<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 判断是否为特殊符号     * @param c     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isSymbol</span><span class="token punctuation">(</span><span class="token class-name">Character</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 0x2E80~0x9FFF 是东亚文字范围</span>        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token class-name">CharUtils</span><span class="token punctuation">.</span><span class="token function">isAsciiAlphanumeric</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0x2E80</span> <span class="token operator">||</span> c <span class="token operator">></span> <span class="token number">0x9FFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发20-并发容器中的坑</title>
      <link href="2020/04/16/java-bing-fa-20-bing-fa-rong-qi-zhong-de-keng/"/>
      <url>2020/04/16/java-bing-fa-20-bing-fa-rong-qi-zhong-de-keng/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发20-并发容器中的坑"><a href="#Java并发20-并发容器中的坑" class="headerlink" title="Java并发20-并发容器中的坑"></a>Java并发20-并发容器中的坑</h3><p>Java中的容器主要可分为四个大类，分别是<code>List</code>、<code>Map</code>、<code>Set</code> 和<code>Queue</code>。</p><p>如何将非线程安全容器变成线程安全—<strong>Java并发12</strong>：把非线程安全容器封装在对象内部，然后控制好访问路径。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SafeArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>  <span class="token comment">//封装ArrayList</span>  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//控制访问路径</span>  <span class="token keyword">synchronized</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">addIfNotExist</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JDK做了类似的包装：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Set</span> set <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedSet</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Map</span> map <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="注意竞态条件"><a href="#注意竞态条件" class="headerlink" title="注意竞态条件"></a>注意竞态条件</h3><p><strong>切记：组合操作需要注意竞态条件问题</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Iterator</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里就产生了竞态条件 执行5行的时候 可能已经无next()了。</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token function">foo</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确做法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Iterator</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">foo</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>SychronizedList</code>、<code>SychronizedMap</code>、<code>SychronizedSet</code>、<code>Vector</code>、<code>Stack</code>、<code>HashTable</code>都是<code>sychronized</code>关键字实现的，称为<strong>同步容器</strong>。</p><p><code>Vector</code>、<code>Stack</code>和<code>Hashtable</code>这三个容器不是基于包装类实现的，对这三个容器的遍历，同样要加锁保证互斥。</p><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.png" alt="并发容器"></p><p>JDK1.5之前主要指同步容器线程安全，但性能差。1.5之后提供了性能更好的<strong>并发容器</strong>，并发容器遍历线程安全。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List 里面只有一个实现类就是<code>CopyOnWriteArrayList</code>。</p><p><code>CopyOnWriteArrayList</code>内部维护了一个数组，成员变量<code>array</code>就指向这个内部数组，所有的读操作都是基于 <code>array</code>进行的，如下图所示，迭代器<code>Iterator</code>遍历的就是<code>array</code>数组。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E6%89%A7%E8%A1%8C%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%86%85%E9%83%A8%E6%95%B0%E7%BB%84.png" alt="执行迭代的内部数组"></p><p>如果遍历<code>array</code>时，还有一个写操作，例如增加元素，<code>CopyOnWriteArrayList</code>会将<code>array</code>复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将<code>array</code>指向新的数组。</p><p><img src="F:\data\blogImg\执行增加元素的内部结构图.png"></p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code>接口的两个实现是<code>ConcurrentHashMap</code>和<code>ConcurrentSkipListMap</code>。</p><p><code>ConcurrentHashMap</code>的<code>key</code>无序，<code>ConcurrentSkipListMap</code>的<code>key</code>有序。</p><p><strong>它们的<code>key</code>和<code>value</code>都不能为空</strong>。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%90%84Map%E5%AF%B9Key&Value%E7%9A%84%E8%A6%81%E6%B1%82.png" alt="各Map对Key&amp;Value的要求"></p><p><code>ConcurrentSkipListMap</code>里面的<code>SkipList</code>本身就是一种数据结构。</p><p>跳表插入、删除、查询操作平均的时间复杂度是<code>O(log n)</code>，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若<code>ConcurrentHashMap</code>的性能还不够满意，可以尝试<code>ConcurrentSkipListMap</code>。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>Set</code>接口的两个实现是<code>CopyOnWriteArraySet</code>和<code>ConcurrentSkipListSet</code>，使用场景可以参考前面讲述的 <code>CopyOnWriteArrayList</code>和<code>ConcurrentSkipListMap</code>，它们的原理都是一样的。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>阻塞与非阻塞：当队列已满，入队操作阻塞；当队列已空时，出队操作阻塞。</p><p>单端与双端：单端即队尾入队，队首出队；双端即队首队尾皆可入队出队。</p><p><strong>Java并发包里阻塞队列都用<code>Blocking</code>关键字标识，单端队列使用<code>Queue</code>标识，双端队列使用<code>Deque</code>标识。</strong></p><ul><li><p>单端阻塞队列</p><p>  <code>ArrayBlockingQueue</code></p><p>  内部持有一个数组队列。</p><p>  <code>LinkedBlockingQueue</code></p><p>  内部持有一个链表队列。</p><p>  <code>SynchronousQueue</code></p><p>  内部不持有队列，生产者-消费者模式下，生产者线程的入对操作必须等待消费者线程的出队操作。</p><p>  <code>LinkedTransferQueue</code>（大佬工作中没用过）</p><p>  结合了<code>LinkedBlockingQueue</code>&amp;<code>SynchronousQueue</code>功能，性能比<code>LinkedBlockingQueue</code>好。</p><p>  <code>PriorityBlockingQueue</code></p><p>  支持按照优先级出队。</p><p>  <code>DelayQueue</code></p><p>  支持延时出队。</p><p>  <img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%8D%95%E7%AB%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="单端阻塞队列"></p></li><li><p>双端阻塞队列</p><p>  <code>LinkedBlockingDeque</code></p><p>  <img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%8F%8C%E7%AB%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="双端阻塞队列"></p></li><li><p>单端非阻塞队列</p><p>  <code>ConcurrentLinkedQueue</code></p></li><li><p>双端非阻塞队列</p><p>  <code>ConcurrentLinkedDeque</code></p></li></ul><p><strong>实际工作中，一般都不建议使用无界的队列(即没有设置队列容量)，因为数据量大了之后很容易导致 OOM。</strong></p><p><strong>只有<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>是支持有界的。</strong></p><p><strong>要学会根据容器特性选择才是关键。</strong></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>线上系统 CPU 突然飙升，怀疑在并发场景里使用了<code>HashMap</code>，因为在1.8之前的版本里并发执行<code>HashMap.put()</code>可能会导致CPU飙升到100%，该如何验证猜测？</p><blockquote><p>Java7中的HashMap在执行put操作时会涉及到扩容，由于扩容时链表并发操作会造成链表成环，所以可能导致cpu飙升100%。</p><p>——<strong>黑白尤文</strong></p></blockquote><p>为何<code>concurrentskiplistmap</code>比<code>concurrenthashmap</code>性能好?</p><p>如果key冲突比较大，<code>hashmap</code>还是要靠链表或者<code>tree</code>来解决冲突的，所以O(1)是理想值。</p><p>同时增删改操作很多也影响<code>hashmap</code>性能。这个也是要看冲突情况，也就是说<code>hashmap</code>的稳定性差。</p><p>如果很不幸正好偶遇它的稳定性问题，同时又接受不了，就可以尝试<code>skiplistmap</code>，它能保证稳定性，无论并发量是多大，也没有key冲突的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发19-CountDownLatch&amp;CyclicBarrier</title>
      <link href="2020/04/16/java-bing-fa-19-countdownlatch-cyclicbarrier/"/>
      <url>2020/04/16/java-bing-fa-19-countdownlatch-cyclicbarrier/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发19-CountDownLatch-amp-CyclicBarrier"><a href="#Java并发19-CountDownLatch-amp-CyclicBarrier" class="headerlink" title="Java并发19-CountDownLatch&amp;CyclicBarrier"></a>Java并发19-CountDownLatch&amp;CyclicBarrier</h3><h3 id="对账系统流程"><a href="#对账系统流程" class="headerlink" title="对账系统流程"></a>对账系统流程</h3><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E6%9F%90%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="某对账系统流程图"></p><p>抽象后的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 查询未对账订单</span>  pos <span class="token operator">=</span> <span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 查询派送单</span>  dos <span class="token operator">=</span> <span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 执行对账操作</span>  diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> dos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 差异写入差异库</span>  <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>订单存到订单库，根据订单产生派送单；派送单存在派送单库，根据派送单执行派送。</p><p>对账系统每天根据订单进行对账，比对订单和派送单。</p><h3 id="利用并行优化"><a href="#利用并行优化" class="headerlink" title="利用并行优化"></a>利用并行优化</h3><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="对账系统单线程执行示意图"></p><p>单线程下<code>getPOrders()</code>&amp;<code>getDOrders()</code>执行耗时长，可以采用并行，让这两个方法同时执行。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%AF%B9%E8%B4%A6%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="对账系统并行执行示意图"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 查询未对账订单</span>  <span class="token class-name">Thread</span> T1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>    pos <span class="token operator">=</span> <span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  T1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 查询派送单</span>  <span class="token class-name">Thread</span> T2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>    dos <span class="token operator">=</span> <span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  T2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待T1、T2结束</span>  T1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  T2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 执行对账操作</span>  diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> dos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 差异写入差异库</span>  <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但上面代码，会导致每次循环都产生新线程，可以用线程池。</p><h3 id="CountDownLatch实现线程等待"><a href="#CountDownLatch实现线程等待" class="headerlink" title="CountDownLatch实现线程等待"></a>CountDownLatch实现线程等待</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建2个线程的线程池</span><span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 查询未对账订单</span>  executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span> <span class="token punctuation">&#123;</span>    pos <span class="token operator">=</span> <span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 查询派送单</span>  executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span> <span class="token punctuation">&#123;</span>    dos <span class="token operator">=</span> <span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* ？？如何实现等待？？*/</span>    <span class="token comment">// 执行对账操作</span>  diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> dos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 差异写入差异库</span>  <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路：最直接的办法是弄一个计数器，初始值设置成 2，当执行完pos = getPOrders();这个操作之后将计数器减 1，执行完dos = getDOrders();之后也将计数器减 1，在主线程里，等待计数器等于 0；当计数器等于 0 时，说明这两个查询操作执行完了。等待计数器等于 0 其实就是一个条件变量，用管程实现起来也很简单。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建2个线程的线程池</span><span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 计数器初始化为2</span>  <span class="token class-name">CountDownLatch</span> latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 查询未对账订单</span>  executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span> <span class="token punctuation">&#123;</span>    pos <span class="token operator">=</span> <span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 查询派送单</span>  executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span> <span class="token punctuation">&#123;</span>    dos <span class="token operator">=</span> <span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待两个查询操作结束</span>  latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 执行对账操作</span>  diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> dos<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 差异写入差异库</span>  <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用CyclicBarrier实现线程同步"><a href="#用CyclicBarrier实现线程同步" class="headerlink" title="用CyclicBarrier实现线程同步"></a>用CyclicBarrier实现线程同步</h3><p>实际上可以让查询在操作的同时，check()&amp;save()方法也同时执行。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%AE%8C%E5%85%A8%E5%B9%B6%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="完全并行示意图"></p><p>这样可以设计两个队列，一个订单队列，一个派送单队列。</p><p>订单队列进行查询订单，每查询到一个即生产了一个订单数据。</p><p>派送单队列查询派送单，每查询到一个即生产了一个派送单数据。</p><p>生产出的订单和派送单数据要<strong>一一对应</strong>，都生产出来后，再通知管理check()&amp;save()的线程进行操作。</p><p><strong>因此，图中线程T1和线程T2要互相等待，生产出对应数据后再通知T3，即T3等待T1&amp;T2的完成的通知。</strong></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%8F%8C%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="双队列示意图"></p><p>思路：利用一个计数器来解决，计数器初始化为 2，线程 T1 和 T2 生产完一条数据都将计数器减 1，如果计数器大于 0 则线程 T1 或者 T2 等待。如果计数器等于 0，则通知线程 T3，并唤醒等待的线程 T1 或者 T2，与此同时，将计数器重置为 2，这样线程 T1 和线程 T2 生产下一条数据的时候就可以继续使用这个计数器。</p><p><strong><code>CyclicBarrier</code>的计数器有自动重置的功能，当减到 0 的时候，会自动重置你设置的初始值。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 订单队列</span><span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">P</span><span class="token punctuation">></span></span> pos<span class="token punctuation">;</span><span class="token comment">// 派送单队列</span><span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">D</span><span class="token punctuation">></span></span> dos<span class="token punctuation">;</span><span class="token comment">// 执行回调的线程池 </span><span class="token class-name">Executor</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token class-name">CyclicBarrier</span> barrier <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">P</span> p <span class="token operator">=</span> pos<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">D</span> d <span class="token operator">=</span> dos<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 执行对账操作</span>  diff <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 差异写入差异库</span>  <span class="token function">save</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">checkAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 循环查询订单库</span>  <span class="token class-name">Thread</span> T1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 查询订单库</span>      pos<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getPOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 等待</span>      barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  T1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 循环查询运单库</span>  <span class="token class-name">Thread</span> T2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>存在未对账订单<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 查询运单库</span>      dos<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">getDOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 等待</span>      barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  T2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong><code>CountDownLatch</code>主要用来解决一个线程等待多个线程的场景；<code>CyclicBarrier</code>是一组线程之间互相等待。</strong></p><p>除此之外<code>CountDownLatch</code>的计数器不能循环利用，也就是说一旦计数器减到 0，再有线程调用<code>await()</code>，该线程会直接通过。</p><p><code>CyclicBarrier</code>的计数器可以循环利用，具备自动重置的功能，一旦计数器减到 0 会自动重置设置的初始值。</p><p>除此之外，<code>CyclicBarrier</code>还可以设置回调函数。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><code>CyclicBarrier</code>的回调函数使用了一个固定大小的线程池，是否有必要？</p><blockquote><p>我问题其实是两个:<br>1.为啥要用线程池，而不是在回调函数中直接调用？<br>2.线程池为啥使用单线程的？</p><p>1.使用线程池是为了异步操作，否则回调函数是同步调用，即本次对账操作执行完才能进行下一轮的检查。<br>2.线程数量固定为1，防止了多线程并发导致的数据不一致，因为订单和派送单是两个队列，只有单线程去两个队列中取消息才不会出现消息不匹配的问题。</p><p>——<strong>傲</strong></p></blockquote><blockquote><p>推荐使用ThreadPoolExecutor去实现线程池，并且实现里面的RejectedExecutionHandler和ThreadFactory，这样可以方便当调用订单查询和派送单查询的时候出现full gc的时候 dump文件 可以快速定位出现问题的线程是哪个业务线程，如果是CountDownLatch，建议设置超时时间，避免由于业务死锁没有调用countDown()导致现线程睡死的情况。</p><p>——<strong>曾轼麟</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发18-StampLock</title>
      <link href="2020/04/16/java-bing-fa-18-stamplock/"/>
      <url>2020/04/16/java-bing-fa-18-stamplock/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发18-StampedLock"><a href="#Java并发18-StampedLock" class="headerlink" title="Java并发18-StampedLock"></a>Java并发18-StampedLock</h3><h3 id="StampedLock模式"><a href="#StampedLock模式" class="headerlink" title="StampedLock模式"></a>StampedLock模式</h3><p>读多写少场景下，<code>StampedLock</code>的性能比<code>ReadWriteLock</code>性能更好。</p><pre class="line-numbers language-ReadWriteLock```支持读锁和写锁。" data-language="ReadWriteLock```支持读锁和写锁。"><code class="language-ReadWriteLock```支持读锁和写锁。">&#96;&#96;&#96;StampedLock&#96;&#96;&#96;支持写锁，悲观读锁和乐观读。&#96;StampedLock&#96; 的写锁和悲观读锁加锁成功后，会返回一个 &#96;stamp&#96;；解锁的时候，需要传入这个 &#96;stamp&#96;。&#96;&#96;&#96;javafinal StampedLock sl &#x3D; new StampedLock();  &#x2F;&#x2F; 获取&#x2F;释放悲观读锁示意代码long stamp &#x3D; sl.readLock();try &#123;  &#x2F;&#x2F;省略业务相关代码&#125; finally &#123;  sl.unlockRead(stamp);&#125;&#x2F;&#x2F; 获取&#x2F;释放写锁示意代码long stamp &#x3D; sl.writeLock();try &#123;  &#x2F;&#x2F;省略业务相关代码&#125; finally &#123;  sl.unlockWrite(stamp);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>StampedLock</code>性能好的原因是因为它支持乐观读，乐观读即无锁。</strong></p><h3 id="官方示例展示"><a href="#官方示例展示" class="headerlink" title="官方示例展示"></a>官方示例展示</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token class-name">StampedLock</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//计算到原点的距离  </span>  <span class="token keyword">int</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 乐观读</span>    <span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">tryOptimisticRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 读入局部变量，</span>    <span class="token comment">// 读的过程数据可能被修改</span>    <span class="token keyword">int</span> curX <span class="token operator">=</span> x<span class="token punctuation">,</span> curY <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token comment">//判断执行读操作期间，</span>    <span class="token comment">//是否存在写操作，如果存在，</span>    <span class="token comment">//则sl.validate返回false</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sl<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 升级为悲观读锁</span>      stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        curX <span class="token operator">=</span> x<span class="token punctuation">;</span>        curY <span class="token operator">=</span> y<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//释放悲观读锁</span>        sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>curX <span class="token operator">*</span> curX <span class="token operator">+</span> curY <span class="token operator">*</span> curY<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><p><code>StampedLock</code>的功能仅仅是<code>ReadWriteLock</code>的子集，<code>StampedLock</code>不支持重入。</p><p><code>StampedLock</code>的悲观读锁、写锁都不支持条件变量。</p><p>使用<code>StampedLock</code>一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 <code>readLockInterruptibly()</code>和写锁 <code>writeLockInterruptibly()</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">StampedLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> T1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>  <span class="token comment">// 获取写锁</span>  lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 永远阻塞在此处，不释放写锁</span>  <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>T1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 保证T1获取写锁</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> T2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>  <span class="token comment">//阻塞在悲观读锁</span>  lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>T2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 保证T2阻塞在读锁</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//中断线程T2</span><span class="token comment">//会导致线程T2所在CPU飙升</span><span class="token comment">//内部实现里while循环里面对中断的处理有点问题</span>T2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>T2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h3><p><code>StampedLock</code>读模板：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">StampedLock</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 乐观读</span><span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">tryOptimisticRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读入方法局部变量</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 校验stamp</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sl<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 升级为悲观读锁</span>  stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 读入方法局部变量</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//释放悲观读锁</span>    sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//使用方法局部变量执行业务操作</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>StampedLock</code>写模板：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 写共享变量</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>  sl<span class="token punctuation">.</span><span class="token function">unlockWrite</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>找BUG</p><p><code>StampedLock</code>支持锁的降级（<code>tryConvertToReadLock()</code>）和升级（<code>tryConvertToWriteLock()</code>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token class-name">StampedLock</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 存在问题的方法</span><span class="token keyword">void</span> <span class="token function">moveIfAtOrigin</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">,</span> <span class="token keyword">double</span> newY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0.0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//tryConvertToWriteLock(stamp)这个方法内部会释放悲观读锁stamp  </span>    <span class="token keyword">long</span> ws <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">tryConvertToWriteLock</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">!=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      x <span class="token operator">=</span> newX<span class="token punctuation">;</span>      y <span class="token operator">=</span> newY<span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>      stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>  sl<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在锁升级成功的时候，最后没有释放最新的写锁，可以在<code>if</code>块的<code>break</code>上加个<code>stamp=ws</code>进行释放。</p><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p><code>StampedLock</code>读模板，先通过乐观读或者悲观读锁获取变量，然后利用这些变量处理业务逻辑，会不会存在线程安全的情况? 比如，读出来的变量没问题，但是进行业务逻辑处理的时候，这时读出的变量有可能发生变化了(比如被写锁改写了)？所以当使用乐观读锁时，是不是等业务都处理完了（比如先利用变量把距离计算完），再判断变量是否被改写，如果没改写，直接return;如果已经改写，则使用悲观读锁做同样的事情。不过如果业务比较耗时，可能持有悲观锁的时间会比较长?</p><p>——<strong>Presley</strong></p><blockquote><p><strong>两种场景，如果处理业务需要保持互斥，那么就用互斥锁，如果不需要保持互斥才可以用读写锁。</strong></p><p><strong>一般来讲缓存是不需要保持互斥性的，能接受瞬间的不一致。</strong></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发17-读写锁实现缓存</title>
      <link href="2020/04/16/java-bing-fa-17-du-xie-suo-shi-xian-huan-cun/"/>
      <url>2020/04/16/java-bing-fa-17-du-xie-suo-shi-xian-huan-cun/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发17-读写锁实现缓存"><a href="#Java并发17-读写锁实现缓存" class="headerlink" title="Java并发17-读写锁实现缓存"></a>Java并发17-读写锁实现缓存</h3><p>读写锁原则：</p><ul><li>允许多个线程同时读共享变量</li><li>同一时间只允许一个线程写共享变量</li><li>写变量的时候不允许读</li></ul><h3 id="快速实现一个缓存"><a href="#快速实现一个缓存" class="headerlink" title="快速实现一个缓存"></a>快速实现一个缓存</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token class-name">ReadWriteLock</span> rwl <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 读锁</span>  <span class="token keyword">final</span> <span class="token class-name">Lock</span> r <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 写锁</span>  <span class="token keyword">final</span> <span class="token class-name">Lock</span> w <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 读缓存</span>  <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>         r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 写缓存</span>  <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>         w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这种缓存，需要先使用<code>put()</code>将缓存一次性加载好，再提供使用。</p><h3 id="按需加载缓存"><a href="#按需加载缓存" class="headerlink" title="按需加载缓存"></a>按需加载缓存</h3><p>按需加载，先看缓存中是否有值，有就返回，没有就从数据库中查询。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token class-name">ReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token class-name">Lock</span> r <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token class-name">Lock</span> w <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">V</span> v <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//读缓存</span>    r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      v <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span><span class="token punctuation">&#123;</span>      r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token comment">//缓存中存在，返回</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>      <span class="token comment">//缓存中不存在，查询数据库</span>    w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//再次验证</span>      <span class="token comment">//其他线程可能已经查询过数据库</span>      v <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token comment">//查询数据库</span>        v<span class="token operator">=</span>省略代码无数        m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span><span class="token punctuation">&#123;</span>      w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关注代码第25行，为什么拿到写锁不直接去数据库取数据，要再验证下<code>v</code>是否不存在？</p><p>假设线程 <code>T1</code>获取写锁后查询数据库并更新缓存，最终释放写锁。此时线程 <code>T2</code> 和 <code>T3</code> 会再有一个线程能获取写锁。假设是 <code>T2</code>，如果不再次验证，此时 <code>T2</code> 会再次查询数据库。<code>T2</code> 释放写锁之后，<code>T3</code> 也会再次查询一次数据库。</p><p><strong>实际上线程 <code>T1</code> 已经把缓存的值设置好了，<code>T2</code>、<code>T3</code> 完全没有必要再次查询数据库。</strong></p><p><strong>因此再次验证的方式能够避免高并发场景下重复查询数据的问题。</strong></p><h3 id="读写锁的升级与降级"><a href="#读写锁的升级与降级" class="headerlink" title="读写锁的升级与降级"></a>读写锁的升级与降级</h3><ul><li>升级</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//读缓存</span>r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         ①<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>  v <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> ②  <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//再次验证并更新缓存</span>      <span class="token comment">//省略详细代码</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span><span class="token punctuation">&#123;</span>      w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">finally</span><span class="token punctuation">&#123;</span>  r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ③<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种读锁还没释放，在读锁作用范围内使用写锁是不可行的。<strong>读锁还未释放，会导致写锁永久等待。</strong></p><ul><li>降级</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">CachedData</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">Object</span> data<span class="token punctuation">;</span>  <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> cacheValid<span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token class-name">ReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 读锁  </span>  <span class="token keyword">final</span> <span class="token class-name">Lock</span> r <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 写锁</span>  <span class="token keyword">final</span> <span class="token class-name">Lock</span> w <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">processCachedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取读锁</span>    r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 释放读锁，因为不允许读锁的升级</span>      r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 获取写锁</span>      w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 再次检查状态  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          data <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          cacheValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 释放写锁前，降级为读锁</span>        <span class="token comment">// 降级是可以的</span>        r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 释放写锁</span>        w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 此处仍然持有读锁</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token function">use</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>cacheValid</code>标记了<code>data</code>是否可用，即是否有<code>data</code>缓存。</p><p>如果可用，读缓存直接执行到第34行使用数据，再释放锁。</p><p>如果不可用，先释放<strong>读锁</strong>，再获取<strong>写锁</strong>，再次检查<code>data</code>是否可用，因为获取到<strong>写锁</strong>的时候可能已经被其他线程写过<code>data</code>了，获取<code>data</code>后将<code>cacheValid</code>置为<code>true</code>。</p><p>第26行允许释放锁前将<strong>写锁</strong>降级为<strong>读锁</strong>，即<strong>写锁</strong>还未释放时，获取<strong>读锁</strong>。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>读写锁类似于<code>ReentrantLock</code>，也支持公平模式和非公平模式。</p><p><strong>读锁</strong>和<strong>写锁</strong>都实现了 <code>java.util.concurrent.locks.Lock</code> 接口，支持<code>lock()</code> ，<code>tryLock()</code>、<code>lockInterruptibly()</code> 等方法。</p><p>但只有<strong>写锁</strong>支持条件变量，<strong>读锁</strong>不支持条件变量，<strong>读锁</strong>调用 <code>newCondition()</code> 会抛出 <code>UnsupportedOperationException</code> 异常。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>线上服务CPU占用率很小，但停止响应了，可能是读写锁升级导致的问题，如何确定？</p><blockquote><p>考虑到是线上应用，可采用以下方法</p><ol><li>源代码分析。查找<code>ReentrantReadWriteLock</code>在项目中的引用，看下写锁是否在读锁释放前尝试获取</li><li>如果线上是Web应用，应用服务器比如说是Tomcat，并且开启了JMX，则可以通过JConsole等工具远程查看下线上死锁的具体情况。</li></ol><p>——<strong>Kǎfκã²⁰²⁰</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发16:Semaphore</title>
      <link href="2020/04/15/java-bing-fa-16-semaphore-shi-xian-xian-liu-qi/"/>
      <url>2020/04/15/java-bing-fa-16-semaphore-shi-xian-xian-liu-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发16-Semaphore"><a href="#Java并发16-Semaphore" class="headerlink" title="Java并发16:Semaphore"></a>Java并发16:Semaphore</h3><p>信号量由计算机科学家迪杰斯特拉(Dijkstra)于 1965 年提出，之后 15 年信号量一直都是并发编程领域的终结者。直到 1980 年管程才被提出，才有第二选择。目前几乎所有支持并发编程的语言都支持信号量机制，所以学好信号量很有必要。</p><h3 id="信号量模型"><a href="#信号量模型" class="headerlink" title="信号量模型"></a>信号量模型</h3><p><strong>一个计数器，一个等待队列，三个方法。</strong></p><p>计数器和等待队列对外透明，通过信号量中的3个方法访问，分别是：</p><ul><li><code>init()</code>：设置计数器初始值。</li><li><code>down()</code>：计数器的值减 1；如果计数器的值小于 0，当前线程将被阻塞，否则当前线程可以继续执行。</li><li><code>up()</code>：计数器的值加 1；如果计数器的值小于或者等于 0，唤醒等待队列中的一个线程，并将其从等待队列中移除。</li></ul><p>这3个方法都是由信号量模型实现，Java中信号量模型由 <code>java.util.concurrent.Semaphore</code> 实现的，<code>Semaphore</code> 这个类能够保证这三个方法都是原子操作。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="信号量模型图"></p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Semaphore</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 计数器</span>  <span class="token keyword">int</span> count<span class="token punctuation">;</span>  <span class="token comment">// 等待队列</span>  <span class="token class-name">Queue</span> queue<span class="token punctuation">;</span>  <span class="token comment">// 初始化操作</span>  <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">=</span>c<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 调用down() count减1  acquire()</span>  <span class="token keyword">void</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//将当前线程插入等待队列</span>      <span class="token comment">//阻塞当前线程</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 调用up() count+1  release()</span>  <span class="token keyword">void</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//&lt;=0说明有等待线程</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//移除等待队列中的某个线程T</span>      <span class="token comment">//唤醒线程T</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment">//初始化信号量 初始值为1</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Semaphore</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用信号量保证互斥    首先要明确acquire和release是原子操作</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 调用后 count = 0 如再有线程调用方法，count=-1，新线程阻塞</span>  s<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    count<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//调用后 count+1 不一定为1</span>    s<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="限流器"><a href="#限流器" class="headerlink" title="限流器"></a>限流器</h3><p>从上面可以看到<code>Semaphore</code>相比<code>Lock</code>可以让多个线程访问临界区。</p><p>比如对象池的设计，要保证同一时间内&lt;=N(对象池大小)个线程访问对象池。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ObjPool</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> pool<span class="token punctuation">;</span>  <span class="token comment">// 用信号量实现限流器</span>  <span class="token keyword">final</span> <span class="token class-name">Semaphore</span> sem<span class="token punctuation">;</span>  <span class="token comment">// 构造函数 size即计数器初始值 t即池中的对象</span>  <span class="token class-name">ObjPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//线程安全的池</span>    pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//初始化池</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      pool<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//信号量</span>    sem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 利用对象池的对象，调用func</span>  <span class="token class-name">R</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">></span></span> func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">T</span> t <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//从对象池取出</span>        t <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> function<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//释放资源还回对象池</span>        pool<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Go</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 创建对象池</span>        <span class="token class-name">ObjPool</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjPool</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"do method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>pool<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ObjPool</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> pool<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token class-name">ObjPool</span> pool<span class="token punctuation">,</span> <span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>pool <span class="token operator">=</span> pool<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 通过对象池获取t，之后执行 </span>            pool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>t <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路主要体现在<code>execute()</code>的设计上。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><code>Vector</code>换成<code>Arraylist</code>是否可以?</p><p>不可以。多线程同时在操作集合，用<code>Arraylist</code>不安全，会导致<code>t</code>可能为<code>null</code>。</p><p>1、<code>acquire</code>；2、<code>apply</code>；3、<code>finally release</code>；4、<code>return</code></p><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>我理解的和管程相比，信号量可以实现的独特功能就是同时允许多个线程进入临界区，但是信号量不能做的就是同时唤醒多个线程去争抢锁，只能唤醒一个阻塞中的线程，而且信号量模型是没有Condition的概念的，即阻塞线程被醒了直接就运行了而不会去检查此时临界条件是否已经不满足了，基于此考虑信号量模型才会设计出只能让一个线程被唤醒，否则就会出现因为缺少Condition检查而带来的线程安全问题。正因为缺失了Condition，所以用信号量来实现阻塞队列就很麻烦，因为要自己实现类似Condition的逻辑。</p><p>——<strong>CCC</strong></p></blockquote><blockquote><p>进入临界区的N个线程不安全。<code>add</code>/<code>remove</code>都是不安全的。</p><p>拿<code>remove()</code>举例, <code>ArrayList</code>的<code>remove()</code>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">></span><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">></span><span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span>modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token comment">// 假设两个线程 t1,t2都执行到这一步，t1让出cpu,t2执行</span><span class="token operator">></span><span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token comment">//此步t1继续执行，t1,t2拿到的oldValue是一样的，两个线程能拿到同一个对象，明显线程不安全</span><span class="token operator">></span><span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span>elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// clear to let GC do its work</span><span class="token operator">></span><span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>——<strong>Presley</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发15:Lock&amp;Condition-2</title>
      <link href="2020/04/15/java-bing-fa-15-lock-condition-2/"/>
      <url>2020/04/15/java-bing-fa-15-lock-condition-2/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发15-Lock-amp-Condition-2"><a href="#Java并发15-Lock-amp-Condition-2" class="headerlink" title="Java并发15:Lock&amp;Condition-2"></a>Java并发15:Lock&amp;Condition-2</h3><p>Java代码默认同步处理。</p><p>通过两种方式实现异步：</p><ul><li>调用方创建一个子线程，在子线程方法中调用，即<strong>异步调用</strong>。</li><li>方法实现时，创建一个新线程执行主要逻辑，主线程直接<code>return</code>，即<strong>异步方法</strong>。</li></ul><h3 id="Dubbo源码分析"><a href="#Dubbo源码分析" class="headerlink" title="Dubbo源码分析"></a>Dubbo源码分析</h3><p><strong>RPC 调用，在 TCP 协议层面，发送完 RPC 请求后，线程不会等待 RPC 的响应结果。</strong></p><p><strong>但平常中的RPC调用大多是同步的</strong>，如<strong>Dubbo</strong>中的<code>DefaultFuture.get()</code>方法，就是帮忙做了异步转同步操作。</p><p><strong>Dubbo</strong>中的<code>DefaultFuture</code>类的精简代码（2.7.3版本已不用lock和signal了）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建锁与条件变量</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> done <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用方通过该方法等待结果</span><span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//记录请求发起时间</span>  <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//锁定资源  </span>  lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//循环判断请求是否完成 MESA管程模型wait()范式</span>  <span class="token comment">//若未完成，就继续wait</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//condition设置超时wait</span>    done<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//记录当前执行时间</span>    <span class="token keyword">long</span> cur<span class="token operator">=</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//如果此时完成 或者 已超时 跳出循环</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> cur<span class="token operator">-</span>start <span class="token operator">></span> timeout<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>  lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//未完成抛异常  </span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//完成后返回请求完成的结果</span>  <span class="token keyword">return</span> <span class="token function">returnFromResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// RPC结果是否已经返回</span><span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> response <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// RPC结果返回时调用该方法   </span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReceived</span><span class="token punctuation">(</span><span class="token class-name">Response</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    response <span class="token operator">=</span> res<span class="token punctuation">;</span>    <span class="token comment">//这边check done!=null 没必要 done必不为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>done <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//后来改成了signalAll();</span>      done<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>DefaultFuture本质上只是一种future实现，所以理论上可以有多个线程同时持有同一个future并调用 get方法，如这时候使用signal()就有可能导致有些线程会请求超时</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">></span><span class="token class-name">DefaultFuture</span> future <span class="token operator">=</span> currentClient<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">></span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">></span><span class="token annotation punctuation">@Override</span><span class="token operator">></span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>——<strong>牧名</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发14:Lock&amp;Condition-1</title>
      <link href="2020/04/10/java-bing-fa-14-lock-condition-1/"/>
      <url>2020/04/10/java-bing-fa-14-lock-condition-1/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发14-Lock-amp-Condition-1"><a href="#Java并发14-Lock-amp-Condition-1" class="headerlink" title="Java并发14:Lock&amp;Condition-1"></a>Java并发14:Lock&amp;Condition-1</h3><p>Java并发包中提供Lock和Condition实现管程，Lock作为锁，Condition作为同步。</p><h3 id="为什么有了synchronized还要Lock和Condition"><a href="#为什么有了synchronized还要Lock和Condition" class="headerlink" title="为什么有了synchronized还要Lock和Condition?"></a>为什么有了synchronized还要Lock和Condition?</h3><p>举例：</p><p>死锁-破坏不可抢占条件：</p><pre class="line-numbers language-synchronized" data-language="synchronized"><div class="caption"><span>```作为互斥锁是做不到的。</span></div><code class="language-synchronized">原因是&#96;&#96;&#96; synchronized&#96;&#96;&#96; 申请资源的时候，如果申请不到，线程直接进入阻塞状态，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。&gt;对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。因此设计了&#96;&#96;&#96;Lock&#96;&#96;&#96;和&#96;&#96;&#96;Condition&#96;&#96;&#96;解决这种问题。### Lock的设计解决&#96;&#96;&#96;synchronized&#96;&#96;&#96;的问题有3种方案，根据这3种方案设计了新的互斥锁&#96;&#96;&#96;Lock&#96;&#96;&#96;。+ 能够响应中断：&#96;&#96;&#96;synchronized&#96;&#96;&#96;是一旦获取不到资源，直接阻塞，没法唤醒。如果可以让获取互斥锁的线程响应中断，就可以从阻塞中通过响应中断唤醒。+ 支持超时：&#96;&#96;&#96;synchronized&#96;&#96;&#96;是一旦获取不到资源，直接阻塞，并且没超时限制。如果可以让获取互斥锁的线程支持超时，就可以从阻塞中超时设置唤醒。+ 非阻塞地获取锁：如果可以让线程获取锁失败的时候，不进入阻塞状态，而是直接返回，这样有机会让线程释放自己的资源。##### 相关API&#96;&#96;&#96;java&#x2F;&#x2F; 支持中断的APIvoid lockInterruptibly()   throws InterruptedException;&#x2F;&#x2F; 支持超时的APIboolean tryLock(long time, TimeUnit unit)   throws InterruptedException;&#x2F;&#x2F; 支持非阻塞获取锁的APIboolean tryLock();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Lock如何保证可见性"><a href="#Lock如何保证可见性" class="headerlink" title="Lock如何保证可见性"></a>Lock如何保证可见性</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** The synchronization state.*/</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment">/*** Performs lock.  Try immediate barge, backing up to normal* acquire on failure.*/</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*** Performs non-fair tryLock.  tryAcquire is implemented in* subclasses, but both need nonfair try for trylock method.*/</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前线程实例</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取state变量的值,即当前锁被重入的次数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//state为0,说明当前锁未被任何线程持有</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//以cas方式获取锁</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将当前线程标记为持有锁的线程</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//获取锁成功,非重入</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//当前线程即持有锁线程,说明该锁被重入</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span><span class="token comment">//计算state变量要更新的值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//非同步方式更新state值</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//获取锁成功,重入</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//走到这里说明尝试获取锁失败</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lock()```为加锁，```nonfairTryAcquire()```为加锁中的底层代码，```tryRelease()```为释放锁中的底层代码。" data-language="lock()```为加锁，```nonfairTryAcquire()```为加锁中的底层代码，```tryRelease()```为释放锁中的底层代码。"><code class="language-lock()```为加锁，```nonfairTryAcquire()```为加锁中的底层代码，```tryRelease()```为释放锁中的底层代码。">&#96;&#96;&#96;state&#96;&#96;&#96;是&#96;&#96;&#96;volatile&#96;&#96;&#96;修饰的变量。总体逻辑为：&#96;&#96;&#96;lock()&#96;&#96;&#96; 会读写state中的值，&#96;&#96;&#96;unlock()&#96;&#96;&#96;会读写state中的值。根据Happens-Before规则进行梳理：+ **顺序性规则**：对于线程 T1，&#96;&#96;&#96;value+&#x3D;1&#96;&#96;&#96;**Happens-Before**释放锁的操作&#96;&#96;&#96;unlock()&#96;&#96;&#96;；+ **volatile 变量规则**：由于 &#96;&#96;&#96;state &#x3D; 1&#96;&#96;&#96; 会先读取 &#96;&#96;&#96;state&#96;&#96;&#96;，所以线程 &#96;&#96;&#96;T1&#96;&#96;&#96; 的 &#96;&#96;&#96;unlock()&#96;&#96;&#96; 操作 &#96;&#96;&#96;Happens-Before&#96;&#96;&#96; 线程&#96;&#96;&#96; T2&#96;&#96;&#96; 的 &#96;&#96;&#96;lock()&#96;&#96;&#96; 操作；+ **传递性规则**：线程 &#96;&#96;&#96;T1&#96;&#96;&#96; 的 &#96;&#96;&#96;value+&#x3D;1&#96;&#96;&#96;**Happens-Before**线程 T2 的 &#96;&#96;&#96;lock()&#96;&#96;&#96; 操作。### 可重入锁**可重入锁即线程可以重复获取同一把锁。****可重入函数即多个线程可以同时调用该函数**。&gt;&#96;&#96;&#96;synchronized&#96;&#96;&#96;拥有强制原子性的内部锁机制，是一个可重入锁。&gt;&gt;因此，在一个线程使用&#96;&#96;&#96;synchronized&#96;&#96;&#96;方法时调用该对象另一个&#96;&#96;&#96;synchronized&#96;&#96;&#96;方法，即一个线程得到一个对象锁后再次请求该对象锁，是**永远可以拿到锁的**。&gt;&gt;在Java内部，同一个线程调用自己类中其他&#96;&#96;&#96;synchronized&#96;&#96;&#96;方法&#x2F;块时不会阻碍该线程的执行，同一个线程对同一个对象锁是可重入的，同一个线程可以获取同一把锁多次，也就是可以多次重入。&gt;&gt;**原因是Java中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。**&gt;&gt;可重入函数的条件&gt;&gt;- 不在函数内使用静态或全局数据。&gt;- 不返回静态或全局数据，所有数据都由函数的调用者提供。&gt;- 使用本地数据（工作内存），或者通过制作全局数据的本地拷贝来保护全局数据。&gt;- 不调用不可重入函数。&gt;&gt;可重入与线程安全&gt;&gt;一般而言，可重入的函数一定是线程安全的，反之则不一定成立。&gt;&gt;在不加锁的前提下，如果一个函数用到了全局或静态变量，那么它不是线程安全的，也不是可重入的。&gt;&gt;如果加以改进，对全局变量的访问加锁，此时它是线程安全的但不是可重入的，因为通常的加锁方式是针对不同线程的访问（如Java的&#96;&#96;&#96;synchronized&#96;&#96;&#96;），当同一个线程多次访问就会出现问题。&gt;&gt;只有当函数满足可重入的四条条件时，才是可重入的。&gt;&gt;——**CieloSun**&#96;&#96;&#96;javaclass X &#123;  private final Lock rtl &#x3D; new ReentrantLock();  int value;  public int get() &#123;    &#x2F;&#x2F; 获取锁    rtl.lock();         ②    try &#123;      return value;    &#125; finally &#123;      &#x2F;&#x2F; 保证锁能释放      rtl.unlock();    &#125;  &#125;  public void addOne() &#123;    &#x2F;&#x2F; 获取锁    rtl.lock();      try &#123;      value &#x3D; 1 + get(); ①    &#125; finally &#123;      &#x2F;&#x2F; 保证锁能释放      rtl.unlock();    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当线程 T1 执行到 ① 处时，已经获取到了锁 rtl ，当在 ① 处调用 <code>get()</code> 方法时，会在 ② 再次对锁 rtl 执行加锁操作。此时，如果锁 rtl 是可重入的，那么线程 T1 可以再次加锁成功；如果锁 rtl 是不可重入的，那么线程 T1 此时会被阻塞。</p><h3 id="公平-amp-非公平锁"><a href="#公平-amp-非公平锁" class="headerlink" title="公平&amp;非公平锁"></a>公平&amp;非公平锁</h3><p>构造时默认非公平锁，传一<code>boolean</code>值，<code>true</code>为公平锁，<code>false</code>为非公平锁。</p><p>公平：有先来后到，先来的线程，抢锁的时候能先抢。</p><p>非公平：没有先来后到，所有队列中的线程大家一起抢锁。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//无参构造函数：默认非公平锁</span><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//根据公平策略参数创建锁</span><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用锁的最佳实践"><a href="#用锁的最佳实践" class="headerlink" title="用锁的最佳实践"></a>用锁的最佳实践</h3><ul><li>永远只在更新对象的成员变量时加锁</li><li>永远只在访问可变的成员变量时加锁</li><li>永远不在调用其他对象的方法时加锁</li></ul><p>可能其他方法里面有线程<code>sleep()</code>的调用，也可能会有奇慢无比的 I/O 操作，这些都会严重影响性能。更可怕的是，其他类的方法可能也会加锁，然后双重加锁就可能导致死锁。</p><p><strong>性能上：ReentrantLock和Synchronized基本持平，场景上能用Synchronized，就尽量用。</strong></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>是否存在死锁问题？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 转账</span>  <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> tar<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// myway:lock.tryLock((int)Math.random()*1000, TimeUnit.NANOSECONDS);</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>tar<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>              tar<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>              <span class="token comment">//break;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>              tar<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span><span class="token comment">//if</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token comment">//if</span>     <span class="token comment">//bestway：sleep一个随机时间避免活锁 </span>     <span class="token comment">//Thread.sleep(随机时间);</span>    <span class="token punctuation">&#125;</span><span class="token comment">//while</span>  <span class="token punctuation">&#125;</span><span class="token comment">//transfer</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有可能活锁：</p><p>若A和B同时向对方转账，同时执行到第7行，双方都持有了自己的锁，接着同时执行到第9行，都获取不到对方的锁，接着又到第18行同时释放自己的锁，再次尝试重新获取。会导致双方一直取不到锁。</p><p>增加随机等待时间，转账成功过后应跳出循环。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发13:阶段小结</title>
      <link href="2020/04/10/java-bing-fa-13-jie-duan-xiao-jie/"/>
      <url>2020/04/10/java-bing-fa-13-jie-duan-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发13-阶段小结"><a href="#Java并发13-阶段小结" class="headerlink" title="Java并发13:阶段小结"></a>Java并发13:阶段小结</h3><h3 id="逐篇梳理"><a href="#逐篇梳理" class="headerlink" title="逐篇梳理"></a>逐篇梳理</h3><p>整个前13篇文章是个串行进行的，循序渐进的学习逻辑,主要讲的都是<strong>并发方向的理论知识</strong>。</p><h4 id="0-并发问题核心点："><a href="#0-并发问题核心点：" class="headerlink" title="0-并发问题核心点："></a>0-并发问题核心点：</h4><p>宏观地梳理了下并发问题的核心点：<strong>分工</strong>，<strong>同步</strong>，<strong>互斥</strong>。解决并发问题主要要做这3个模块。</p><h4 id="1-并发问题源头："><a href="#1-并发问题源头：" class="headerlink" title="1-并发问题源头："></a>1-并发问题源头：</h4><p>因CPU&amp;内存&amp;I/O存在效率差异，因此产生了CPU做线程切换。</p><p>因为线程切换，导致了<strong>可见性</strong>，<strong>有序性</strong>，<strong>原子性</strong>三个并发问题的源头。</p><h4 id="2-Happens-Before规则"><a href="#2-Happens-Before规则" class="headerlink" title="2-Happens-Before规则"></a>2-Happens-Before规则</h4><p>JVM通过<code>Happens-Before</code>解决了<strong>可见性</strong>和<strong>有序性</strong>问题。</p><h4 id="3-互斥锁-上-amp-4-互斥锁-下-："><a href="#3-互斥锁-上-amp-4-互斥锁-下-：" class="headerlink" title="3-互斥锁(上)&amp;4-互斥锁(下)："></a>3-互斥锁(上)&amp;4-互斥锁(下)：</h4><p>JVM通过加锁机制解决了<strong>原子性</strong>问题。</p><h4 id="5-死锁："><a href="#5-死锁：" class="headerlink" title="5-死锁："></a>5-死锁：</h4><p>因为加锁导致程序出现<strong>死锁</strong>，所以引出其解决方法。</p><h4 id="6-等待通知机制："><a href="#6-等待通知机制：" class="headerlink" title="6-等待通知机制："></a>6-等待通知机制：</h4><p>因为线程争夺锁的关系和死锁等问题的存在，因此需要利用<strong>等待通知机制</strong>实现线程协作。</p><h4 id="7-安全性-amp-活跃性和性能问题："><a href="#7-安全性-amp-活跃性和性能问题：" class="headerlink" title="7-安全性&amp;活跃性和性能问题："></a>7-安全性&amp;活跃性和性能问题：</h4><p>1-6从微观角度看并发问题。</p><p>7则是从宏观看：</p><ul><li>安全性：<strong>数据竞争</strong>、<strong>竞态条件</strong></li><li>活跃性：<strong>死锁，活锁和饥饿问题</strong></li><li>性能：锁带来等性能问题，<strong>评估性能</strong></li></ul><h4 id="8-管程："><a href="#8-管程：" class="headerlink" title="8-管程："></a>8-管程：</h4><p><strong>Java并发编程解决互斥和同步的核心基础理论</strong>。</p><p>以上关于并发的理论基础基本上全覆盖了，接下来具体到<code>Java</code>上。</p><h4 id="9-Java线程生命周期"><a href="#9-Java线程生命周期" class="headerlink" title="9-Java线程生命周期"></a>9-Java线程生命周期</h4><p>Java线程基础，开发必备知识。</p><h4 id="10-线程数量"><a href="#10-线程数量" class="headerlink" title="10-线程数量"></a>10-线程数量</h4><p>如何根据场景估算线程数量。</p><h4 id="11-局部变量"><a href="#11-局部变量" class="headerlink" title="11-局部变量"></a>11-局部变量</h4><p>明确了方法执行过程，明确了局部变量不存在线程安全问题。</p><h4 id="12-面向对象与并发"><a href="#12-面向对象与并发" class="headerlink" title="12-面向对象与并发"></a>12-面向对象与并发</h4><p>如何利用面向对象更好地实现并发。</p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="并发编程理论基础模块思维导图"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发12:面向对象与并发</title>
      <link href="2020/04/09/java-bing-fa-12-mian-xiang-dui-xiang-yu-bing-fa/"/>
      <url>2020/04/09/java-bing-fa-12-mian-xiang-dui-xiang-yu-bing-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发12-面向对象与并发"><a href="#Java并发12-面向对象与并发" class="headerlink" title="Java并发12:面向对象与并发"></a>Java并发12:面向对象与并发</h3><p>在Java 语言里，面向对象思想能让并发编程更简单。</p><h3 id="封装共享变量"><a href="#封装共享变量" class="headerlink" title="封装共享变量"></a>封装共享变量</h3><p><strong>封装：将属性和实现细节封装在对象内部，外界对象只能通过目标对象提供的公共方法来间接访问这些内部属性。</strong></p><p><strong>Tip:将共享变量作为对象属性封装在内部，对所有公共方法制定并发访问策略。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>  <span class="token comment">//将计数器封装为对象，提供了线程安全的方法</span>  <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">++</span>value<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tip:很多变量实际上是不变的，如身份证号等，将它声明为final。</strong></p><h3 id="识别共享变量间的约束条件"><a href="#识别共享变量间的约束条件" class="headerlink" title="识别共享变量间的约束条件"></a>识别共享变量间的约束条件</h3><p>约束条件决定了并发访问策略。</p><p>一定要识别出所有共享变量之间的约束条件，如果约束条件识别不足，很可能导致制定的并发访问策略南辕北辙。</p><p>共享变量之间的约束条件，反映在代码里，基本上都会有 if 语句，<strong>一定要特别注意竞态条件</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SafeWM</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 库存上限</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> upper <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 库存下限</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> lower <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置库存上限</span>  <span class="token keyword">void</span> <span class="token function">setUpper</span><span class="token punctuation">(</span><span class="token keyword">long</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 检查参数合法性</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&lt;</span> lower<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    upper<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 设置库存下限</span>  <span class="token keyword">void</span> <span class="token function">setLower</span><span class="token punctuation">(</span><span class="token keyword">long</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 检查参数合法性</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">></span> upper<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    lower<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 省略其他业务代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第11行和第19行践行了库存上下限关系，但由于竞态条件导致线程不安全。</p><h3 id="制定并发访问策略"><a href="#制定并发访问策略" class="headerlink" title="制定并发访问策略"></a>制定并发访问策略</h3><h4 id="方案策略"><a href="#方案策略" class="headerlink" title="方案策略"></a>方案策略</h4><ul><li>避免共享：主要由线程本地存储&amp;为每个任务分配独立线程实现。</li><li>不变模式：Java领域较少，其他领域如 Actor 模式、CSP 模式以及函数式编程的基础都是不变模式。</li><li>管程和其他同步工具：管程以及并发包中适用于不同场景的工具。</li></ul><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul><li>优先使用成熟工具类：Java并发包</li><li>迫不得已使用同步原语：如<code>synchronized</code>、<code>Lock</code>、<code>Semaphore</code>。</li><li>避免过早优化：安全第一，先保证程序安全，出现性能瓶颈再优化。</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>上述代码如何使其线程安全？</p><ul><li>对<code>setUpper()</code>&amp;<code>setLower</code>加锁</li><li>将<code>upper</code>和<code>lower</code>封装成类，避免静态条件产生。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Boundary</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> upper<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> lower<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Boundary</span><span class="token punctuation">(</span><span class="token keyword">int</span> upper<span class="token punctuation">,</span> <span class="token keyword">int</span> lower<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>upper <span class="token operator">&lt;=</span> lower<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"参数错误！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>upper <span class="token operator">=</span> upper<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lower <span class="token operator">=</span> lower<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SafeWM</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Boundary</span> boundary<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBoundary</span><span class="token punctuation">(</span><span class="token class-name">Boundary</span> boundary<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>boundary <span class="token operator">=</span> boundary<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>我的理解是set方法线程不安全的点在于竞态条件中获取到的值通过了判断，但是在set的时候可能不是最新的。方法二类封装的两个属性都是不可变的，在setBoundary()方法中去赋值就不会存在值被更新的情况，类似于ThreadLocal的独立副本。</p><p>——<strong>大饶Raysir</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发11:局部变量</title>
      <link href="2020/04/08/java-bing-fa-11-ju-bu-bian-liang/"/>
      <url>2020/04/08/java-bing-fa-11-ju-bu-bian-liang/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发11-局部变量"><a href="#Java并发11-局部变量" class="headerlink" title="Java并发11:局部变量"></a>Java并发11:局部变量</h3><h3 id="方法执行"><a href="#方法执行" class="headerlink" title="方法执行"></a>方法执行</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">7</span>；<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行第2行时，CPU会找到<code>fibonacci()</code>的地址，跳转到该地址执行代码，执行完返回。</p><p>找到调用方法下一行，也就是第3行的地址去执行。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="方法的调用过程"></p><p><strong>CPU通过其堆栈寄存器找到调用方法的参数和返回地址，栈是和方法相关的，被称为调用栈。</strong></p><p><strong>堆栈寄存器指向栈顶内存地址。</strong></p><p><strong>如图3个方法A-B-C的调用关系，运行时会构造出以下形式调用栈，每个方法有自己独立的空间，称为栈帧。</strong></p><p><strong>每个栈帧都有对应方法需要的参数和返回地址。</strong></p><p><strong>调用方法时，会创建新栈帧，并压入调用栈；</strong></p><p><strong>方法返回时，对应栈帧被自动弹出。即栈帧和方法是同生共死的。</strong></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E8%B0%83%E7%94%A8%E6%A0%88%E7%BB%93%E6%9E%84.png" alt="调用栈结构"></p><p>栈结构支持方法调用这个方案非常普遍，以至于 CPU 里内置了栈寄存器。</p><p>各编程语言方法的内部执行原理出奇一致：都是靠栈结构解决的。</p><p>Java 虽然是靠虚拟机解释执行的，但是方法的调用也是利用栈结构解决的。</p><h3 id="先计算参数"><a href="#先计算参数" class="headerlink" title="先计算参数"></a>先计算参数</h3><p>方法调用时会先计算参数，再执行方法体。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//先执行get()+1</span>  <span class="token function">set</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例如写日志的代码，<strong>如果日志级别设置为 INFO，虽然这行代码不会写日志，但是会计算”The var1：” + var1 + “, var2:” + var2的值，因为方法调用前会先计算参数。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"The var1："</span> <span class="token operator">+</span> var1 <span class="token operator">+</span> <span class="token string">", var2:"</span> <span class="token operator">+</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更好的写法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"The var1：&#123;&#125;, var2:&#123;&#125;"</span><span class="token punctuation">,</span> var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>这种写法仅将参数压栈，而没有参数的计算。使用{}占位符是写日志的一个良好习惯。</strong></p><h3 id="局部变量的位置"><a href="#局部变量的位置" class="headerlink" title="局部变量的位置"></a>局部变量的位置</h3><p>局部变量作用域是方法内部，方法执行完，局部变量就失效了。和<strong>方法也是同生死</strong>。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E4%BF%9D%E6%8A%A4%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E8%B0%83%E7%94%A8%E6%A0%88%E7%BB%93%E6%9E%84.png" alt="保护局部变量的调用栈结构"></p><p><strong>一个变量如果想跨越方法的边界，就必须创建在堆里。</strong></p><h3 id="调用栈与线程"><a href="#调用栈与线程" class="headerlink" title="调用栈与线程"></a>调用栈与线程</h3><p><strong>每个线程都有自己独立的调用栈</strong></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="线程与调用栈的关系"></p><p><strong>线程的调用栈独立，方法的栈帧独立，局部变量只存在于对应方法的栈帧中，因此无并发问题。</strong></p><h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><p><strong>线程封闭：即仅在单线程内访问数据</strong>，作为解决并发问题的一种手段。</p><p>例如从数据库连接池里获取的连接 Connection，在JDBC 规范并未要求 Connection 必须是线程安全的。</p><p>数据库连接池通过线程封闭技术，保证一个 Connection 一旦被一个线程获取之后，在这个线程关闭 Connection 之前的这段时间里，不会再分配给其他线程，从而保证了 Connection 不会有并发问题。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>递归调用太深，可能导致栈溢出。原因是什么？有哪些解决方案？</p><p>不断开辟栈帧导致内存空间不足。</p><p>不使用递归，循环替代/减少递归次数/尾递归。</p><p>所有的递归算法都可以用非递归算法实现。</p><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>栈溢出原因：<br>因为每调用一个方法就会在栈上创建一个栈帧，方法调用结束后就会弹出该栈帧，而栈的大小不是无限的，所以递归调用次数过多的话就会导致栈溢出。而递归调用的特点是每递归一次，就要创建一个新的栈帧，而且还要保留之前的环境（栈帧），直到遇到结束条件。所以递归调用一定要明确好结束条件，不要出现死循环，而且要避免栈太深。<br>解决方法：</p><ol><li>简单粗暴，不要使用递归，使用循环替代。缺点：代码逻辑不够清晰；</li><li>限制递归次数；</li><li>使用尾递归，尾递归是指在方法返回时只调用自己本身，且不能包含表达式。编译器或解释器会把尾递归做优化，使递归方法不论调用多少次，都只占用一个栈帧，所以不会出现栈溢出。然鹅，Java没有尾递归优化。</li></ol><p>——<strong>uyong</strong></p></blockquote><blockquote><p>对于这句话：“ new 出来的对象是在堆里，局部变量在栈里”<br>我觉得应该是对象在堆里，引用（句柄）在栈里。</p><p>——<strong>suynan</strong></p><p>note:方法中new出来的对象属于局部变量：对象在堆里，但是指针在栈里。</p></blockquote><blockquote><p>如果方法内部又有多线程，那方法内部的局部变量是不是也不是线程安全。</p><p>——<strong>Xiao</strong></p><blockquote><p>方法内部的局部变量传到线程里要是final修饰的，不会有这种问题。 </p><p>——<strong>Carisy</strong></p></blockquote></blockquote><blockquote><p><strong>其实就是并发调用方法而产生的局部变量指向的内存地址都是不同的。</strong></p><p><strong>所以同一时刻只会有一个线程去操作这些局部变量指向的内存。</strong></p><p>——<strong>crudBoy</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发10:线程数量</title>
      <link href="2020/04/07/java-bing-fa-10-xian-cheng-shu-liang/"/>
      <url>2020/04/07/java-bing-fa-10-xian-cheng-shu-liang/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发10-线程数量"><a href="#Java并发10-线程数量" class="headerlink" title="Java并发10:线程数量"></a>Java并发10:线程数量</h3><h3 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h3><p><strong>提升性能</strong></p><h3 id="如何度量性能"><a href="#如何度量性能" class="headerlink" title="如何度量性能"></a>如何度量性能</h3><p><strong>延迟</strong>和<strong>吞吐量</strong></p><p><strong>延迟</strong>：发出请求到收到响的时间；延迟越短，程序执行得越快，性能越好。</p><p><strong>吞吐量</strong>：单位时间内能处理请求的数量；吞吐量越大，程序能处理的请求越多，性能越好。</p><p>两个指标内部有一定的联系（同等条件下，延迟越短，吞吐量越大），但是由于它们隶属不同维度（一个是时间维度，一个是空间维度），不能互相转换。</p><h3 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h3><p><strong>降低延迟&amp;提升吞吐量</strong></p><h3 id="多线程应用场景"><a href="#多线程应用场景" class="headerlink" title="多线程应用场景"></a>多线程应用场景</h3><p><strong>提高性能方向：一是优化算法，二是将硬件性能发挥极致。前者算法范畴，后者与并发编程有关。</strong></p><p>实际上操作系统已经解决了硬件的利用率问题：例如操作系统已经解决了磁盘和网卡的利用率问题，利用中断机制还能避免 CPU 轮询 I/O 状态，也提升了 CPU 的利用率。</p><p>但操作系统解决硬件利用率问题的对象往往是单一的硬件设备，而并发程序往往需要 CPU 和 I/O 设备相互配合工作，<strong>需要解决 CPU 和 I/O 设备综合利用率的问题</strong>。</p><p><strong>所以利用多线程解决综合利用率问题。</strong></p><h3 id="综合利用率示例"><a href="#综合利用率示例" class="headerlink" title="综合利用率示例"></a>综合利用率示例</h3><p>前提：假设程序按CPU 计算和 I/O 操作交叉执行的方式运行， CPU 计算和 I/O 操作的耗时是 1:1。</p><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>一个线程，执行 CPU 计算，I/O 设备空闲；执行 I/O 操作，CPU 空闲。</p><p>CPU 的利用率和 I/O 设备的利用率为50%。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="单线程执行示意图"></p><h4 id="双线程"><a href="#双线程" class="headerlink" title="双线程"></a>双线程</h4><p>两个线程，线程 A 执行 CPU 计算，线程 B 执行 I/O 操作；线程 A 执行 I/O 操作，线程 B 执行 CPU 计算。</p><p>这CPU 的利用率和 I/O 设备的利用率就为100%。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="两个线程执行示意图"></p><p>即：逆向思维：<strong>如果 CPU 和 I/O 设备的利用率都很低，那么可以尝试通过增加线程来提高吞吐量</strong>。</p><h4 id="单核-amp-多核区别"><a href="#单核-amp-多核区别" class="headerlink" title="单核&amp;多核区别"></a>单核&amp;多核区别</h4><p>单核CPU下，多线程用来平衡CPU与I/O操作，如上面的单线程示例。</p><p>但若多线程没有I/O操作，在单核CPU下反而会使性能降低，大家都在排队等计算。</p><p>多核CPU下，多线程纯CPU计算也可能提升性能。</p><h5 id="多核CPU纯计算提升性能示例"><a href="#多核CPU纯计算提升性能示例" class="headerlink" title="多核CPU纯计算提升性能示例"></a>多核CPU纯计算提升性能示例</h5><p>计算1+2+3+…+100亿，4核CPU就可以4个线程同时执行。</p><p>A计算1-25亿，B计算25-50亿，C计算50-75亿，D计算75-100亿。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%A4%9A%E6%A0%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="多核多线程执行示意图"></p><h3 id="创建合适的线程数"><a href="#创建合适的线程数" class="headerlink" title="创建合适的线程数"></a>创建合适的线程数</h3><h4 id="场景分类"><a href="#场景分类" class="headerlink" title="场景分类"></a>场景分类</h4><ul><li><p>I/O密集型计算</p><p>  I/O 操作执行的时间相对于 CPU 计算非常长</p></li><li><p>CPU 密集型计算</p><p>  大部分场景下都是纯 CPU 计算</p></li></ul><h4 id="CPU-密集型计算"><a href="#CPU-密集型计算" class="headerlink" title="CPU 密集型计算"></a>CPU 密集型计算</h4><p>对于该场景，多线程本质上是提升多核 CPU 的利用率。</p><p>理论上：对于一个 4 核的 CPU，每个核一个线程，CPU利用率就是100%。</p><p><strong>工程上：线程的数量一般会设置为“CPU 核数 +1”。</strong></p><p><strong>当线程因为偶尔的内存页失效或其他原因导致阻塞时，额外的线程可以顶上，从而保证 CPU 的利用率。</strong></p><h4 id="I-O密集型计算"><a href="#I-O密集型计算" class="headerlink" title="I/O密集型计算"></a>I/O密集型计算</h4><p><strong>单核最佳线程数 = 1 +（I/O 耗时 / CPU 耗时）</strong></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E4%B8%89%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="三线程执行示意图"></p><p>如图<code>T(I/O) = 2T(CPU)</code>，即单位时间内做一次I/O的时间可以做两次CPU计算。</p><p>所以同一时间，2个线程做I/O，1个线程做CPU计算。</p><p>*<em>多核最佳线程数 = CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]*</em></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CPU密集型：根据公式，硬件性能发挥到极致。</p><p>I/O密集型：不同的I/O操作场景下动态变化。</p><p>因此工程上，原则是将硬件的性能发挥到极致。</p><p>压测时，要重点关注 CPU、I/O 设备的利用率和性能指标（响应时间、吞吐量）之间的关系。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>有些经验上认为对于 I/O 密集型应用，最佳线程数应该为：<code>2*CPU 的核数 + 1</code>，是否合理？</p><blockquote><p>从理论上来讲，这个经验值一定是靠不住的。</p><p>但是经验值对于很多“I/O 耗时 / CPU 耗时”不太容易确定的系统来说，却是一个<strong>很好的初始值</strong>。</p><p>最佳线程数最终还是靠压测来确定的，实际工作中大家面临的系统，“I/O 耗时 / CPU 耗时”往往都大于 1，所以基本上都是在这个初始值的基础上增加。增加的过程中，应<strong>关注线程数是如何影响吞吐量和延迟的</strong>。</p><p>一般来讲，随着线程数的增加，吞吐量会增加，延迟也会缓慢增加；但是当线程数增加到一定程度，吞吐量就会开始下降，延迟会迅速增加。<strong>这个时候基本上就是线程能够设置的最大值了。</strong></p><p>实际工作中，不同的 I/O 模型对最佳线程数的影响非常大，例如Nginx 用的是非阻塞 I/O，采用的是多进程单线程结构，Nginx 本来是一个 I/O 密集型系统，但是最佳进程数设置的却是 CPU 的核数，完全参考的是 CPU 密集型的算法。所以理论还是要活学活用。</p></blockquote><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>更多的精力其实应该放在算法的优化上，线程池的配置，按照经验配置一个，随时关注线程池大小对程序的影响即可，具体做法：可以为你的程序配置一个全局的线程池，需要异步执行的任务，扔到这个全局线程池处理，线程池大小按照经验设置，每隔一段时间打印一下线程池的利用率，做到心里有数。</p><p>看到过太多的代码，遇到要执行一个异步任务就创建一个线程池，导致整个程序的线程池大到爆，完全没必要。而且大多数时候，提高吞吐量可以通过使用缓存、优化业务逻辑、提前计算好等方式来处理，真没有必要太过于关注线程池大小怎么配置，如果小了就改大一点，大了改小一点就好，从老师本文的篇幅也可以看出来。</p><p>经验值不靠谱的另外一个原因，大多数情况下，一台服务器跑了很多程序，每个程序都有自己的线程池，那CPU如何分配？还是根据实际情况来确定比较好。</p><p>——<strong>CHEN川</strong></p><blockquote><p>文中三线程图假设io是并行的，恐怕并不合理，实际理论上真的是只要两倍线程就好，再多的线程也无法提高利用率，都会因为io阻塞。</p><p>——<strong>Evan</strong></p></blockquote></blockquote><blockquote><p>个人觉得公式话性能问题有些不妥，定性的io密集或者cpu密集很难在定量的维度上反应出性能瓶颈，而且公式上忽略了线程数增加带来的cpu消耗，性能优化还是要定量比较好，这样不会盲目，比如io已经成为了瓶颈，增加线程或许带来不了性能提升，这个时候是不是可以考虑用cpu换取带宽，压缩数据，或者逻辑上少发送一些。最后一个问题，我的答案是大部分应用环境是合理的，题目也说了是积累了一些调优经验后给出的方案，没有特殊需求，初始值我会选大家都在用的伪标准。</p><p>——<strong>假行僧</strong></p></blockquote><blockquote><p>在4核8线程的处理器使用Runtime.availableProcessors()结果是8，超线程技术属于硬件层面上的并发，从cpu硬件来看是一个物理核心有两个逻辑核心，但因为缓存、执行资源等存在共享和竞争，所以两个核心并不能并行工作。超线程技术统计性能提升大概是30%左右，并不是100%。另外，不管设置成4还是8，现代操作系统层面的调度应该是按逻辑核心数，也就是8来调度的（除非禁用超线程技术）。所以我觉得这种情况下，严格来说，4和8都不一定是合适的，具体情况还是要根据应用性能和资源的使用情况进行调整。</p><p>——<strong>榣山樵客™</strong></p><blockquote><p>工作中都是按照逻辑核数来的，理论值和经验值只是提供个指导，实际上还是要靠压测。</p><p>——作者</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发9:Java线程生命周期</title>
      <link href="2020/04/06/java-bing-fa-9-java-xian-cheng-sheng-ming-zhou-qi/"/>
      <url>2020/04/06/java-bing-fa-9-java-xian-cheng-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发9-Java线程生命周期"><a href="#Java并发9-Java线程生命周期" class="headerlink" title="Java并发9:Java线程生命周期"></a>Java并发9:Java线程生命周期</h3><h3 id="通用线程生命周期"><a href="#通用线程生命周期" class="headerlink" title="通用线程生命周期"></a>通用线程生命周期</h3><p>通用线程生命周期基本上可以用“五态模型”来描述。</p><p>这五态是：<strong>初始状态</strong>、<strong>可运行状态</strong>、<strong>运行状态</strong>、<strong>休眠状态</strong>和<strong>终止状态</strong>。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E9%80%9A%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png"></p><ul><li><p><strong>初始状态</strong></p><p>  线程已经被创建，但还不允许分配 CPU 执行。</p><p>  这个状态属于编程语言特有，这里所谓的被创建，仅是在编程语言层面被创建，而在操作系统层面，线程还没有创建。</p></li><li><p><strong>可运行状态</strong></p><p>  线程可以分配 CPU 执行。</p><p>  这个状态，真操作系统线程已经被成功创建，可以分配 CPU 执行。</p></li><li><p><strong>运行状态</strong></p><p>  当有空闲的 CPU ，操作系统会将其分配给一个处于可运行状态的线程，被分配到 CPU 的线程的状态就转换成运行状态。</p></li><li><p><strong>休眠状态</strong></p><p>  运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或等待某个事件（例如条件变量），那么线程的状态就会转换到休眠状态，同时释放 CPU 使用权。</p><p>  <strong>休眠状态的线程永远没有机会获得 CPU 使用权。</strong></p><p>  当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</p></li><li><p><strong>终止状态</strong></p><p>  <strong>线程执行完或者出现异常就会进入终止状态</strong>，终止状态的线程不会切换到其他任何状态，<strong>进入终止状态也就意味着线程的生命周期结束了。</strong></p></li></ul><p>Java 语言里把<strong>可运行状态</strong>和<strong>运行状态</strong>合并了，这两个状态在操作系统调度层面有用。</p><p>Java语言把<strong>休眠状态</strong>给细分了。</p><p> JVM 层面不关心这两个状态，因为 <strong>JVM 把线程调度交给操作系统处理了</strong>。</p><h3 id="Java线程生命周期"><a href="#Java线程生命周期" class="headerlink" title="Java线程生命周期"></a>Java线程生命周期</h3><p>Java线程有6中状态：</p><ul><li><p>NEW(初始化状态)</p></li><li><p>RUNNABLE(可运行/运行状态)</p></li><li><p>BLOCKED(阻塞状态)</p></li><li><p>WAITING(无限时等待状态)</p></li><li><p>TIMED_WAITING(有限时等待状态)</p></li><li><p>TERMINATED(终止状态)</p><p>  <img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png"></p></li></ul><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><h4 id="RUNNABLE-与-BLOCKED-的状态转换"><a href="#RUNNABLE-与-BLOCKED-的状态转换" class="headerlink" title="RUNNABLE 与 BLOCKED 的状态转换"></a>RUNNABLE 与 BLOCKED 的状态转换</h4><pre class="line-numbers language-synchronized" data-language="synchronized"><div class="caption"><span>```修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待。</span></div><code class="language-synchronized">这种情况下，等待的线程会从**RUNNABLE**转换到**BLOCKED**状态。当等待的线程获得&#96;&#96;&#96; synchronized &#96;&#96;&#96;隐式锁时，会从**BLOCKED**转换到**RUNNABLE**状态。线程调用阻塞式 API 时，在操作系统层面，线程会转换到休眠状态；在 JVM 层面，Java 线程的状态不会发生变化，即Java 线程的状态依然保持**RUNNABLE**状态。JVM 层面并不关心操作系统调度相关的状态，在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I&#x2F;O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了**RUNNABLE**状态。**Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。**#### RUNNABLE 与 WAITING 的状态转换1、线程被调用&#96;&#96;&#96;wait()&#96;&#96;&#96;方法，除非被&#96;&#96;&#96;notify()&#96;&#96;&#96;&#x2F;&#96;&#96;&#96;notifyAll()&#96;&#96;&#96;唤醒，否则永远没有争抢CPU执行权的资格。该状态下的线程，已经释放了其持有的锁资源，待再次被唤醒时，需要重新争夺锁资源。被唤醒后，重新回到**RUNNABLE**状态。2、线程被调用&#96;&#96;&#96;Thread.join()&#96;&#96;&#96;方法，执行该方法的线程会由**RUNNABLE**转换为**WAITING**状态，等到目标线程执行完毕，执行该方法的线程会回到**RUNNABLE**状态。3、调用&#96;&#96;&#96;LockSupport.park()&#96;&#96;&#96;方法，当前线程会由**RUNNABLE**转换为**WAITING**状态。调用&#96;&#96;&#96; LockSupport.unpark(Thread thread)&#96;&#96;&#96;可唤醒目标线程，目标线程的状态又会从**WAITING**状态转换到**RUNNABLE**。**通过 &#96;Lock.lock()&#96; 方法等待获取锁时，也会处于 WAITING 状态。****因为 &#96;Lock&#96; 接口的实现基于 AQS 实现的，而 AQS 中的阻塞操作都是基于 &#96;LockSupport&#96; 工具类实现的。**####  RUNNABLE 与 TIMED_WAITING 的状态转换+ 调用带超时参数的 &#96;&#96;&#96;Thread.sleep(long millis)&#96;&#96;&#96;方法；+ 获得 &#96;&#96;&#96;synchronized&#96;&#96;&#96; 隐式锁的线程，调用带超时参数的&#96;&#96;&#96; Object.wait(long timeout)&#96;&#96;&#96;方法；+ 调用带超时参数的&#96;&#96;&#96; Thread.join(long millis)&#96;&#96;&#96; 方法；+ 调用带超时参数的 &#96;&#96;&#96;LockSupport.parkNanos(Object blocker, long deadline)&#96;&#96;&#96; 方法；+ 调用带超时参数的 &#96;&#96;&#96;LockSupport.parkUntil(long deadline)&#96;&#96;&#96; 方法。+ 调用带超时参数的&#96;&#96;&#96;Lock.tryLock(long time, TimeUnit unit)&#96;&#96;&#96;方法。**TIMED_WAITING**和**WAITING**状态的区别，仅仅是触发条件多了超时参数。#### 从 NEW 到 RUNNABLE 状态继承&#96;&#96;&#96;Thread&#96;&#96;&#96;对象或实现&#96;&#96;&#96;Runnable&#96;&#96;&#96;接口，重写&#96;&#96;&#96;run()&#96;&#96;&#96;方法来创建线程。调用start()方法将线程从**NEW**转换到**RUNNABLE**状态。#### 从 RUNNABLE 到 TERMINATED 状态+ 执行完&#96;&#96;&#96;run()&#96;&#96;&#96;方法+ ~~&#96;&#96;&#96;stop()&#96;&#96;&#96;&#x2F;&#96;&#96;&#96;suspend()&#96;&#96;&#96;&#x2F;&#96;&#96;&#96;resume()&#96;&#96;&#96;~~方法+ &#96;&#96;&#96;interrupt()&#96;&#96;&#96;方法&#96;&#96;&#96;interrupt()&#96;&#96;&#96;方法仅通知线程有机会执行一些后续操作，同时也可以无视这个通知。被&#96;&#96;&#96;interrupt()&#96;&#96;&#96;的线程如何受到通知？+ 异常当线程 A 处于**WAITING**、**TIMED_WAITING** 状态，其他线程调用线程 A 的 &#96;&#96;&#96;interrupt()&#96;&#96;&#96; 方法，会使线程 A 返回到**RUNNABLE**状态，同时线程 A 的代码会触发 &#96;&#96;&#96;InterruptedException&#96;&#96;&#96;异常。在 &#96;wait()&#96; 方法中等待的线程被中断时，和使用 &#96;notify()&#96; 唤醒一样，必须要重新获得对象的锁才能从方法中返回，而不是立即就能返回并进入异常处理。&#96;&#96;&#96;wait()&#96;&#96;&#96;、&#96;&#96;&#96;join()&#96;&#96;&#96;、&#96;&#96;&#96;sleep()&#96;&#96;&#96; 类似的方法签名都有&#96;&#96;&#96;throws InterruptedException&#96;&#96;&#96;这个异常。这个异常的触发条件就是：其他线程调用了该线程的 &#96;&#96;&#96;interrupt()&#96;&#96;&#96;方法。note:当线程 A 处于**RUNNABLE**状态时，并且阻塞在 &#96;&#96;&#96;java.nio.channels.InterruptibleChannel&#96;&#96;&#96; 上时，如果其他线程调用线程 A &#96;&#96;&#96; interrupt()&#96;&#96;&#96; 方法，线程 A 会触发 &#96;&#96;&#96;java.nio.channels.ClosedByInterruptException&#96;&#96;&#96; 这个异常；而阻塞在&#96;&#96;&#96;java.nio.channels.Selector&#96;&#96;&#96;上时，如果其他线程调用线程 A 的 &#96;&#96;&#96;interrupt()&#96;&#96;&#96; 方法，线程 A 的 &#96;&#96;&#96;java.nio.channels.Selector&#96;&#96;&#96; 会立即返回。+ 主动检测如果线程处于**RUNNABLE**状态，并且没有阻塞在某个 I&#x2F;O 操作上，例如中断计算圆周率的线程 A，这时需要依赖线程 A 主动检测中断状态。其他线程调用线程 A 的&#96;&#96;&#96;interrupt()&#96;&#96;&#96;方法，线程 A 可通过&#96;&#96;&#96;isInterrupted()&#96;&#96;&#96;方法检测自己是否被中断。### 思考&#96;&#96;&#96;javaThread th &#x3D; Thread.currentThread();while(true) &#123;  if(th.isInterrupted()) &#123;    break;  &#125;  &#x2F;&#x2F; 省略业务代码无数  try &#123;    Thread.sleep(100);  &#125;catch (InterruptedException e)&#123;    e.printStackTrace();  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码的本意是当前线程被中断之后，退出<code>while(true)</code>，这段代码是否正确？</p><p>可能出现无限循环，</p><p>如果在线程在sleep期间被中断，会抛出一个<code>InterruptedException</code>异常，<strong>在触发<code>InterruptedException</code>异常的同时，JVM 会同时把线程的中断标志位清除。</strong></p><p>应该重置一下中断标示。</p><blockquote><p>InterruptedException - if any thread has interrupted the current thread.</p><p><strong>The interrupted status of the current thread is cleared when this exception is thrown.</strong></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span> th <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>th<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 省略业务代码无数</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span>｛    <span class="token comment">//重置中断标识  </span>    th<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>在 Java 的文档中对 <code>interrupt()</code> 的效果列了四种情形：</p><blockquote><p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p><p>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException.</p><p>If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.</p><p>If none of the previous conditions hold then this thread’s interrupt status will be set.</p></blockquote><p><strong>前三种情形其实是描述了如果线程处于等待状态或是阻塞在某一种资源上，那么 <code>interrupt()</code> 方法会使得线程跳出这种状态继续执行下去。第四种情形则描述了如果线程正在正常执行，那么 <code>interrupt()</code> 的效果则是设置了线程的中断状态，至于怎么处理这种状态，可以选择忽略也可以按需处理。</strong></p><p><code>yield()</code> 方法是 <code>Thread</code> 类的静态方法，也用于出让当前线程占用的CPU资源。和 <code>sleep(long)</code> 方法不同的是， <code>sleep(long)</code>会使得线程进入 <code>WAITING</code> 状态并且至少会等待超时时间到达后才会再次执行；而 <code>yield()</code> 方法则是从 <code>RUNNING</code> 进入 <code>READY</code> 状态（这里指的是操作系统层面，在 JVM 暴露出来的都是 <code>RUNNABLE</code> 状态），因而极有可能马上又被调度选中继续运行。</p><blockquote><p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.</p></blockquote><p>从文档中的表述来看，<code>yield()</code> 方法相比于 <code>sleep(long)</code> 方法更依赖与系统的调度。该方法并不经常用到。</p><p>——<strong>jrwang</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发8:管程</title>
      <link href="2020/04/06/java-bing-fa-8-guan-cheng/"/>
      <url>2020/04/06/java-bing-fa-8-guan-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发8-管程"><a href="#Java并发8-管程" class="headerlink" title="Java并发8:管程"></a>Java并发8:管程</h3><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><strong>Java采用的是管程技术，<code>synchronized</code>关键字及<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>都是管程的组成部分。</strong></p><p><strong>管程和信号量是等价的，即用管程能够实现信号量，也能用信号量实现管程。</strong></p><p>但是管程更容易使用，所以 Java 选择了管程。</p><p><strong>管程（Monitor），很多将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这是意译。</strong></p><p><strong>管程，即管理共享变量以及对共享变量的操作过程，让它们支持并发。</strong></p><p>翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。</p><h3 id="管程模型"><a href="#管程模型" class="headerlink" title="管程模型"></a>管程模型</h3><p>Hasen模型/Hoare模型/MESA模型，Java参考的是MESA模型。</p><p>重申一遍并发核心问：分工（合理分配线程执行任务），互斥（同一时刻只有一个线程访问资源），同步（线程通信，协作）。</p><h4 id="管程解决互斥"><a href="#管程解决互斥" class="headerlink" title="管程解决互斥"></a>管程解决互斥</h4><p>将共享变量及其对共享变量的操作统一封装。</p><p>管程 X 将共享变量 queue 队列和相关操作入队 enq()、出队 deq() 都进行封装；</p><p>线程 A 和线程 B 如果想访问共享变量 queue，只能通过调用管程提供的 enq()、deq() 方法来实现；</p><p>enq()、deq() 保证互斥性，只允许一个线程进入管程。</p><p>管程模型和面向对象高度契合。互斥锁用法，模型就是管程。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8C%96%E8%AF%AD%E4%B9%89.png" alt="管程模型的代码化语义"></p><h4 id="管程解决同步"><a href="#管程解决同步" class="headerlink" title="管程解决同步"></a>管程解决同步</h4><p>共享变量和对共享变量的操作被封装。</p><p>每个条件变量对应一个等待队列，不满足条件进入对应条件变量等待队列(<code>wait()</code>)，满足被唤醒进入入口等待队列(<code>notify()</code>&amp;<code>notifyAll()</code>)。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/MESA%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="MESA管程模型"></p><p>代码说明：</p><p>对于入队操作，如果队列已满，就需要等待直到队列不满，所以这里用了<code>notFull.await();</code>。</p><p>对于出队操作，如果队列为空，就需要等待直到队列不空，所以就用了<code>notEmpty.await();</code>。</p><p>如果入队成功，那么队列就不空了，就需要通知条件变量：队列不空<code>notEmpty</code>对应的等待队列。</p><p>如果出队成功，那就队列就不满了，就需要通知条件变量：队列不满<code>notFull</code>对应的等待队列。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockedQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span>    <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 条件变量：队列不满  </span>  <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull <span class="token operator">=</span>    lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 条件变量：队列不空  </span>  <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span>    lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 入队</span>  <span class="token keyword">void</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token class-name">T</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>队列已满<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 等待队列不满 </span>        notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>        <span class="token comment">// 省略入队操作...</span>      <span class="token comment">//入队后,通知可出队</span>      notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 出队</span>  <span class="token keyword">void</span> <span class="token function">deq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>队列已空<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 等待队列不空</span>        notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 省略出队操作...</span>      <span class="token comment">//出队后，通知可入队</span>      notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Java内置管程方案"><a href="#Java内置管程方案" class="headerlink" title="Java内置管程方案"></a>Java内置管程方案</h4><p><strong>MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。</strong></p><p>Java 内置的管程方案（<code>synchronized</code>）使用简单，<code>synchronized</code> 关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量；而 Java SDK 并发包实现的管程支持多个条件变量，不过并发包里的锁，需要开发人员自己进行加锁和解锁操作。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/Java%E4%B8%AD%E7%AE%A1%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Java中管程示意图"></p><h3 id="wait-范式"><a href="#wait-范式" class="headerlink" title="wait()范式"></a>wait()范式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>条件不满足<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要在<code>while</code>中调用<code>wait()</code>，MESA管程特有。</p><p><strong>Hasen</strong>模型、<strong>Hoare</strong>模型和<strong>MESA</strong>模型的一个核心区别就是当条件满足后，如何通知相关线程。</p><p><strong>Hasen</strong>模型：<code>notify()</code>放在代码最后，这样 T2 通知完 T1 后，T2 结束；T1 再执行，这样保证同一时刻只有一个线程执行。</p><p><strong>Hoare</strong>模型：T2 通知完 T1 后，T2 阻塞，T1 马上执行；等T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。相比<strong>Hasen</strong>模型，T2 多了一次阻塞唤醒操作。</p><p><strong>MESA</strong>模型：T2 通知完 T1 后，T2 接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是<code>notify()</code>不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。</p><p><strong>但有副作用:当 T1 再次执行的时候，可能曾经满足条件，现在不满足，所以需要以循环方式检验条件变量。</strong></p><h3 id="notify-何时使用"><a href="#notify-何时使用" class="headerlink" title="notify()何时使用"></a>notify()何时使用</h3><ul><li>所有等待线程拥有相同的等待条件；</li><li>所有等待线程被唤醒后，执行相同的操作；</li><li>只需要唤醒一个线程。</li></ul><p>尽量使用<code>notifyAll()</code>。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><code>wait()</code> 方法，在 <strong>Hasen</strong> 模型和 <strong>Hoare</strong> 模型里面，都是没有参数的，而在 <strong>MESA</strong> 模型里面，增加了超时参数，参数是否有必要吗？</p><p><strong>Hasen</strong> 模型和 <strong>Hoare</strong> 模型都保证一定唤醒线程。</p><p><strong>MESA</strong> 模型因为采用了<code>while</code>循环，如果不加超时参数，仅使用<code>notify()</code>唤醒，那么<code>wait()</code>处的线程可能一直不被唤醒，<code>wait()</code>超时后，会到等待队列里抢锁。</p><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>管程的组成锁和0或者多个条件变量，java用两种方式实现了管程①synchronized+wait、notify、notifyAll②lock+内部的condition，第一种只支持一个条件变量，即wait，调用wait时会将其加到等待队列中，被notify时，会随机通知一个线程加到获取锁的等待队列中，第二种相对第一种condition支持中断和增加了时间的等待，lock需要自己进行加锁解锁，更加灵活，两个都是可重入锁，但是lock支持公平和非公平锁，synchronized支持非公平锁。</p><p>——<strong>linqw</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发7:安全性&amp;活跃性&amp;性能问题</title>
      <link href="2020/04/06/java-bing-fa-7-an-quan-xing-huo-yue-xing-he-xing-neng-wen-ti/"/>
      <url>2020/04/06/java-bing-fa-7-an-quan-xing-huo-yue-xing-he-xing-neng-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发7-安全性-amp-活跃性-amp-性能问题"><a href="#Java并发7-安全性-amp-活跃性-amp-性能问题" class="headerlink" title="Java并发7:安全性&amp;活跃性&amp;性能问题"></a>Java并发7:安全性&amp;活跃性&amp;性能问题</h3><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题。</p><p>要对<strong>存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据</strong>这种情况下的代码进行线程安全分析。</p><p>如果能不共享数据或者数据状态不发生变化，也是可以保证线程安全。</p><p>例如线程本地存储（Thread Local Storage，TLS）、不变模式等。</p><p><strong>数据竞争（Data Race）:多个线程同时访问同一数据，且至少有一个线程会写此数据时，如不采取防护措施，就会导致并发 Bug。</strong></p><p>如下面这种情况，多个线程调用<code>add10K()</code>方法，导致对<code>count</code>存在<strong>数据竞争</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>竞态条件（Race Condition）：程序的执行结果依赖线程执行的顺序。</strong></p><p>并发场景中，程序执行依赖于某个状态变量：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>状态变量 满足 执行条件<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  执行操作<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>当某个线程发现状态变量满足执行条件，开始执行操作；</strong></p><p><strong>但此时这个线程执行操作时，其他线程同时修改了状态变量，导致状态变量不满足执行条件。</strong></p><p><strong>很多场景下，这个条件不是显式的。</strong></p><p>显式理解：</p><p>A&amp;B两线程同时调用transfer()方法：A执行第5行发现余额大于转账金额，可以执行第6行；同时B也执行第5行发现余额大于转账金额，可以执行第6行；但此时余额可能因A&amp;B的操作导致为负。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>  <span class="token comment">// 转账</span>  <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//第6行共享读了数据blance，没有写  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">></span> amt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>      target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>隐式理解：</p><p>虽然<code>get()</code>&amp;<code>set()</code>都加了锁，但多个线程执行第12行时，<code>get()</code>会取到相同的<code>count=0</code>，导致<code>get()+1</code>均为1，导致<code>set(get()+1)</code>均为1。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">long</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    count <span class="token operator">=</span> v<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>   <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//set(get()+1) 这个复合操作，隐式依赖 get() 的结果</span>      <span class="token comment">//先计算完get()+1这个参数，才会去执行set()的方法体</span>      <span class="token function">set</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h3><p>死锁/活锁/饥饿都是常见的活跃性问题，即操作无法执行下去。</p><p>解决死锁，见<strong>Java并发5-死锁</strong>；</p><p>解决活锁，随机等待一个时间，未获取到目标资源再释放当前持有资源；</p><p>解决饥饿：保证资源充足/公平分配资源/避免持有锁的线程长时间执行。</p><p>一般采用公平分配资源，公平锁：排在等待队列前的线程会优先获得资源。</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>锁使用过度，可能导致大量操作变为串行，产生性能问题。</p><p><strong>阿姆达尔（Amdahl）定律：处理器并行运算之后效率提升的能力。</strong><br>$$<br>S=\frac{1}{(1-p)+\frac{p}{n}}<br>$$<br>n:CPU核数</p><p>p:并行百分比</p><p>1-p:串行百分比</p><p>S:性能加速比</p><p><strong>假设串行百分比为5%，那么n即使无穷大，也只能提升20倍性能，所以关键在于如何减少串行百分比。</strong></p><h5 id="如何避免锁带来的性能问题"><a href="#如何避免锁带来的性能问题" class="headerlink" title="如何避免锁带来的性能问题"></a>如何避免锁带来的性能问题</h5><p>1、使用无锁的算法和数据结构。</p><p>例如线程本地存储 （Thread Local Storage, TLS）、写入时复制 （Copy-on-write）、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好等等。</p><p>2、减少锁持有的时间。</p><p><strong>互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。</strong></p><p>例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。</p><h5 id="性能度量指标"><a href="#性能度量指标" class="headerlink" title="性能度量指标"></a>性能度量指标</h5><ul><li><p>吞吐量：单位时间内能处理的请求数量。吞吐量越高性能越好。</p></li><li><p>延迟：从发出请求到收到响应的时间。延迟越小性能越好。</p></li><li><p>并发量：能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。</p><p>  一因此延迟一般是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。</p></li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>代码是否存在并发问题？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addIfNotExist</span><span class="token punctuation">(</span><span class="token class-name">Vector</span> v<span class="token punctuation">,</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    v<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会产生竞态条件问题，多个线程同时执行到第2行，都发现<code>v</code>中无<code>o</code>，都回去执行第3行，造成并发BUG。</p><p>将变量封装在内部，提供线程安全的方法去访问。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SafeVector</span><span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">Vector</span> v<span class="token punctuation">;</span>   <span class="token comment">// 所有公共方法增加同步控制</span>  <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addIfNotExist</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      v<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比。</p><p>——<strong>作者</strong></p></blockquote><blockquote><p><code>Vector</code>实现线程安全是通过给主要的写方法加了<code>synchronized</code>，类似<code>contains()</code>这样的读方法并没有<code>synchronized</code>，该题的问题就出在不是线程安全的<code>contains()</code>方法，两个线程如果同时执行到<code>if(!v.contains(o))</code>是可以都通过的，这时就会执行两次<code>add()</code>方法，重复添加。也就是竞态条件。</p><p>——<strong>飘呀飘的小叶子</strong></p></blockquote><blockquote><p>编写并发程序的初衷是为了提升性能，但在追求性能的同时由于多线程操作共享资源而出现了安全性问题，所以才用到了锁技术，一旦用到了锁技术就会出现了死锁，活锁等活跃性问题，而且不恰当地使用锁，导致了串行百分比的增加，由此又产生了性能问题，所以这就是并发程序与锁的因果关系。</p><p>——<strong>Nevermore</strong></p></blockquote><blockquote><p>服务器上存了2000万个电话号码相关的数据，要做的是把这批号码从服务器上请求下来写入到本地的文件中，为了将数据打散到多个文件中，这里通过 电话号码%1024 得到的余数来确定这个号码需要存入到哪个文件中取，比如13888888888 % 1024 =56，那么这个号码会被存入到 56.txt的文件中，写入时是一行一个号码。<br>为了效率这里使用了多线程来请求数据并将请求下来的数据写入到文件，也就是每个线程包含向服务器请求数据，然后在将数据写入到电话号码对1024取余的那个文件中去，如果这么做目前会有一个隐患，多线程时如果 电话号码%1024 后定位的是同一个文件，那么就会出现多线程同时写这个文件的操作，一定程度上会造成最终结果错误。</p><p>——<strong>0928</strong></p><blockquote><p>写一个文件只需要一个线程就够了。<br>你可以用生产者-消费者模式试一下。<br>可以创建64个线程，每个线程负责16个文件，<br>同时创建64个阻塞队列，64个线程消费这<del>76</del> 64个阻塞队列，<br>电话号码%1024 % 64 进入目标阻塞队列。</p><p>其余的就是优化一下写文件的效率了</p><p>note:余64固然可以确定队列，但如何确定目标文件。</p><p>——<strong>作者</strong></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发6:等待通知机制</title>
      <link href="2020/04/06/java-bing-fa-6-deng-dai-tong-zhi-ji-zhi/"/>
      <url>2020/04/06/java-bing-fa-6-deng-dai-tong-zhi-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发6-等待通知机制"><a href="#Java并发6-等待通知机制" class="headerlink" title="Java并发6:等待通知机制"></a>Java并发6:等待通知机制</h3><h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待-通知机制"></a>等待-通知机制</h3><p>上篇文章通过<code>while(!actr.apply(this, target));</code>来破坏占用且等待条件。</p><p>若<code>apply()</code>操作耗时非常短，且并发冲突量也不大，那这个方案还可行，可能循环上几次或者几十次就能一次性获取转出账户和转入账户。</p><p>但若<code> apply()</code> 操作耗时长，或者并发冲突量大的时候，就不适用了，可能要循环上万次才能获取到锁，代码不断执行太消耗 CPU 。</p><p>最好的方案应该是：</p><p>如果线程要求的条件（转出账本和转入账本同在文件架上）不满足，则线程阻塞自己，进入等待状态；</p><p>当线程要求的条件（转出账本和转入账本同在文件架上）满足后，通知等待的线程重新执行。</p><p><strong>使用线程阻塞的方式就能避免循环等待消耗 CPU 的问题。</strong></p><p><strong>一个完整的等待 - 通知机制：</strong></p><p><strong>线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；</strong></p><p><strong>当要求的条件满足时，通知等待的线程，重新获取互斥锁。</strong></p><h3 id="synchronized实现等待-通知机制"><a href="#synchronized实现等待-通知机制" class="headerlink" title="synchronized实现等待-通知机制"></a>synchronized实现等待-通知机制</h3><pre class="line-numbers language-synchronized" data-language="synchronized"><div class="caption"><span>```配合``` wait()```、```notify()```、```notifyAll() ```实现。</span></div><code class="language-synchronized">同一时刻，只允许一个线程进入&#96;&#96;&#96; synchronized&#96;&#96;&#96; 保护的临界区，当有一个线程进入临界区后，其他线程就只能进入图中左边的等待队列里等待。**等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。**![wait()操作工作原理](https:&#x2F;&#x2F;images-1252818907.cos.ap-chengdu.myqcloud.com&#x2F;images&#x2F;wait()操作工作原理.png)调用&#96;&#96; wait() &#96;&#96;方法，当前线程被阻塞，进入到右边的等待队列，这个等待队列也是互斥锁的等待队列。线程在进入等待队列的同时，会释放持有的互斥锁，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。线程要求的条件满足时，通过Java 对象的&#96;&#96;&#96; notify() &#96;&#96;&#96;和 &#96;&#96;&#96;notifyAll() &#96;&#96;&#96;方法唤醒阻塞的线程。当条件满足时调用&#96;&#96;&#96; notify()&#96;&#96;&#96;，会通知等待队列（互斥锁的等待队列）中的线程，告诉它条件曾经满足过。**notify() 只能保证在通知时间点，条件是满足的。**而被通知线程的执行时间点和通知的时间点基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。![notify()操作工作原理图](https:&#x2F;&#x2F;images-1252818907.cos.ap-chengdu.myqcloud.com&#x2F;images&#x2F;notify()操作工作原理图.png)**&#96;&#96;&#96;wait()&#96;&#96;&#96;、&#96;&#96;&#96;notify()&#96;&#96;&#96;、&#96;&#96;&#96;notifyAll() &#96;&#96;&#96;方法操作的等待队列是互斥锁的等待队列。**所以如果&#96;&#96;&#96; synchronized&#96;&#96;&#96; 锁定的是&#96;&#96;&#96; this&#96;&#96;&#96;，那么对应的一定是&#96;&#96;&#96; this.wait()&#96;&#96;&#96;、&#96;&#96;&#96;this.notify()&#96;&#96;&#96;、&#96;&#96;&#96;this.notifyAll()&#96;&#96;&#96;；如果 &#96;&#96;&#96;synchronized &#96;&#96;&#96;锁定的是&#96;&#96;&#96; target&#96;&#96;&#96;，那么对应的一定是 &#96;&#96;&#96;target.wait()&#96;&#96;&#96;、&#96;&#96;&#96;target.notify()&#96;&#96;&#96;、&#96;&#96;&#96;target.notifyAll() &#96;&#96;&#96;。**&#96;&#96;&#96;wait()&#96;&#96;&#96;、&#96;&#96;&#96;notify()&#96;&#96;&#96;、&#96;&#96;&#96;notifyAll() &#96;&#96;&#96;这三个方法能够被调用的前提是已经获取了相应的互斥锁，即 wait()、notify()、notifyAll() 都是在 synchronized&#123;&#125;内部被调用的。**如果在&#96;&#96;&#96; synchronized&#123;&#125;&#96;&#96;&#96;外部调用，或者锁定的&#96;&#96;&#96; this&#96;&#96;&#96;，而用&#96;&#96;&#96; target.wait()&#96;&#96;&#96; 调用的话，JVM 会抛出一个运行时异常：&#96;&#96;&#96;java.lang.IllegalMonitorStateException&#96;&#96;&#96;。### 利用等待-通知实现转账+ 等待-通知机制条件判断范式这种范式可以解决上面提到的条件曾经满足过这个问题。因为当&#96;&#96;&#96; wait()&#96;&#96;&#96; 返回时，有可能条件已经发生变化了，曾经条件满足，但是现在已经不满足了，所以要重新检验条件是否满足。范式，意味着是经典做法，所以没有特殊理由不要尝试换个写法。&#96;&#96;&#96;java while(条件不满足) &#123;    wait();  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>代码</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> als<span class="token punctuation">;</span>  <span class="token comment">// 一次性申请所有资源</span>  <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Object</span> from<span class="token punctuation">,</span> <span class="token class-name">Object</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 经典写法</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>als<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">||</span> als<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        <span class="token comment">//集合不为空，说明有其他Account线程已经申请了资源，当前申请资源的Account线程就wait()释放</span>        <span class="token comment">//实例allocator锁</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>     als<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>    als<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token comment">// 归还资源</span>  <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span>    <span class="token class-name">Object</span> from<span class="token punctuation">,</span> <span class="token class-name">Object</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    als<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>    als<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>notify()</code> 是会随机地通知等待队列中的一个线程，而 <code>notifyAll() </code>会通知等待队列中的所有线程，尽量使用<code>notifyAll()</code>避免线程被饿死。</strong></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><pre class="line-numbers language-wait()" data-language="wait()"><div class="caption"><span>```方法和``` sleep() ```方法都能让当前线程挂起一段时间，区别是什么？</span></div><code class="language-wait()">+ &#96;&#96;&#96;wait()&#96;&#96;&#96;方法会释放对象的“锁标志”调用对象的&#96;&#96;&#96;wait()&#96;&#96;&#96;方法后，当前线程暂停执行，释放锁标志，并将当前线程放入**对象等待池**中。调用&#96;&#96;&#96;notify()&#96;&#96;&#96;方法后，将从**对象等待池**中移出任意一个线程并放入**锁标志等待池**中，**只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。**调用&#96;&#96;&#96;notifyAll()&#96;&#96;&#96;方法后，**会将对象等待池中的所有线程都移动到该对象的锁标志等待池**。+ &#96;&#96;&#96;sleep()&#96;&#96;&#96;方法**必须**要指定等待的时间可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是&#96;&#96;&#96;sleep()&#96;&#96;&#96;方法不会释放“锁标志”，如果有&#96;&#96;&#96;synchronized&#96;&#96;&#96;同步块，其他线程仍然不能访问共享数据。+ &#96;&#96;&#96;wait()&#96;&#96;&#96;是&#96;&#96;&#96;Object&#96;&#96;&#96;的对象方法，&#96;&#96;&#96;sleep()&#96;&#96;&#96;是&#96;&#96;&#96;Thread&#96;&#96;&#96;的类方法。+ &#96;&#96;&#96;wait()&#96;&#96;&#96;需要被唤醒，&#96;&#96;&#96;wait(1000L)&#96;&#96;&#96;不需要，&#96;&#96;&#96;sleep()&#96;&#96;&#96;不需要。+ &#96;&#96;&#96;wait()&#96;&#96;&#96;需要获取到监视器，即只能在同步方法和同步快中使用，否则抛异常，&#96;&#96;&#96;sleep()&#96;&#96;&#96;不需要。### 别人的总结&gt;&#96;&#96;&#96;java&gt;public class MyLock &#123;&gt;    &#x2F;&#x2F; 测试转账的main方法&gt;    public static void main(String[] args) throws InterruptedException &#123;&gt;        Account src &#x3D; new Account(10000);&gt;        Account target &#x3D; new Account(10000);&gt;        CountDownLatch countDownLatch &#x3D; new CountDownLatch(9999);&gt;        for (int i &#x3D; 0; i &lt; 9999; i++) &#123;&gt;            new Thread(() -&gt; &#123;&gt;                src.transactionToTarget(1, target);&gt;                 &#x2F;&#x2F;放在finally里面？更安全？&gt;                countDownLatch.countDown();&gt;            &#125;).start();&gt;        &#125;&gt;        countDownLatch.await();&gt;        System.out.println(&quot;src&#x3D;&quot;+src.getBanalce() );&gt;        System.out.println(&quot;target&#x3D;&quot; + target.getBanalce());&gt;    &#125;&gt;&gt;    static class Account &#123; &#x2F;&#x2F;账户类&gt;        public Account(Integer banalce) &#123;&gt;            this.banalce &#x3D; banalce;&gt;        &#125;&gt;&gt;        private Integer banalce;&gt;&gt;        public void transactionToTarget(Integer money, Account target) &#123;&#x2F;&#x2F;转账方法&gt;            Allocator.getInstance().apply(this, target);&gt;            this.banalce -&#x3D; money;&gt;            target.setBanalce(target.getBanalce() + money);&gt;            &#x2F;&#x2F;放在finally里面？更安全？&gt;            Allocator.getInstance().release(this, target);&gt;        &#125;&gt;&gt;        public Integer getBanalce() &#123;&gt;            return banalce;&gt;        &#125;&gt;&gt;        public void setBanalce(Integer banalce) &#123;&gt;            this.banalce &#x3D; banalce;&gt;        &#125;&gt;    &#125;&gt;&gt;    static class Allocator &#123; &#x2F;&#x2F;单例锁类&gt;        private Allocator() &#123;&gt;        &#125;&gt;&#x2F;&#x2F;优化 list换成set更快&gt;        private List&lt;Account&gt; locks &#x3D; new ArrayList&lt;&gt;();&gt;&gt;        public synchronized void apply(Account src, Account tag) &#123;&gt;            while (locks.contains(src) || locks.contains(tag)) &#123;&gt;                try &#123;&gt;                    this.wait();&gt;                &#125; catch (InterruptedException e) &#123;&gt;                &#125;&gt;            &#125;&gt;            locks.add(src);&gt;            locks.add(tag);&gt;        &#125;&gt;&gt;        public synchronized void release(Account src, Account tag) &#123;&gt;            locks.remove(src);&gt;            locks.remove(tag);&gt;            this.notifyAll();&gt;        &#125;&gt;&gt;        public static Allocator getInstance() &#123;&gt;            return AllocatorSingle.install;&gt;        &#125;&gt;&gt;        static class AllocatorSingle &#123;&gt;            public static Allocator install &#x3D; new Allocator();&gt;        &#125;&gt;    &#125;&gt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>——<strong>wang</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发5:死锁</title>
      <link href="2020/04/06/java-bing-fa-5-si-suo/"/>
      <url>2020/04/06/java-bing-fa-5-si-suo/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发5-死锁"><a href="#Java并发5-死锁" class="headerlink" title="Java并发5:死锁"></a>Java并发5:死锁</h3><p>上篇文章中转账加锁使用了<code>Account.class</code>，实际开发中肯定不可行。性能上无法接受，需采用更细粒度的锁。</p><h3 id="采用细粒度锁带来问题"><a href="#采用细粒度锁带来问题" class="headerlink" title="采用细粒度锁带来问题"></a>采用细粒度锁带来问题</h3><h4 id="采用细粒度锁优化性能"><a href="#采用细粒度锁优化性能" class="headerlink" title="采用细粒度锁优化性能"></a>采用细粒度锁优化性能</h4><p>即在<code>transfer()</code>方法内部，先尝试锁定转出账户 <code>this</code>（先把转出账本拿到），然后尝试锁定转入账户<code> target</code>（再把转入账本拿到手），只有当两者都成功时，才执行转账操作。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E4%B8%A4%E4%B8%AA%E8%BD%AC%E8%B4%A6%E6%93%8D%E4%BD%9C%E5%B9%B6%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="两个转账操作并行示意图"></p><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>  <span class="token comment">// 转账</span>  <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 锁定转出账户</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 锁定转入账户</span>      <span class="token keyword">synchronized</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">></span> amt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>          target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="产生死锁"><a href="#产生死锁" class="headerlink" title="产生死锁"></a>产生死锁</h4><p><strong>死锁：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。</strong></p><p>上面代码会产生死锁，A向B转账，B向A转账时。</p><ul><li>A进入第6行锁定了对象A，B进入第6行锁定了对象B。</li><li>A进入第8行尝试获取对象B，B进入第8行尝试获取对象A。</li><li>此时A和B都占有了对方想要获取的资源，产生了阻塞。</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。</strong></p><h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><ul><li>互斥，共享资源X和Y只能被一个线程占用。</li><li>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li><li>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li><li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li></ul><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>破坏上述任意条件。</p><ul><li><p>互斥这个条件没有办法破坏，因为用锁为的就是互斥。</p></li><li><p>对于“占用且等待”，可以一次性申请所有的资源，这样就不存在等待了。</p></li><li><p>对于“不可抢占”，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>  note:可能出现活锁问题，要等待随机时间。</p></li><li><p>对于“循环等待”，可以按序申请资源。按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</p></li></ul><h4 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h4><ul><li><p>破坏占有且等待条件</p><p>  一次性申请所有资源，通过类<code>Allocator</code>一次性申请，申请到了返回<code>true</code>。</p><p>  线程执行<code>transfer()</code>方法时循环判断直到申请到了所有必须的资源，再进行转账。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> als <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 一次性申请所有资源，多个线程同时申请，加锁保证apply()方法对外部表现原子性</span>  <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Object</span> from<span class="token punctuation">,</span> <span class="token class-name">Object</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//如果als集合中有任意一个资源，说明Allocator已经完成了所有资源的申请  </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>als<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">||</span> als<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//als集合一个资源都没有，进行添加。 </span>      als<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>      als<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token comment">//申请资源完毕，返回true</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 归还资源</span>  <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span>    <span class="token class-name">Object</span> from<span class="token punctuation">,</span> <span class="token class-name">Object</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    als<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>    als<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// actr应该为单例</span>  <span class="token keyword">private</span> <span class="token class-name">Allocator</span> actr<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>  <span class="token comment">// 转账</span>  <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 一次性申请转出账户和转入账户，直到成功</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>actr<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 锁定转出账户</span>      <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                      <span class="token comment">// 锁定转入账户</span>        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">></span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>            target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>      actr<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>破坏不可抢占条件</p><p>  <code>synchronized </code>是做不到的。原因是<code> synchronized</code> 申请资源的时候，如果申请不到，线程直接进入阻塞状态，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。</p><p>  <code>java.util.concurrent</code> 这个包下面提供的<code> Lock</code> 可以解决，见XXX。</p></li><li><p>破坏循环等待条件</p><p>  破坏这个条件，需要对资源进行排序，然后按序申请资源。</p><p>  假设每个账户都有不同的属性<code> id</code>，这个<code>id</code>可以作为排序字段，申请的时候，可以按从小到大的顺序来申请。比如下面代码，①~⑥处的代码对转出账户（<code>this</code>）和转入账户（<code>target</code>）排序，然后按照序号从小到大的顺序锁定账户。这样就不存在“循环”等待了。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>  <span class="token comment">// 转账</span>  <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Account</span> left <span class="token operator">=</span> <span class="token keyword">this</span>        ①    <span class="token class-name">Account</span> right <span class="token operator">=</span> target<span class="token punctuation">;</span>    ②    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">></span> target<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> ③      left <span class="token operator">=</span> target<span class="token punctuation">;</span>           ④      right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            ⑤    <span class="token punctuation">&#125;</span>                          ⑥    <span class="token comment">// 锁定序号小的账户</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 锁定序号大的账户</span>      <span class="token keyword">synchronized</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">></span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>          target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用<strong>细粒度锁</strong>来锁定多个资源时，要注意<strong>死锁</strong>的问题。</p><p>需要能把它强化为一个思维定势，遇到这种场景，马上想到可能存在死锁问题。</p><p>当知道风险之后，才有机会谈如何预防和避免，因此，识别出风险很重要。</p><p><strong>转账例子中，破坏占用且等待条件的成本就比破坏循环等待条件的成本高。</strong></p><p><strong>破坏占用且等待条件，也是锁了所有的账户，而且还是用了死循环while(!actr.apply(this, target));方法，不过好在 apply() 这个方法基本不耗时。</strong></p><p><strong>转账例子中，破坏循环等待条件就是成本最低的一个方案。</strong></p><p>所以在选择具体方案的时候，还需要评估一下操作成本，从中选择一个成本最低的方案。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><code>while(!actr.apply(this, target));</code>与<code>synchronized(Account.class) </code>有无性能优势呢？</p><p>前者只锁了转账操作，后者锁了账户所有操作。</p><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>老师，请问一下，在实际的开发中，account对象应该是从数据库中查询出来的吧，假如A转B，C转B一起执行，那B的account对象如何保证是同一个对象，不太理解。。。</p><p>——<strong>几字凉了秋丶</strong></p><blockquote><p>实际开发中都是用数据库事务+乐观锁的方式解决的。这个就是个例子，为了说明死锁是怎么回事，以及死锁问题怎么解决。</p><p>——<strong>作者</strong></p></blockquote></blockquote><blockquote><p>老师，感觉下面的代码也能避免死锁，并且能实现功能：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">boolean</span> isTransfer <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token comment">// 锁定转出账户</span> <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">></span> amt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>    isTransfer <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isTransfer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 锁定转入账户</span>  <span class="token keyword">synchronized</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反映到现实中的场景：服务员A拿到账本1先判断余额够不够，够的话先扣款，再等待其他人操作完账本2，才增加它的额度。</p><p>但是这样转账和到账就存在一个时差，现实生活中也是这样，转账不会立马到账，短信提醒24小时内到账，所谓的最终一致性。</p><p>老师帮忙看看这样实现会不会有啥其他问题？</p><p>——<strong>Bright丶</strong></p><blockquote><p>实际中也有这么做的，只不过是把转入操作放到mq里，mq消费失败会重试，所以能保证最终一致性。</p><p>——<strong>作者</strong></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发4:互斥锁(下)</title>
      <link href="2020/04/06/java-bing-fa-4-hu-chi-suo-xia/"/>
      <url>2020/04/06/java-bing-fa-4-hu-chi-suo-xia/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发4-互斥锁-下"><a href="#Java并发4-互斥锁-下" class="headerlink" title="Java并发4:互斥锁(下)"></a>Java并发4:互斥锁(下)</h3><p><strong>受保护资源和锁之间合理的关联关系应该是 N:1 的关系</strong>，即可以用一把锁来保护多个资源，但不能多把锁保护一个资源。</p><p>要保护多个资源，首先要区分这些资源是否存在关联关系。</p><h3 id="保护没有关联关系的多个资源"><a href="#保护没有关联关系的多个资源" class="headerlink" title="保护没有关联关系的多个资源"></a>保护没有关联关系的多个资源</h3><p>有一用户账户类Account。</p><p>对于用户账户，有账号，密码，余额等属性。</p><p>密码和余额是没有关联关系的，这样就可以建两把锁，来保护密码和余额。不同的资源用不同的锁来保护。</p><p>当然也可以用一把锁来保护，比如直接用用户对象this保护.</p><p>但这样问题就是性能太差，对密码和余额操作都需要共享一把锁。</p><p><strong>所以还是对不同的资源采取不同的锁进行精细化管理，能够提升性能，即细粒度锁。</strong></p><h3 id="保护有关联关系的多个资源"><a href="#保护有关联关系的多个资源" class="headerlink" title="保护有关联关系的多个资源"></a>保护有关联关系的多个资源</h3><p>比如A账户向B账户转账，这样要同时锁定A&amp;B两个资源。</p><p><strong>保证锁能覆盖所有的保护资源。</strong></p><ul><li>传入同一个锁进行转账</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">Object</span> lock；  <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建Account时传入同一个lock对象</span>  <span class="token keyword">public</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token class-name">Object</span> lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>lock <span class="token operator">=</span> lock<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>   <span class="token comment">// 转账</span>  <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 此处检查所有对象共享的锁</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">></span> amt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>        target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个办法要求在创建 <code>Account </code>对象的时候必须传入同一个对象，如果创建<code> Account</code> 对象时，传入的<code> lock</code> 不是同一个对象，就会出现问题。</p><p>在真实的项目场景中，创建<code> Account</code> 对象的代码很可能分散在多个工程中，传入共享的<code> lock</code>实际上很难。</p><ul><li>用Account.class作为共享锁</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> balance<span class="token punctuation">;</span>  <span class="token comment">// 转账</span>  <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Account</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Account</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">></span> amt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>balance <span class="token operator">-=</span> amt<span class="token punctuation">;</span>        target<span class="token punctuation">.</span>balance <span class="token operator">+=</span> amt<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此举会出现性能问题，因为所有用户的<code>Account</code>中的所有操作都会用同一个锁。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>用两把不同的锁来分别保护账户余额、账户密码，创建锁的时候：</p><pre class="line-numbers language-private" data-language="private"><div class="caption"><span>final Object xxxLock </span></div><code class="language-private">如果账户余额用&#96;&#96;&#96; this.balance&#96;&#96;&#96; 作为互斥锁，账户密码用&#96;&#96;&#96; this.password &#96;&#96;&#96;作为互斥锁，是否可以？不可以。不能用可变对象做锁。&#96;&#96;&#96;balance&#96;&#96;&#96;是&#96;&#96;&#96;Integer&#96;&#96;&#96;，&#96;&#96;&#96;password&#96;&#96;&#96;是&#96;&#96;&#96;String&#96;&#96;&#96;，都是不可变对象，一但对他们进行赋值就会变成新的对象，加的锁就失效了。核心问题有两点：+ 一个是锁有可能会变化：如果锁发生变化，就意味着失去了互斥功能。+ 一个是 &#96;&#96;&#96;Integer&#96;&#96;&#96; 和 &#96;&#96;&#96;String&#96;&#96;&#96; 类型的对象不适合做锁：&#96;&#96;&#96;Boolean&#96;&#96;&#96;、 &#96;&#96;&#96;Integer&#96;&#96;&#96; 和 &#96;&#96;&#96;String&#96;&#96;&#96; 类型的对象在 JVM 里可能被重用。重用意味着锁可能被其他代码使用，如果其他代码 &#96;&#96;&#96;synchronized(锁)&#96;&#96;&#96;，且不释放，那程序就永远拿不到锁，这是隐藏的风险。**锁应是私有的、不可变的、不可重用的。**### 别人的总结&gt;是否可以在&#96;&#96;&#96;Account&#96;&#96;&#96;中添加一个静态&#96;&#96;&#96;object&#96;&#96;&#96;，通过锁这个&#96;&#96;&#96;object&#96;&#96;&#96;来实现一个锁保护多个资源，如下：&gt;&gt;&#96;&#96;&#96;java&gt;class Account &#123;&gt; private final static Object lock &#x3D; new Object();&gt; private int balance;&gt; &#x2F;&#x2F; 转账&gt; void transfer(Account target, int amt)&#123;&gt;synchronized(lock) &#123;&gt;if (this.balance &gt; amt) &#123;&gt;this.balance -&#x3D; amt;&gt;target.balance +&#x3D; amt;&gt;&#125;&gt;&#125;&gt; &#125;&gt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>——<strong>yuc</strong></p><p>note:这样的话所有用户转账操作用的是同一把锁。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发3:互斥锁(上)</title>
      <link href="2020/04/06/java-bing-fa-3-hu-chi-suo-shang/"/>
      <url>2020/04/06/java-bing-fa-3-hu-chi-suo-shang/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发3-互斥锁-上"><a href="#Java并发3-互斥锁-上" class="headerlink" title="Java并发3:互斥锁(上)"></a>Java并发3:互斥锁(上)</h3><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li><p>如何理解原子性？</p><p>  原子性的本质其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。</p></li><li><p>如何解决原子性？</p><p>  产生原子性源头问题是线程切换，线程切换依赖CPU中断，那么禁用CPU中断就能禁止线程切换。</p><p>  单核CPU场景下，禁止CPU进行中断，那么线程不会切换，保证了同一时刻只有一个线程在执行。</p><p>  多核CPU场景下，禁止CPU进行中断，那么线程不会切换，但同一时刻有多个CPU在执行线程，<strong>同一时刻有多个线程在执行</strong>。</p><p>  note:解决原子性问题，是要保证中间状态对外不可见。</p></li></ul><p><strong>同一时刻只有一个线程执行</strong>，即互斥，这样无论单核还是多核CPU都可以保证原子性。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>解决原子性的方案：锁。</p><ul><li><p>简易锁模型</p><p>  <strong>临界区</strong>：一段需要互斥操作的代码，对其在前后进行加锁操作。</p></li></ul><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E7%AE%80%E6%98%93%E9%94%81%E6%A8%A1%E5%9E%8B.png" alt="简易锁模型"></p><ul><li><p>改进锁模型</p><p>  资源和锁之间应该有对应关系，好比不能拿你家的锁锁我家的门。</p><p>  首先，要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源 R；</p><p>  其次，要保护资源 R 需要为它创建一把锁 LR；</p><p>  最后，针对这把锁 LR，需在进出临界区时添上加锁操作和解锁操作。</p><p>  另外，在锁 LR 和受保护资源之间，图中特地用一条线做了关联，这个关联关系非常重要。</p><p>  很多并发 Bug 的出现都是因为把它忽略了，然后就出现了类似锁自家门来保护他家资产的事情，这样的 Bug 非常不好诊断，因为潜意识里认为已经正确加锁了。</p></li></ul><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E6%94%B9%E8%BF%9B%E5%90%8E%E9%94%81%E6%A8%A1%E5%9E%8B.png" alt="改进后的锁模型"></p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>Java提供<code>synchronized</code>关键字作为一种锁的实现。</p><ul><li>用法示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 修饰非静态方法</span>  <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 临界区</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 修饰静态方法</span>  <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 临界区</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 修饰代码块</span>  <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；  <span class="token keyword">void</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//实例作为锁定资源  </span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 临界区</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">//Class对象作为锁定资源</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 临界区</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java编译器会在<code>synchronized</code>关键字修饰的方法或代码块上自动执行加锁和解锁动作，这样做的好处是加锁和解锁一定是成对出现。</p><p>当<code>synchronized</code>修饰静态方法时，默认锁定的是当前类的Class对象；</p><p>当<code>synchronized</code>修饰非静态方法时，默认锁定的类是当前的实例对象this；</p><p>当<code>synchronized</code>修饰代码块时，应指定锁定的资源（Class或对象实例）。</p><ul><li>代码</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SafeCalc</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SafeCalc</span> safeCalc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SafeCalc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Tc</span><span class="token punctuation">(</span>safeCalc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Tc</span><span class="token punctuation">(</span>safeCalc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>safeCalc<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Tc</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token class-name">SafeCalc</span> safeCalc<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Tc</span><span class="token punctuation">(</span><span class="token class-name">SafeCalc</span> safeCalc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>safeCalc <span class="token operator">=</span> safeCalc<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                safeCalc<span class="token punctuation">.</span><span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，加了<code>synchronized</code>后可以完全保证第20行代码打印出来的计算结果一定是200000。</p><p>但需要注意的是，由于第4行代码没有加<code>synchronized</code>关键字，因此<code>addOne()</code>方法不<code>Happens-Before</code>于<code>get()</code>方法。</p><p>如果在计算过程中，有其他线程在不断执行<code>get()</code>方法，此时<code>get()</code>方法和<code>addOne()</code>方法是不互斥的，因此不保证每次<code>addOne()</code>方法执行后对<code>get()</code>方法的可见性。</p><p>但<code>t1</code>和<code>t2</code>中执行的<code>addOne()</code>方法之间的可见性和原子性都保证。</p><p>如果要保证<code>get()</code>方法和<code>addOne()</code>之间的可见性， 那么<code>get()</code>方法要加上<code>synchronized</code>关键字，或者<code>value</code>变量加<code>volatile</code>关键字。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E4%BF%9D%E6%8A%A4%E4%B8%B4%E7%95%8C%E5%8C%BAget()%E5%92%8CaddOne()%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><h3 id="锁和受保护资源的关系"><a href="#锁和受保护资源的关系" class="headerlink" title="锁和受保护资源的关系"></a>锁和受保护资源的关系</h3><p><strong>受保护资源和锁之间的关联关系为N:1的关系</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SafeCalc</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>  <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果按上面代码执行，明显可以发现<code>get()</code>和<code>addOne()</code>占用的仍然不是一个锁，不存在互斥关系。</p><p>临界区的代码是操作受保护资源的路径，要加锁，但不是随便一把锁都能有效。</p><p>所以得深入分析锁定的对象和受保护资源的关系，综合考虑受保护资源的访问路径，多方面考量才能用好互斥锁。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>下面代码是否正确？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SafeCalc</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>  <span class="token keyword">long</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个方法用的不是同一个锁，多个线程调用方法时，会一直产生新的锁（新的Object实例），不能保证原子性和可见性。</p><p><strong>一个合理的受保护资源与锁之间的关联关系应该是 N:1</strong></p><blockquote><p>多把锁保护同一个资源，就像一个厕所坑位，有N多门可以进去，没有丝毫保护效果，管理员一看，还不如把门都撤了，弄成开放式(编译器代码优化)。</p><p>——<strong>sbwei</strong></p></blockquote><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以加锁无效。</p><p>——<strong>nonohony</strong></p></blockquote><blockquote><p><strong>经过JVM逃逸分析的优化后，这个sync代码直接会被优化掉</strong>，所以在运行时该代码块是无锁的。</p><p>——<strong>w1sl1y</strong></p></blockquote><blockquote><p>sync锁的对象monitor指针指向一个ObjectMonitor对象，所有线程加入他的entrylist里面，去cas抢锁，更改state加1拿锁，执行完代码，释放锁state减1，和aqs机制差不多，只是所有线程不阻塞，cas抢锁，没有队列，属于非公平锁。<br>wait的时候，线程进waitset休眠，等待notify唤醒。</p><p>——<strong>zyl</strong></p></blockquote><blockquote><p>两把不同的锁，不能保护临界资源。而且这种new出来只在一个地方使用的对象，其它线程不能对它解锁，这个锁会被编译器优化掉。和没有syncronized代码块效果是相同的。</p><p>——<strong>老杨同志</strong></p></blockquote><blockquote><p>现实世界里，我们可以用多把锁来保护同一个资源，但在并发领域是不行的。<br>不能用两把锁锁定同一个资源吗？<br>如下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">></span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">&#123;</span> <span class="token keyword">private</span> <span class="token class-name">Object</span> lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token class-name">Object</span> lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> value<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然说这样做没有实际意义，但是也不会导致死锁或者其他不好的结果吧？</p><p>——<strong>石头剪刀布</strong></p><p>note:这种属于lock1保护lock2，lock2保护value。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发2:Happens-Before规则</title>
      <link href="2020/03/29/java-bing-fa-2-happens-before-gui-ze/"/>
      <url>2020/03/29/java-bing-fa-2-happens-before-gui-ze/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发2-Happens-Before规则"><a href="#Java并发2-Happens-Before规则" class="headerlink" title="Java并发2:Happens-Before规则"></a>Java并发2:Happens-Before规则</h3><p>由上篇总结可知：导致可见性的原因是缓存，导致有序性的原因是编译优化。</p><p>则解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>，但会出现性能问题。所以<strong>应该按需禁用缓存以及编译优化</strong>。</p><p>Java 内存模型是个很复杂的规范，可以从不同视角来解读，站在我们这些程序员的视角，本质上可以理解为，<strong>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法</strong>。</p><p>具体来说，这些方法包括 <code>volatile</code>、<code>synchronized </code>和 <code>final </code>三个关键字，以及<strong>六项 Happens-Before 规则</strong>。</p><p><code>volatile</code>：JDK1.5对该关键字做了增强，在原有禁止指令重排序&amp;禁用缓存的功能上，通过<strong>读写屏障</strong>保证了<strong>传递性</strong>。</p><p><strong>Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。</strong></p><h3 id="1-程序的顺序性规则"><a href="#1-程序的顺序性规则" class="headerlink" title="1. 程序的顺序性规则"></a>1. 程序的顺序性规则</h3><p>在一个线程中，按照<strong>程序控制流顺序</strong>(而非代码顺序)，前面的操作 Happens-Before 于后续的任意操作。</p><h3 id="2-volatile-变量规则"><a href="#2-volatile-变量规则" class="headerlink" title="2. volatile 变量规则"></a>2. volatile 变量规则</h3><p>指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。</p><h3 id="3-传递性"><a href="#3-传递性" class="headerlink" title="3. 传递性"></a>3. 传递性</h3><p>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</p><h3 id="4-管程中锁的规则"><a href="#4-管程中锁的规则" class="headerlink" title="4. 管程中锁的规则"></a>4. 管程中锁的规则</h3><p>指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><p><strong>管程</strong>是一种通用的同步原语，在 Java 中指的就是 <code>synchronized</code>，<code>synchronized</code> 是 Java 里对管程的实现。</p><h3 id="5-线程-start-规则"><a href="#5-线程-start-规则" class="headerlink" title="5. 线程 start() 规则"></a>5. 线程 start() 规则</h3><p>指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p><p>主线程调用B.start()之前，启动B线程之前所有对共享变量的修改，B线程皆可见。</p><h3 id="6-线程-join-规则"><a href="#6-线程-join-规则" class="headerlink" title="6. 线程 join() 规则"></a>6. 线程 join() 规则</h3><p>主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的<code> join()</code> 方法实现），当子线程 B 完成后（主线程 A 中<code>join()</code>方法返回），主线程能够看到子线程的操作，即对共享变量的操作。</p><h3 id="7-线程中断规则："><a href="#7-线程中断规则：" class="headerlink" title="7.线程中断规则："></a>7.线程中断规则：</h3><p>对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过<code>Thread.interrupted()</code>方法检测到是否有中断发生。</p><h3 id="8-对象终结规则"><a href="#8-对象终结规则" class="headerlink" title="8.对象终结规则"></a>8.对象终结规则</h3><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的<code>finalize()</code>方法的开始。</p><p><strong>Note：代码执行时在时间上的先后顺序与<code>Happends-Before</code>原则基本没有因果关系。</strong></p><hr><h3 id="补充-内存模型"><a href="#补充-内存模型" class="headerlink" title="补充-内存模型"></a>补充-内存模型</h3><p>Java内存模型规定所有变量存到主内存，可类比就是机器上的内存，当然仍处于虚拟机内存的一部分。</p><p>每条线程有自己的工作内存，可类比就是处理器缓存，里面会有对被该线程使用的主内存变量的副本。</p><p>线程先把要用的数据从主内存中读取到自己的工作内存中，再操作，操作完再写会主内存。</p><h3 id="补充-volatile关键字"><a href="#补充-volatile关键字" class="headerlink" title="补充-volatile关键字"></a>补充-volatile关键字</h3><p>2个性质：</p><p>可见性：一个线程对volatile变量的修改，其他线程可以立即看见。</p><p><strong>每次</strong>（指令级别）操作volatile变量，强制从主内存中读； 每次写volatile变量，强制向主内存中写。</p><p>禁止指令重排序：通过底层汇编代码<code>lock add1 $0x0,(%esp)</code>实现内存屏障，这样对volatile变量操作的指令的后面的指令就不会排到前面。</p><h3 id="补充-final关键字"><a href="#补充-final关键字" class="headerlink" title="补充-final关键字"></a>补充-final关键字</h3><p><strong>final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以最大限度优化。</strong></p><p>Java 编译器在 1.5 以前的版本的对该关键字有优化问题：类似利用双重检查方法创建单例，构造函数的错误重排导致线程可能看到 final 变量的值会变化。</p><p><strong>在 1.5 以后 Java 内存模型对<code>final</code>类型变量的重排进行了约束。前提是保证提供正确的构造函数没有“引用逃逸”。</strong></p><p><strong>如何正确使用<code>final</code>保证没有引用逃逸？</strong></p><blockquote><p><strong>How can final fields appear to change their values?</strong></p><p>One of the best examples of how final fields’ values can be seen to change involves one particular implementation of the <code>String</code> class.</p><p>A <code>String</code> can be implemented as an object with three fields – a character array, an offset into that array, and a length. The rationale for implementing <code>String</code> this way, instead of having only the character array, is that it lets multiple <code>String</code> and <code>StringBuffer</code> objects share the same character array and avoid additional object allocation and copying. So, for example, the method <code>String.substring()</code> can be implemented by creating a new string which shares the same character array with the original <code>String</code> and merely differs in the length and offset fields. For a <code>String</code>, these fields are all final fields.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">></span><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"/usr/tmp"</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token class-name">String</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//该处底层代码调用 new String(array, offset, length)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>The string <code>s2</code> will have an offset of 4 and a length of 4. But, under the old model, it was possible for another thread to see the offset as having the default value of 0, and then later see the correct value of 4, it will appear as if the string “/usr” changes to “/tmp”.</p><p>The original Java Memory Model allowed this behavior; several JVMs have exhibited this behavior. The new Java Memory Model makes this illegal.</p></blockquote><p>上面这段话解释了为什么可能出现线程访问final值时不同的情况。</p><p>举了一个很典型的例子：(需要重新组织下语言)</p><p>首先<code>String</code>类是由3字段实现的：一个字符数组(<code>array</code>)，数组偏移量(<code>offset</code>)，数组长度(<code>length</code>)。</p><p>为什么<code>String</code>类不直接只用一个字符数组实现就行了？反而要用这3个字段？</p><p>原因是让<code>String</code>类的<code>StringBuffer</code>类能复用同一个字符串底层的数组，这样就不用重复复制开辟内存空间了。</p><p>比如<code>String s  = &quot;abc&quot;</code>，底层是有<code>a</code>，<code>b</code>，<code>c</code>3个字符的数组，那么实际上<code>&quot;a&quot;</code>，<code>&quot;b&quot;</code>，<code>&quot;c&quot;</code>，<code>&quot;ab&quot;</code>,<code>&quot;ac&quot;</code>，<code>&quot;bc&quot;</code>这些字符串都可以复用<code>&quot;abc&quot;</code>的数组，只要这几个字符串的<code>offset</code>和<code>length</code>做出相应的变化就可以。</p><p>因此，一个<code>String</code>对象中的<code>offset</code>和<code>length</code>字段也肯定是<code>final</code>的。</p><p>从上面第2行代码可以看到，字符串<code>s2</code>是个<code>offset</code>为4，<code>length</code>为4的字符串，它和字符串<code>s1</code>底层都指向的同一个字符数组。</p><p>在旧的内存模型中，其他线程访问<code>s2</code>时，可能会发现<code>offset</code>为0，之后<code>offset</code>才显示正确值4。</p><p>这样就会让访问<code>s2</code>的线程发现，<code>s2</code>可能出现<code>s2=&quot;/usr&quot;</code>的情况（<code>offset=0</code>，<code>length=4</code>），等到<code>offset</code>成为4的时候，<code>s2</code>才为<code>&quot;/tmp&quot;</code>；</p><p><strong>这种情况的产生，就是指令重排优化导致先返回了<code>s2</code>的指针，再去给<code>offset</code>初始化造成的。</strong></p><p><strong>新的Java内存模型已经禁止了这种重排行为。</strong>（JDK1.5之后）</p><blockquote><p><strong>How do final fields work under the new JMM?</strong><br>The values for an object’s final fields are set in its constructor. Assuming the object is constructed “correctly”, once an object is constructed, the values assigned to the final fields in the constructor will be visible to all other threads without synchronization. In addition, the visible values for any other object or array referenced by those final fields will be at least as up-to-date as the final fields.</p><p>What does it mean for an object to be properly constructed? It simply means that no reference to the object being constructed is allowed to “escape” during construction. (See Safe Construction Techniques for examples.)  In other words, do not place a reference to the object being constructed anywhere where another thread might be able to see it; do not assign it to a static field, do not register it as a listener with any other object, and so on. These tasks should be done after the constructor completes, not in the constructor.</p></blockquote><p><code>final</code>字段的值在构造器中设置。假设对象被正确构造，一旦对象构造完成，那么其他线程不用同步就可以看得到<code>final</code>字段的值。另外，被这些<code>final</code>字段引用的对象或者数组的可见值肯定至少是跟<code>final</code>字段一样新。</p><p>那么怎样才能说一个构造器是被合理适当地构造了？</p><p>简单说就是在对象构造过程中，对该对象的引用都不允许<strong>“引用逃逸”</strong>(escape)。（详见<a href="http://www-106.ibm.com/developerworks/java/library/j-jtp0618.html"> Safe Construction Techniques for examples</a>）</p><p><strong>也就是说不要将正在构造的对象的引用放在另一个线程可能能够看到它的任何地方；不要将其分配给静态字段，不要在将这个引用注册为<code>listener</code>等等。这种操作应该放在构造器完成之后，而不是构造器里面。</strong></p><blockquote><p>以下是正确的使用方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">FinalFieldExample</span> <span class="token punctuation">&#123;</span><span class="token operator">></span><span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token operator">></span><span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token operator">></span><span class="token keyword">static</span> <span class="token class-name">FinalFieldExample</span> f<span class="token punctuation">;</span><span class="token operator">></span><span class="token keyword">public</span> <span class="token class-name">FinalFieldExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">></span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token operator">></span>y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">></span>f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalFieldExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">></span><span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> i <span class="token operator">=</span> f<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> f<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The class above is an example of how final fields should be used. A thread executing <code>reader</code> is guaranteed to see the value 3 for <code>f.x</code>, because it is final. It is not guaranteed to see the value 4 for <code>y</code>, because it is not final. </p></blockquote><p>从代码中可以看到，<strong>构造器仅仅是对属性值进行了初始化，构造器中并没有任何引用该对象的代码</strong>。</p><p>这样一个线程在执行<code>reader()</code>方法时，一定能够看得到<code>f.x=3</code>。</p><p><strong>因为它是<code>final</code>的，这样尽管可能在构造<code>f</code>对象时，先返回了对象指针（参考上篇文章双重检查方法创建单例），但Java内存模型一定保证了返回指针前把<code>final</code>字段的值给初始化了，但不一定看得到<code>f.y=4</code>。</strong></p><blockquote><p>If <code>FinalFieldExample</code>‘s constructor looked like this:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">></span><span class="token keyword">public</span> <span class="token class-name">FinalFieldExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// bad!</span><span class="token operator">></span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token operator">></span>y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token comment">// bad construction - allowing this to escape</span><span class="token operator">></span>global<span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>then threads that read the reference to <code>this </code>from <code>global.obj</code> are <strong>not</strong> guaranteed to see 3 for <code>x</code>.</p></blockquote><p>这种就是不好的例子，因为其他线程调用global.obj时，它可能还没初始化，就造成了空指针异常。</p><blockquote><p>The ability to see the correctly constructed value for the field is nice, but if the field itself is a reference, then you also want your code to see the up to date values for the object (or array) to which it points. If your field is a final field, this is also guaranteed. So, you can have a final pointer to an array and not have to worry about other threads seeing the correct values for the array reference, but incorrect values for the contents of the array. Again, by “correct” here, we mean “up to date as of the end of the object’s constructor”, not “the latest value available”.</p><p>Now, having said all of this, if, after a thread constructs an immutable object (that is, an object that only contains final fields), you want to ensure that it is seen correctly by all of the other thread, you <strong>still</strong> typically need to use synchronization. There is no other way to ensure, for example, that the reference to the immutable object will be seen by the second thread. The guarantees the program gets from final fields should be carefully tempered with a deep and careful understanding of how concurrency is managed in your code.</p><p>There is no defined behavior if you want to use JNI to change final fields.</p><p>——<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong"><strong>JSR 133 (Java Memory Model) FAQ</strong> Jeremy Manson and Brian Goetz, February 2004</a></p></blockquote><p>上面这段话总结起来就是，如果你构造函数里面有个<code>final</code>指针指向的是数组或者对象，如果这个数组和对象在被构造的时候，其他线程也可能在操作这个数组或对象，那么这个数组和对象就就是非线程安全的。你还是要在访问的地方加锁才可以保证其他线程看到的值都是最新的。</p><h3 id="补充-逃逸分析"><a href="#补充-逃逸分析" class="headerlink" title="补充-逃逸分析"></a>补充-逃逸分析</h3><p>JVM优化技术，通过编译时分析对象动态作用域，判断当一个对象在方法内定义后，是否可能逃逸，分成几个不同的逃逸程度。</p><p>不逃逸：变量仅在方法内使用，别的方法和线程无法访问。</p><p>方法逃逸：通过传参，被外部方法引用，但在同一线程内。</p><p>线程逃逸：通过赋值，变量会被其他线程访问。</p><p>优化方法：</p><ul><li><p>栈上分配</p><p>  如果对象无方法逃逸，对象可以之间放在方法的栈帧中，执行完即可销毁。HotSpot还没做此项优化。</p></li><li><p>标量替换</p><p>  如果对象无方法逃逸，对象可以化整为零，只需要在方法栈中存成员变量进行计算即可。</p></li><li><p>同步消除</p><p>  如果对象无线程逃逸，即无线程安全问题，就可以自动优化调加锁释放锁的操作。</p></li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>有一个共享变量 <code>abc</code>，在一个线程里设置了 <code>abc</code> 的值<code> abc=3</code>，有哪些办法可以让其他线程能够看到<code>abc==3</code>？</p><p>1.声明共享变量<code>abc</code>，并使用<code>volatile</code>关键字修饰<code>abc</code>。<br>2.声明共享变量<code>abc</code>，在<code>synchronized</code>关键字对<code>abc</code>的赋值代码块加锁，由于<code>Happen-before</code>管程锁的规则，可以使得后续的线程可以看到<code>abc</code>的值。<br>3.<code>A</code>线程启动后，使用<code>A.JOIN()</code>方法来完成运行，后续线程再启动，则一定可以看到<code>abc==3</code>。</p><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><ol><li><p>为什么定义Java内存模型？现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。</p></li><li><p>三个基本原则：原子性、可见性、有序性。</p></li><li><p>Java内存模型涉及的几个关键词：锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。</p></li><li><p>Happens-Before的7个规则：<br>(1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。<br>(2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面”是指时间上的先后顺序。<br>(3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的”后面”同样是指时间上的先后顺序。<br>(4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。<br>(5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。<br>(6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。<br>(7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始</p></li><li><p>Happens-Before的1个特性：传递性。</p></li><li><p>Java内存模型底层怎么实现的？主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。</p><p>——<strong>Healtheon</strong></p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发1:并发问题源头</title>
      <link href="2020/03/29/java-bing-fa-1-bing-fa-wen-ti-yuan-tou/"/>
      <url>2020/03/29/java-bing-fa-1-bing-fa-wen-ti-yuan-tou/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发1-并发问题源头"><a href="#Java并发1-并发问题源头" class="headerlink" title="Java并发1:并发问题源头"></a>Java并发1:并发问题源头</h3><h3 id="硬件之间的妥协"><a href="#硬件之间的妥协" class="headerlink" title="硬件之间的妥协"></a>硬件之间的妥协</h3><p>程序里大部分语句都要访问内存，有些还要访问 I/O，根据木桶理论，<strong>程序整体的性能取决于最慢的操作——读写 I/O 设备，也就是说单方面提高 CPU 性能是无效的</strong>。</p><p>为了合理利用 CPU 的高性能，平衡这三者速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li></ul><h3 id="缓存导致可见性问题"><a href="#缓存导致可见性问题" class="headerlink" title="缓存导致可见性问题"></a>缓存导致可见性问题</h3><p><strong>一个线程对共享变量的修改，另外一个线程能够立刻看到，称为可见性。</strong></p><p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。</p><p>因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。</p><p>下图中，线程 A 和线程 B 都是操作<strong>同一个 CPU 里面的缓存</strong>，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%8D%95%E6%A0%B8CPU%E4%B8%8A%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9Cpng" alt="单核CPU上的线程操作"></p><p>多核时代，每颗 CPU 都有自己的缓存，多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。</p><p>下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，<strong>这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了</strong>。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%A4%9A%E6%A0%B8CPU%E4%B8%8A%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C.png" alt="多核CPU上的线程操作"></p><h5 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建两个线程，执行add()操作</span>    <span class="token class-name">Thread</span> th1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>      test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> th2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>      test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 启动两个线程</span>    th1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待两个线程执行结束</span>    th1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    th2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，会发现内存中是 1，而不是期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。<strong>这就是缓存的可见性问题。</strong></p><p>循环 10000 次 count+=1 操作如果改为循环 1 亿次，效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。</p><p>如果循环 10000 次，count 的值接近 20000，<strong>原因是两个线程不是同时启动的，有一个时差。</strong></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%8F%AF%E8%A7%81%E6%80%A7%E8%AE%A1%E7%AE%97.png" alt="计算结果"></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%8F%98%E9%87%8Fcount%E5%9C%A8%E5%86%85%E5%AD%98%E5%92%8CCPU%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5.png" alt="变量count在内存和CPU缓存中的情况"></p><h3 id="线程切换带来的原子性问题"><a href="#线程切换带来的原子性问题" class="headerlink" title="线程切换带来的原子性问题"></a>线程切换带来的原子性问题</h3><p>操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（称为“任务切换”），这个 50 毫秒称为“时间片”。</p><p>早期的操作系统基于<strong>进程来调度 CPU</strong>，不同进程间是<strong>不共享内存空间</strong>的，所以进程要做任务切换就要切换内存映射地址，而<strong>一个进程创建的所有线程，都是共享一个内存空间</strong>的，所以线程做任务切换成本就很低了。</p><p>现代的操作系统都基于更轻量的线程来调度，<strong>现在我们提到的“任务切换”都是指“线程切换”</strong>。</p><p>Java 并发程序都是基于多线程的，自然也会涉及到任务切换，这是并发编程里诡异 Bug 的源头之一。</p><p>任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成。</p><p>例如<code>count += 1</code>，至少需要三条 CPU 指令。</p><ul><li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li><li>指令 2：之后，在寄存器中执行 +1 操作；</li><li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li></ul><p><strong>操作系统做任务切换，可以发生在任何一条 CPU 指令执行完</strong>，而不是高级语言里的一条语句。</p><p>对于上面的三条指令来说，假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么会发现两个线程都执行了 count+=1 的操作，但得到的结果不是期望的 2，而是 1。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C.png" alt="非原子操作示意图"></p><p><strong>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。</strong></p><p><strong>CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背直觉的地方。</strong></p><p>因此，很多时候我们需要在高级语言层面保证操作的原子性。</p><h3 id="编译优化带来的有序性问题"><a href="#编译优化带来的有序性问题" class="headerlink" title="编译优化带来的有序性问题"></a>编译优化带来的有序性问题</h3><p>编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。</p><p>不过有时候编译器及解释器的优化可能导致意想不到的 Bug。</p><p>在 Java 领域一个经典的案例就是利用<strong>双重检查创建单例对象</strong>，例如下面的代码：在获取实例<code>getInstance()</code> 的方法中，我们首先判断 <code>instance</code>是否为空，如果为空，则锁定<code>Singleton.class</code> 并再次检查 <code>instance</code>是否为空，如果还为空则创建<code>Singleton</code>的一个实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//为什么双重加锁？性能好，一旦单例创建，每次再去获取时不需要再锁定资源。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设两个线程 A、B 同时调用 <code>getInstance()</code>方法，他们会同时发现<code>instance == null</code> ，于是同时对 <code>Singleton.class</code>加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个<code>Singleton</code> 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查<code>instance == null</code>时会发现，已经创建过 <code>Singleton</code>实例了，所以线程 B 不会再创建一个 <code>Singleton</code>实例。</p><p>但实际上这个<code>getInstance()</code>方法并不完美，问题出在 new 操作上。</p><p>我们以为的 new 操作应该是：</p><ul><li>分配一块内存 M；</li><li>在内存 M 上初始化 Singleton 对象；</li><li>然后 M 的地址赋值给 instance 变量。</li></ul><p>实际上优化后的执行路径：</p><ul><li>分配一块内存 M；</li><li>将 M 的地址赋值给 instance 变量；</li><li>最后在内存 M 上初始化 Singleton 对象。</li></ul><p>假设线程 A 先执行 <code>getInstance()</code> 方法，当执行完指令 2 （<strong>将 M 的地址赋值给 instance 变量</strong>）时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行<code>getInstance()</code>方法，那么线程 B 在执行第一个判断时会发现 <code>instance != null</code>（只有指针没有实例），所以直接返回<code>instance</code>，而此时的<code>instance</code> 是没有初始化过的，如果这个时候访问 instance 的成员变量就可能触发空指针异常。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E5%8D%95%E4%BE%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="双重检查单例执行流程"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可见性：由于多核CPU并行处理多线程，并利用各自CPU缓存对共享数据的计算结果导致线程之间修改的共享数据对各自不可见，造成程序执行错误。</p><p>单核CPU可以保证可见性，但如果不加锁，对共享数据的操作仍不安全，会出现原子性问题。</p><p>原子性：高级语言一行代码由多个CPU指令完成，而任务切换可能发生在任意一条CPU指令完成之后。造成了高级语言的代码不具备原子性。</p><p>有序性：编译器为了优化程序执行效率而对代码对应的执行的CPU指令进行顺序优化，导致指令执行过程顺序发生改变，上升到代码层次出现BUG。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>32 位的机器上对 long 型变量进行加减操作是否存在并发隐患？</p><p>long类型是64位，在32位机器上进行计算要多条指令执行才能完成，会有并发隐患。</p><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>如果对<code>instance</code>进行<code>volatile</code>语义声明，就可以禁止指令重排序，避免该情况发生。<br>CPU缓存不存在于内存中的，它是一块比内存更小、读写速度更快的芯片，至于什么时候把数据从缓存写到内存，没有固定的时间。</p><p>对于有volatile语义声明的变量，线程A执行完后会强制将值刷新到内存中，线程B进行相关操作时会强制重新把内存中的内容写入到自己的缓存，这就涉及到了<code>volatile</code>的写入屏障问题，当然也就是所谓<code>happen-before</code>问题。</p><p>——<strong>Jialin</strong></p></blockquote><blockquote><p>——CPU缓存刷新到内存的时机——<br>cpu将缓存写入内存的时机是不确定的。除非调用cpu相关指令强刷</p><p>——指令优化——<br><strong>除了编译优化,有一部分可以通过看汇编代码来看，但是CPU和解释器在运行期也会做一部分优化，所以很多时候都是看不到的，也很难重现。</strong></p><p>——JMM模型和物理内存、缓存等关系——<br>内存、cpu缓存是物理存在，jvm内存是软件存在的。<br>关于线程的工作内存和寄存器、cpu缓存的关系 大家可以参考这篇文章<br><a href="https://blog.csdn.net/u013851082/article/details/70314778/">https://blog.csdn.net/u013851082/article/details/70314778/</a></p><p>——IO操作——<br>io操作不占用cpu，读文件，是设备驱动干的事，cpu只管发命令。发完命令，就可以干别的事情了。</p><p>——寄存器切换——<br>寄存器是共用的，A线程切换到B线程的时候，寄存器会把操作A的相关内容会保存到内存里，切换回来的时候，会从内存把内容加载到寄存器。<strong>可以理解为每个线程有自己的寄存器。</strong></p><p>——<strong>别皱眉</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发0:并发问题核心点</title>
      <link href="2020/03/29/java-bing-fa-0-bing-fa-wen-ti-he-xin-dian/"/>
      <url>2020/03/29/java-bing-fa-0-bing-fa-wen-ti-he-xin-dian/</url>
      
        <content type="html"><![CDATA[<h3 id="Java并发0-并发问题核心点"><a href="#Java并发0-并发问题核心点" class="headerlink" title="Java并发0:并发问题核心点"></a>Java并发0:并发问题核心点</h3><h3 id="什么是并发-并行？"><a href="#什么是并发-并行？" class="headerlink" title="什么是并发/并行？"></a>什么是并发/并行？</h3><p>同一时间段内，多个线程交替执行，为并发。同一时刻内，多个线程同时执行，为并行。</p><h3 id="并发问题核心"><a href="#并发问题核心" class="headerlink" title="并发问题核心"></a>并发问题核心</h3><p>并发问题核心为三点：<strong>分工，同步，互斥</strong></p><ul><li><p>分工，即如何更好的拆解任务分配给线程以实现高效执行。</p></li><li><p>同步，即线程之间如何高效协作。</p></li><li><p>互斥，即保证同一时刻只允许一个线程访问共享资源。</p></li></ul><p>Java SDK 并发包很大部分内容都是按照这三个维度组织的，例如<code> Fork/Join</code> 框架就是一种分工模式，<code>CountDownLatch</code> 就是一种典型的同步方式，而可重入锁则是一种互斥手段。</p><h4 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h4><p>并发领域里，分工很重要，决定了并发性能。Java SDK 并发包里的<code> Executor</code>、<code>Fork/Join</code>、<code>Future</code>  本质上都是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如<code>生产者 - 消费者</code>、<code>Thread-Per-Message</code>、<code>Worker Thread</code> 模式等都是用来指导如何分工的。</p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>在并发编程领域里的同步，主要指的就是线程间的协作，本质上和现实生活中的协作没区别，不过是一个线程执行完了一个任务，如何通知执行后续任务的线程开工而已。</p><p>工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题：<strong>当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行</strong>。</p><p>在 Java 并发编程领域，解决协作问题的核心技术是<strong>管程</strong>。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决互斥问题。可以这么说，<strong>管程是解决并发问题的万能钥匙</strong>。</p><p><strong>理论上，理解管程模型。实践上，掌握 Java SDK 并发包的工具类的应用场景和使用方法。</strong></p><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>分工、同步主要强调的是性能，<strong>互斥，用专业术语叫“线程安全”，为了保证正序执行结果正确性。</strong></p><p><strong>所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。</strong></p><p><strong>实现互斥的核心技术就是锁</strong>，Java 语言里<code>synchronized</code>、SDK 里的各种 <code>Lock</code> 都能解决互斥问题。</p><p>锁解决了安全性问题，但同时也带来了<strong>性能问题</strong>，如何保证安全性的同时又尽量提高性能？</p><ul><li>分场景优化，如Java SDK 里提供的 <code>ReadWriteLock</code>、<code>StampedLock</code> 可以优化读多写少场景下锁的性能。</li><li>使用无锁的数据结构，例如 Java SDK 里提供的<code>原子类</code>都是基于无锁技术实现的。</li><li>其他方案，原理是不共享变量或者变量只允许读。这方面，Java 提供了 <code>Thread Local</code> 和<code> final</code> 关键字，还有一种 <code>Copy-on-write </code>的模式。使用锁除了要注意性能问题外，还需要<strong>注意死锁</strong>问题。</li></ul><h3 id="全景图"><a href="#全景图" class="headerlink" title="全景图"></a>全景图</h3><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E5%85%A8%E6%99%AF%E5%9B%BE.png" alt="并发编程全景图"></p><h3 id="别人的总结"><a href="#别人的总结" class="headerlink" title="别人的总结"></a>别人的总结</h3><blockquote><p>从性能角度讲，为了提高执行一定计算机任务的效率，所以IO等待的时候不能让cpu闲着。</p><p>因此我们把任务拆分交替执行，有了分时操作系统，出现了并发，后来cpu多核了又有了并行计算。</p><p>这就是<strong>分工</strong>。</p><p>分工后为了进一步提升效率和更加灵活地达到目的，要对任务进行组织编排，也就是对线程组织编排。</p><p>于是线程之间需要<strong>通信</strong>，于是操作系统提供了一些让进程，线程之间通信的方式。</p><p>这就是<strong>同步</strong>。</p><p>但是事物总不是完美的。并发和通信带来了较高的编程复杂度，同时也出现了多线程并发操作共享资源的问题。于是天下大势，分久必合，我们又要将对共享资源的访问串行化。所以根据现实世界的做法设计了了<strong>锁</strong>，<strong>信号量</strong>等等来补充这套体系。</p><p>这就是<strong>互斥</strong>。</p><p>综上，这一切均为提高性能的手段和对其所产生问题的解决方案。</p><p>——<strong>常江舟</strong></p></blockquote><blockquote><ol><li>方法论层面：<strong>跳出来，看全景</strong> 和 <strong>钻进去，看本质</strong>，这两条方法论，适合很多领域的学习的。</li><li>并发领域的<strong>全景图</strong>。<br>对于<strong>全景图</strong>，我之前也有一直在构建，可是因为知识储备不够，确实很难构建出来。稍微了解过并发领域知识的人都知道，里面的知识点、概念多而散：<strong>线程安全</strong>、<strong>锁</strong>、<strong>同步</strong>、<strong>异步</strong>、<strong>阻塞</strong>、<strong>非阻塞</strong>、<strong>死锁</strong>、<strong>队列</strong>(为什么并发要跟队列扯上关系)、<strong>闭锁</strong>、<strong>信号量</strong>、<strong>活锁</strong>等等。如果单个去学这些知识点，单个去练习，如果没有「主线」，后期很容易忘。我思考再思考，也总结了一下学习并发的主线：<br>首先，得理解并发的重要性，为什么需要并发？对于这个问题，只需要放在潜意识里面，只需要两个字：<strong>性能</strong>！其它的细节，再去慢慢拓展。<br>然后，既然并发很重要，而并发处理的是任务，接下就是：<strong>对任务的抽象、拆解、分工执行</strong>。而线程模型，只是其中的一种模型，还有多进程、协程。Java使用的是多线程模型，对应到具体的代码就是：<code>Thread</code>, <code>Runnable</code>, <code>Task</code>，执行任务有：<code>Exectors</code>。 引出了线程，有势必存在着线程安全性的问题，因为多线程访问，数据存在着不一致的问题。<br>再然后，大的任务被拆解多个小的子任务，小的子任务被各自执行，不难想象，子任务之间肯定存在着依赖关系，<strong>所以需要协调</strong>，那如何协调呢？也不难想到，锁是非常直接的方式(Monitor原理)，但是<strong>只用锁，协调的费力度太高</strong>，在并发的世界里面，又有了一些其它的更抽象的工具：<strong>闭锁、屏障、队列以及其它的一些并发容器等</strong>；好了，协调的工作不难处理了。可是<strong>协调也会有出错的时候，这就有了死锁、活锁等问题</strong>，大师围绕着这个问题继续优化协调工具，尽量让使用者不容易出现这些活跃性问题；<br>到此，「并发」的历史还在演化：如果一遇到并发问题，就直接上锁，倒也没有什么大问题，可是追求性能是人类的天性。计算机大师就在思考，<strong>能不不加锁也能实现并发，还不容易出错</strong>，于是就有了：<code>CAS</code>、<code>copy-on-write</code>等技术思想，这就是实现了<strong>无锁</strong>并发；<br>可是，事情到此还没有完。如果以上这些个东西，都需要每个程序员自己去弄，然后自己保证正确性，那程序员真累死了，哪还有时间、精力创造这么多美好的应用！于是，计算机大师又开始思考，能不能抽象出统一<strong>模型</strong>，可能这就有了类似于<strong>Java内存模型</strong>这样的东西。</li></ol><p>——<strong>Jerry银银</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA敏捷开发归纳</title>
      <link href="2020/03/15/idea-min-jie-kai-fa-gui-na/"/>
      <url>2020/03/15/idea-min-jie-kai-fa-gui-na/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA敏捷开发归纳"><a href="#IDEA敏捷开发归纳" class="headerlink" title="IDEA敏捷开发归纳"></a>IDEA敏捷开发归纳</h3><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><table><thead><tr><th align="center">Keymap</th><th>Explanation</th></tr></thead><tbody><tr><td align="center">Ctrl + Shift + A</td><td>Find Action 查找IDEA中的操作</td></tr><tr><td align="center">Ctrl + Shift +S</td><td>打开设置面板</td></tr><tr><td align="center">Ctrl + E</td><td>最近访问过的文件列表</td></tr><tr><td align="center">Alt + 1 then ESC</td><td>进入Project栏，按ESC后回到当前文件</td></tr><tr><td align="center">Alt + N(number)</td><td>进入界面所标号的栏</td></tr><tr><td align="center">Alt + ← or →</td><td>选择文件Tab页</td></tr><tr><td align="center">Double Shift</td><td>搜索All</td></tr><tr><td align="center">Ctrl + N</td><td>搜索class</td></tr><tr><td align="center">Ctrl + Shift + N</td><td>搜索Files</td></tr><tr><td align="center">Ctrl + Shift + Alt + N</td><td>搜索Symbols</td></tr><tr><td align="center">Ctrl +Shift + F</td><td>精准搜索，搜索文件中的内容，可定制化</td></tr><tr><td align="center">F11</td><td>添加书签</td></tr><tr><td align="center">Ctrl +F11</td><td>添加书签并做标记</td></tr><tr><td align="center">Shift + F11</td><td>显示书签列表</td></tr><tr><td align="center">Ctrl + Alt + 2</td><td>添加到收藏(favorite)</td></tr><tr><td align="center">Ctrl + Alt + Page Up or Down (自定义)</td><td>跳转到前一个or后一个浏览的文件</td></tr><tr><td align="center">Ctrl + Shift + Backspace or \ (自定义)</td><td>跳转到前一个or或后一个编辑的文件</td></tr><tr><td align="center">Shift + S(自定义)</td><td>跳转到某字母</td></tr><tr><td align="center">Ctrl +B or just F4</td><td>跳转到当前变量或方法的源代码上</td></tr><tr><td align="center">Alt + HOME</td><td>跳转到导航栏</td></tr><tr><td align="center">Ctrl +HOME</td><td>跳转到当前文件第一行</td></tr><tr><td align="center">Shift + Enter</td><td>光标所在当前行下方新起一行</td></tr><tr><td align="center">Ctrl + D</td><td>复制当前行并在下方新起一行粘贴</td></tr><tr><td align="center">Ctrl + Alt + Enter</td><td>光标所在当前行上方新起一行</td></tr><tr><td align="center">HOME</td><td>光标所在行行头</td></tr><tr><td align="center">END</td><td>光标所在行行位</td></tr><tr><td align="center">Shift + Home</td><td>选中行头到光标所在处内容</td></tr><tr><td align="center">Shift + END</td><td>选中光标所在处到行尾内容</td></tr><tr><td align="center">Alt + Enter</td><td>处理报错/纠正错误单词/自动创建函数/自动创建方法/ 实现接口</td></tr></tbody></table><h3 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h3><h4 id="Live-Templates"><a href="#Live-Templates" class="headerlink" title="Live Templates"></a>Live Templates</h4><ul><li><p>psvm</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        $END$    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>psc(private int with comment)</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** $VAR1$*/</span><span class="token keyword">private</span> <span class="token keyword">int</span> $VAR2$<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>psf(private static final)</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> $VAR$<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>psfi(public static final int)</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> $VAR1$ <span class="token operator">=</span> $VAR2$<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>psfs(private static final String)</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> $VAR1$ <span class="token operator">=</span> $VAR2$<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>sout</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>$END$<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="Postfix"><a href="#Postfix" class="headerlink" title="Postfix"></a>Postfix</h4><ul><li><p>for</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Before</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        values<span class="token punctuation">.</span><span class="token keyword">for</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//After</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>fori</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Before</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//After</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> foo<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>sout</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Before</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    b<span class="token punctuation">.</span>sout  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//After</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><h4 id="Background-Images-Plus"><a href="#Background-Images-Plus" class="headerlink" title="Background Images Plus"></a>Background Images Plus</h4><p>在IDEA背景使用图片</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/backgroundimg.png" alt="效果"></p><h4 id="Code-Glance"><a href="#Code-Glance" class="headerlink" title="Code Glance"></a>Code Glance</h4><p>提供代码缩略图浏览</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/codeview.png" alt="效果"></p><h4 id="Grep-Console"><a href="#Grep-Console" class="headerlink" title="Grep Console"></a>Grep Console</h4><p>控制台打印日志区分不同级别颜色</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/log.png" alt="效果"></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/log1.png" alt="效果"></p><h4 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h4><p>标记括号颜色方便区分</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/rainbow.png" alt="效果"></p><h4 id="Statistic"><a href="#Statistic" class="headerlink" title="Statistic"></a>Statistic</h4><p>统计代码行数</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/lines.png" alt="效果"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 敏捷开发 </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次JedisCluster开发问题</title>
      <link href="2019/03/01/ji-yi-ci-jediscluster-kai-fa-wen-ti/"/>
      <url>2019/03/01/ji-yi-ci-jediscluster-kai-fa-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="记一次JedisCluster开发问题"><a href="#记一次JedisCluster开发问题" class="headerlink" title="记一次JedisCluster开发问题"></a>记一次JedisCluster开发问题</h3><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><p>节点数：12（6主6从）</p><p><code>47.93.231.115:6378,47.93.231.115:6379,47.93.231.115:6380,47.93.231.115:6381</code></p><p><code>106.13.124.4:6378,106.13.124.4:6379,106.13.124.4:6380,106.13.124.4:6381</code></p><p><code>119.3.221.0:6378,119.3.221.0:6379,119.3.221.0:6380,119.3.221.0:6381</code></p><p>p.s. 6378&amp;6379为主节点，6380&amp;6381为对应服务器的从节点。</p><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#Redis配置</span><span class="token attr-name">spring.redis.jedis.pool.max-idle</span><span class="token punctuation">=</span><span class="token attr-value">8</span><span class="token attr-name">spring.redis.jedis.pool.min-idle</span><span class="token punctuation">=</span><span class="token attr-value">0</span><span class="token attr-name">spring.redis.jedis.pool.max-wait</span><span class="token punctuation">=</span><span class="token attr-value">5000</span><span class="token attr-name">spring.redis.cluster.nodes</span><span class="token punctuation">=</span><span class="token attr-value">47.93.231.115:6378,47.93.231.115:6379,47.93.231.115:6380,47.93.231.115:6381,106.13.124.4:6378,106.13.124.4:6379,106.13.124.4:6380,106.13.124.4:6381,119.3.221.0:6378,119.3.221.0:6379,119.3.221.0:6380,119.3.221.0:6381</span><span class="token comment">#最大请求重试次数</span><span class="token attr-name">spring.redis.cluster.max-redirects</span><span class="token punctuation">=</span><span class="token attr-value">10</span><span class="token comment">#读取数据超时时间</span><span class="token attr-name">spring.redis.timeout</span><span class="token punctuation">=</span><span class="token attr-value">5000</span><span class="token comment">#链接超时时间</span><span class="token attr-name">redis.connection.timeout</span><span class="token punctuation">=</span><span class="token attr-value">5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JedisCluster配置"><a href="#JedisCluster配置" class="headerlink" title="JedisCluster配置"></a>JedisCluster配置</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;spring.redis.cluster.nodes&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> clusterNodes<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;spring.redis.timeout&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> timeout<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;spring.redis.jedis.pool.max-idle&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxIdle<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;spring.redis.jedis.pool.max-wait&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> maxWaitMillis<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;redis.connection.timeout&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> connectionTimeout<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;spring.redis.cluster.max-redirects&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxRedirects<span class="token punctuation">;</span>    <span class="token comment">/**     * JedisCluster方式操作集群     * @return     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">JedisCluster</span> <span class="token function">getJedisCluster</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">></span></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hostAndPort <span class="token operator">=</span> clusterNodes<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> node <span class="token operator">:</span> hostAndPort<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">HostAndPort</span><span class="token punctuation">.</span><span class="token function">parseString</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">JedisPoolConfig</span> jedisPoolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span>maxIdle<span class="token punctuation">)</span><span class="token punctuation">;</span>        jedisPoolConfig<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span>maxWaitMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">JedisCluster</span> jedisCluster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span>nodes<span class="token punctuation">,</span> connectionTimeout<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> maxRedirects<span class="token punctuation">,</span> jedisPoolConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> jedisCluster<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BUG现象"><a href="#BUG现象" class="headerlink" title="BUG现象"></a>BUG现象</h3><p><strong>使用JedisCluster操作集群，操作到节点<code>47.93.231.115:6379</code>（对应槽位2730-5459）上的数据时总是上报<code>redis.clients.jedis.exceptions.JedisClusterMaxAttemptsException: No more cluster attempts left.</code>异常。</strong></p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><h4 id="环境排查"><a href="#环境排查" class="headerlink" title="环境排查"></a>环境排查</h4><ul><li>集群状态正常</li><li>通过<code>RedisTemplate</code>操作集群正常</li><li><code>JedisCluster</code>操作其他节点正常</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul><li>执行<code>System.out.println(jedisCluster.get(&quot;go&quot; ));</code>报异常，键<code>go</code>在节点<code>47.93.231.115:6379</code>上。<code>jedisCluster.get()</code>底层调用<code>runWithRetries()</code>方法。</li><li><code>runWithRetries()</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//类JedisClusterCommand 省略大量代码</span><span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">runWithRetries</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> slot<span class="token punctuation">,</span> <span class="token keyword">int</span> attempts<span class="token punctuation">,</span> <span class="token keyword">boolean</span> tryRandomNode<span class="token punctuation">,</span> <span class="token class-name">JedisRedirectionException</span> redirect<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>attempts <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//重试次数逐渐递减 为0后抛出异常</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">JedisClusterMaxAttemptsException</span><span class="token punctuation">(</span><span class="token string">"No more cluster attempts left."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Jedis</span> connection <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//尝试获取对应槽位的节点的链接  </span>      connection <span class="token operator">=</span> connectionHandler<span class="token punctuation">.</span><span class="token function">getConnectionFromSlot</span><span class="token punctuation">(</span>slot<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取到链接 执行命令</span>      <span class="token keyword">return</span> <span class="token function">execute</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JedisConnectionException</span> jce<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 捕获链接异常</span>      <span class="token function">releaseConnection</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>      connection <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>attempts <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>connectionHandler<span class="token punctuation">.</span><span class="token function">renewSlotCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> <span class="token function">runWithRetries</span><span class="token punctuation">(</span>slot<span class="token punctuation">,</span> attempts <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tryRandomNode<span class="token punctuation">,</span> redirect<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打断点后发现执行<code>line10</code>无法创建连接，被<code>line13</code>捕获异常。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8.png" alt="捕获异常"></p><p>如此循环往复直到<code>attempts &lt;= 0</code>抛出异常。</p><ul><li><code>getConnectionFromSlot() </code>方法</li></ul><p>继续分析<code>runWithRetries()</code>中<code>line10</code>的<code>getConnectionFromSlot() </code>方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token class-name">Jedis</span> <span class="token function">getConnectionFromSlot</span><span class="token punctuation">(</span><span class="token keyword">int</span> slot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//获取Jeids连接池</span>   <span class="token class-name">JedisPool</span> connectionPool <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">getSlotPool</span><span class="token punctuation">(</span>slot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//省略大量代码...</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打断点查看<code>connectionPool</code>数据，发现异常。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/connectionPool.png" alt="connectionPool"></p><p><strong>初始化的<code>connecionPool</code>是<code>192.168.1.86：6379</code>，一个不存在的节点，而不是应该访问的节点<code>47.93.231.115:6379</code>。</strong></p><p>因为访问键<code>go</code>，应该访问节点<code>47.93.231.115:6379</code>，而不是<code>192.168.1.86：6379</code>这个不存在的节点。</p><ul><li><code>connecionPool</code>由<code>cache.getSlotPool(slot)</code>而来，查看<code>cache</code>中槽位与节点存在对应关系。</li></ul><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/cacheDetails.png" alt="cacheDetails"></p><p><code>slots</code>大小为16384，包含了每个槽位与节点的对应关系，上图为<code>slot0</code>对应的节点关系。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/%E6%A7%BD%E4%BD%8D%E8%8A%82%E7%82%B9%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="槽位节点对应关系"></p><p><strong>上图发现槽位2730的节点对应IP已出现错误，正好是节点<code>47.93.231.115:6379</code>对应槽位的开头，后面槽位对应的也是相同的错误IP。</strong></p><p><strong>接下来分析cache中的槽位节点映射关系为什么会产生错误。</strong></p><ul><li><code>JedisCluster</code>在初始化时，会将集群中各节点和哈希槽的映射关系进行缓存</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1、初始化JedisCluster</span><span class="token comment">//类RedisConfig</span><span class="token class-name">JedisCluster</span> jedisCluster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span>nodes<span class="token punctuation">,</span> connectionTimeout<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> maxRedirects<span class="token punctuation">,</span> jedisPoolConfig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2、方法调用至此</span><span class="token comment">//类JedisClusterConnectionHandler 只展示了必要参数</span>  <span class="token keyword">public</span> <span class="token class-name">JedisClusterConnectionHandler</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">></span></span> nodes<span class="token punctuation">,</span> <span class="token keyword">int</span> connectionTimeout<span class="token punctuation">,</span> <span class="token keyword">int</span> soTimeout<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//调用该方法初始化节点和槽位映射关系的缓存 </span>    <span class="token function">initializeSlotsCache</span><span class="token punctuation">(</span>nodes<span class="token punctuation">,</span> connectionTimeout<span class="token punctuation">,</span> soTimeout<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>initializeSlotsCache</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//类JedisClusterConnectionHandler</span><span class="token comment">//初始化节点与槽映射关系 只展示必要参数</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initializeSlotsCache</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">></span></span> startNodes<span class="token punctuation">,</span>       <span class="token keyword">int</span> connectionTimeout<span class="token punctuation">,</span> <span class="token keyword">int</span> soTimeout<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//遍历Set集合中的IP与端口</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">HostAndPort</span> hostAndPort <span class="token operator">:</span> startNodes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//创建一个新连接 整个初始化过程中第一次创建连接 </span>        jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span>hostAndPort<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hostAndPort<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> connectionTimeout<span class="token punctuation">,</span> soTimeout<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//省略部分代码...</span>        <span class="token comment">//传入连接 通过调用Redis的cluster slots命令获取节点与哈希槽的映射关系 并进行分配</span>        cache<span class="token punctuation">.</span><span class="token function">discoverClusterNodesAndSlots</span><span class="token punctuation">(</span>jedis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JedisConnectionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// try next nodes</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token comment">//HostAndPort类重写了hashCode()方法</span><span class="token comment">//当然 即使不重写，String类自己的hashCode()方法对相同字符串hash结果也一定都是相同的</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">31</span> <span class="token operator">*</span> <span class="token function">convertHost</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> port<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打断点发现，每次第一次创建连接，都连接节点<code>47.93.231.115:6379</code>，即每次遍历<code>Set</code>的第一个元素都是<code>47.93.231.115:6379</code>该节点。</strong></p><ul><li>复习<code>HeahSet</code>的遍历</li></ul><p>由于<code>HashSet</code>底层使用的是<code>HashMap</code>，当调用<code>set.add()</code>，方法时，底层会调用<code>map.put()</code>方法。</p><p>整个调用流程为：</p><p>具体细节请移步：<a href="https://www.zhihu.com/question/28414001/answer/740571085">Java遍历HashSet为什么输出是有序的？</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashSet</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> → <span class="token class-name">HashMap</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">)</span> → <span class="token class-name">HashMap</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> → <span class="token class-name">HashMap</span> <span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面是执行<code>nodes.add(HostAndPort.parseString(node));</code>时对<code>HashMap</code>源码打的断点。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/HashMap%E6%96%AD%E7%82%B9.png" alt="HashMap断点"></p><p>从图中可看到：</p><p>①处表明此时要存的<code>key</code>是节点<code>47.93.231.115:6379</code></p><p>②处表明角标<code>i</code>由<code>(n - 1) &amp; hash</code>而来</p><p>③处表明此时<code>i = 0</code></p><p><strong><code>HashMap</code>要将元素放入哈希表时，通过 <code>(tab.length - 1) &amp; hash</code>确定元素存放的角标。</strong></p><p><strong>节点确定→ 节点的<code>hashCode</code>确定→ <code>(tab.length - 1) &amp; hash</code>值确定→ 元素角标确定→ 遍历<code>Set</code>从最小角标开始</strong></p><p><strong>总结：每次遍历<code>Set</code>集合的第一个节点都是固定的，即角标为0的那个节点。</strong></p><p><strong>因此每次第一次遍历到的节点都是<code>47.93.231.115:6379</code>。</strong></p><ul><li><code>discoverClusterNodesAndSlots()</code>方法(<code>initializeSlotsCache</code>方法的<code>line13</code>)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">discoverClusterNodesAndSlots</span><span class="token punctuation">(</span><span class="token class-name">Jedis</span> jedis<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//加锁等操作  省略...</span> <span class="token comment">//获取节点与slots的映射集合</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> slots <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">clusterSlots</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//根据映射关系初始化到缓存等操作...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打断点查看<code>slot</code>的数据结构：</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/slots.png" alt="slots"></p><p>可以看到<code>slots</code>长度为6，其中每个元素长度为4。</p><p>查看其元素的细节：</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/slotsDetails.png" alt="slotsDetails"></p><p>每个元素的长度为4，其中：</p><p>①包含节点对应划分的哈希槽范围，如图5460-8189</p><p>②处元素0为哈希槽对应主节点的ip，元素1为port，元素2为节点id。</p><pre class="line-numbers language-none"><code class="language-none">49 48 54 46 49 51 46 49 50 52 46 52 → 106.13.124.498 48 55 100 49 57 54 48 55 100 50 97 101 98 97 57 57 49 52 56 99 48 102 48 52 50 53 55 98 55 54 54 50 56 98 97 52 52 57 48 →b07d19607d2aeba99148c0f04257b76628ba4490<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>③处元素0为哈希槽对应从节点的ip，元素1为port，元素2为节点id。</p><ul><li>发现异常</li></ul><p>根据集群配置：节点<code>47.93.231.115:6379</code>对应哈希槽为2730-5459</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">4088d812e351785600c774978959a45b0e31f7a5 <span class="token number">47.93</span>.231.115:6379@16379 master - <span class="token number">0</span> <span class="token number">1588776197225</span> <span class="token number">1</span> connected <span class="token number">2730</span>-5459<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看slots中槽位分布为2730-5459的信息</strong></p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/ip%E9%94%99%E8%AF%AF.png" alt="ip错误"></p><p><strong>②处的<code>ip = 192.168.1.86</code>，并非集群中的<code>47.93.231.115</code>。</strong>登录<code>47.93.231.115</code>服务器，<code>ifconfig</code>发现<code>192.168.1.86</code>是服务器的内网IP，并非公网IP。内网IP无法访问，因此每次访问该服务器上的数据均无法建立连接，导致超时重试，超过重试次数后报异常。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>JedisCluster</code>初始化时会将节点与哈希槽映射关系进行缓存;</p><p>节点与哈希槽的映射关系数据需要通过<code>cluster slots</code>命令获取，因此获取该数据要先创建链接;</p><p>创建的链接对应的节点是<code>Set&lt;HostAndPort&gt;</code>中角标为0的节点;</p><p>在该节点上执行<code>cluster slots</code>命令，该节点获取的IP是自己网卡的IP，即服务器的内网IP，而非公网 IP。</p><p>因此<code>JedisCluster</code>在缓存该节点与哈希槽映射关系时，节点信息存成了内网IP:端口号，</p><p>导致<code>JedisCluster</code>操作该节点数据时，通过内网IP:端口号访问Redis，</p><p>导致无法访问，连接超时，</p><p>导致<code>JedisCluster</code>不断重试，</p><p>超过最大重试次数后，报<code>redis.clients.jedis.exceptions.JedisClusterMaxAttemptsException: No more cluster attempts left</code>异常</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul><li>查看<code>List&lt;Object&gt; slots = jedis.clusterSlots();</code>底层代码</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cluster</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> subcommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  arg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">SafeEncoder</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>subcommand<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">cluster</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打断点发现此处<code>subCommand</code>为<code>slots</code>，即表明<code>jedis.clusterSlots()</code>通过调用<code>cluster slots</code>命令获取节点与哈希槽的对应关系。</p><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/subCommand.png" alt="subCommand"></p><ul><li>在节点<code>47.93.231.115</code>上执行<code>cluster slots</code></li></ul><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/clusterslots.png" alt="cluster slots"></p><ul><li>在节点<code>47.93.231.115</code>上执行<code>ifconfig</code></li></ul><p><img src="https://images-1252818907.cos.ap-chengdu.myqcloud.com/images/ifconfig.png" alt="ifconfig"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
            <tag> Jedis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis常用命令</title>
      <link href="2018/04/28/redis-chang-yong-ming-ling/"/>
      <url>2018/04/28/redis-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><p><img src="https://user-gold-cdn.xitu.io/2019/9/24/16d614b75890ac75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h3 id="基本全局命令"><a href="#基本全局命令" class="headerlink" title="基本全局命令"></a>基本全局命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看所有键</span>keys *<span class="token comment">#选择数据库 0-15</span><span class="token keyword">select</span> <span class="token number">11</span><span class="token comment">#清除所有数据 返回ok</span>flushall<span class="token comment">#清除当前数据库数据 返回ok</span>flushdb<span class="token comment">#键是否存在 存在1不存在0</span>exists key<span class="token comment">#当前数据库中键的数量</span>dbsize<span class="token comment">#删除键 多个 del key1 key2 key3 O(1)|O(n) n是键的个数</span><span class="token comment">#成功返回删除键的数量 失败返回0</span>del key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token comment">#设置键过期时间 惰性删除OR定期扫描</span>expire key second<span class="token comment">#键剩余时间</span><span class="token comment">#>=0 键剩余时间 -1未设置过期时间 -2 键不存在</span>ttl key<span class="token comment">#键的类型 键不存在返回none</span><span class="token builtin class-name">type</span> key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><code>Key</code>最大512M，<code>Value</code>最大512M。</p><p><code>String</code>类型内部编码：</p><ul><li><code>int</code> 8个字节长整型，大概超过<strong>±922.32亿亿</strong>之后切换成<code>embstr</code></li><li><code>embstr</code> &lt;=39字节字符串</li><li><code>raw</code> &gt;39字节字符串</li></ul><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>缓存</p><p>播放量计数</p><p>共享session</p><p>限速：<code>key</code>是IP或TEL，<code>value</code>是次数，每访问一次<code>incr</code>。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#设置值|添加新键值 O(1)</span><span class="token comment">#ex|px设置秒级|毫秒级过期时间</span><span class="token comment">#nx 不存在才可设置 xx存在才可设置</span><span class="token builtin class-name">set</span> key value <span class="token punctuation">[</span>ex seconds<span class="token punctuation">]</span> <span class="token punctuation">[</span>px millseconds<span class="token punctuation">]</span> <span class="token punctuation">[</span>nx<span class="token operator">|</span>xx<span class="token punctuation">]</span><span class="token comment">#设置过期的缩写命令 原子执行还减少了一次网络执行时间 重点</span>setex key seconds value<span class="token comment">#不存在才执行成功 作为一种分布式锁的实现方案 重点</span>setnx key value <span class="token comment">#获取值 O(1)</span>get key <span class="token comment">#批量设置值 O(N)</span>mset key value <span class="token punctuation">[</span>key value<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#批量获取值 不存在的返回nil</span>mget key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#整数返回自增1的值 非整数返回错误 键不存在自增1返回</span>incr key<span class="token comment">#自增n</span>incrby key increment<span class="token comment">#自减浮点数</span>incrbyfloat key increment<span class="token comment">#自减</span>decr key<span class="token comment">#自减n</span>decrby key decrement<span class="token comment">#在指定key后追加</span>append key value<span class="token comment">#value的长度 每个中文字符占3个字节</span>strlen key<span class="token comment">#设置并返回原值 键不存在返回nil</span>getset key value<span class="token comment">#返回指定长度字符串 </span><span class="token comment">#前闭后闭 O(N) N是字符串长度 字符串较短可视为O(1)</span>getrange key start end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p><code>Key</code>最大512M，<code>Value</code>最大2^32-1个元素。</p><p><code>value</code>: <code>field:value</code></p><p><code>HASH</code>类型内部编码：</p><ul><li><p><code>ziplist</code>（压缩列表）：<code>hash</code>元素个数(即<code>field</code>) &lt; <code>hash-max-ziplist-entries</code>（<code>default</code>=512）配置且<code>hash</code>元素的值&lt;<code>hash-max-ziplist-value</code>(<code>default=64</code>)配置时采用。</p><p>  <code>ziplist</code>使用更加紧凑的结构实现多个元素连续存储，节省内存。</p></li><li><p><code>hashtable</code>（哈希表）：不满足以上条件时采用，此时<code>ziplist</code>读写效率下降。</p></li></ul><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>作为业务对象的缓存，如存用户信息。</p><p><strong>对比</strong></p><ul><li><p>使用字符串存<code>JSON</code>类型的对象信息</p><p>  优：简化编程 劣：序列化和反序列化有开销，更新属性需要把对象反序列化再存入。</p></li><li><p>使用<code>hash</code></p><p>  优：简单 劣：把控<code>ziplist</code>和<code>hashtable</code>间的转换</p></li></ul><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#设置值 set user:1 name k</span>hset key field value<span class="token comment">#获取值 不存在返回nil</span>hget key field<span class="token comment">#删除field 或多个</span>hdel key filed <span class="token punctuation">[</span>field<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#返回field个数 O(1)</span>hlen key<span class="token comment">#批量设置</span>hmset key field value <span class="token punctuation">[</span>field value<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#批量获取</span>hmget key field <span class="token punctuation">[</span>field<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#field是否存在 有返回1 没有返回0</span>hexists key field<span class="token comment">#获取所有field</span>hkeys key<span class="token comment">#获取所有value</span>hvals key<span class="token comment">#获取所有field-value 若f-v较多会使redis阻塞 </span><span class="token comment">#建议hmget需要的或使用hscan</span>hgetall key<span class="token comment">#自增</span>hincrbyfloat key field incrementhincrby key filed increment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p><code>Key</code>最大512M，<code>Value</code>最大2^32-1个元素。</p><p><code>List</code>类型内部编码：<code>quicklist</code>：结合了<code>ziplist</code>和<code>linkedlist</code>优势。</p><h4 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h4><ul><li><p>消息队列</p></li><li><p>文章列表</p></li><li><p><code>lpush</code> + <code>lpop</code> 栈</p></li><li><p><code>lpush</code> + <code>rpop</code> 队列</p></li><li><p><code>lpush</code> + <code>ltrim</code> 有限集合</p></li><li><p><code>lpush</code> + <code>brpop</code> 消息队列</p></li></ul><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#从左右push</span>lpushrpush<span class="token comment">#从左右pop</span>lpoprpop<span class="token comment">#删除key中元素</span><span class="token comment">#count=0 删除所有指定元素 count>0 从左到右删除count个 &lt;从左到右删除-count个</span><span class="token comment">#返回删了几个</span>lrem key count value<span class="token comment">#保留指定角标间的值 start&lt;=end 若start>end就全删除了 </span>ltrim key start end<span class="token comment">#在某元素前后插入新元素</span><span class="token comment">#失败返回-1 成功返回现在list长度</span>linsert key before<span class="token operator">|</span>after pivot value<span class="token comment">#获取指定范围元素 </span><span class="token comment">#角标从左到右0~lenth-1 从右到左-1~-lenth 前闭后闭</span><span class="token comment">#O(s+n) s是start的偏移量 n = end -start</span>lrange start end<span class="token comment">#返回指定角标元素</span><span class="token comment">#不存在返回nil 存在返回值</span>lindex key index<span class="token comment">#获取list长度</span>len key<span class="token comment">#设置指定角标的值</span>lset key index newValue<span class="token comment">#源键弹出 目地键放入 sourceKey不存在返回nil</span><span class="token comment">#sourceKey=destinationKey 即原list中的value向右移动一位</span>rpoplpush sourceKey destinationKey<span class="token comment">#阻塞式操作 单位：秒</span><span class="token comment"># sourceKey不存在则等待timeout</span>brpoplpush sourceKey destinationKey <span class="token function">timeout</span>brpop key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>blpop key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p><code>Key</code>最大512M，<code>Value</code>最大2^32-1个元素。</p><p>不允许重复元素且无序。</p><p><code>Set</code>类型内部编码：</p><ul><li><code>instset</code>：全为<strong>整数</strong>且个数小于<code>set-max-intset-entries</code>（<code>default</code> = 512）配置项时</li><li><code>hashtable</code>：不满足上诉条件时使用</li></ul><h4 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h4><p>标签：</p><p>给用户添加标签 <code>sadd user1:tags tag1 tag2 tag3</code></p><p>给标签添加用户 <code>sadd tag1:users user1 user2 user3</code></p><p>删除用户标签 <code>srem user1:tags tag1</code></p><p>删除标签用户 <code>srem tag1:users user1</code></p><p><strong>添加和删除是两个事务，上述关联操作应放在事务中进行。</strong></p><p>计算用户共同感兴趣标签：<code>sinter user1:tags user2:tags</code></p><p>生成随机数：</p><p><code>spop</code>/<code>srandmember</code></p><p>社交需求：</p><p><code>sadd</code> + <code>sinter</code></p><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#添加元素</span>sadd key element <span class="token punctuation">[</span>element<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#删除元素</span>srem key element <span class="token punctuation">[</span>element<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#返回元素个数 O(1) 内部维护变量</span>scard key<span class="token comment">#查看指定元素是否存在于指定key中</span><span class="token comment">#存在1 不存在0</span>sismember key element<span class="token comment">#随机返回count个元素 O(count)</span>srandmember key count<span class="token comment">#随机弹出一个元素</span>spop key<span class="token comment">#获取所有元素</span>smembers key<span class="token comment">#求交集 O(M*K) M键个数K集合中元素最少的个数</span>sinter key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#求并集 O(K) 多个集合元素个数和</span>sunion key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#差集 sdiff key1 key2 key3 即key1减去key2和key3中有的元素 O(K) 多个集合元素个数和</span><span class="token function">sdiff</span> key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#求完结果并保存</span>sinterstore destination key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>sunionstore destination key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>sdiffstore destination key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><p><code>Key</code>最大512M，<code>Value</code>最大2^32-1个元素。</p><p>元素不能重复，但对应的<code>score</code>可以重复。</p><p><code>Zset</code>的内部编码：</p><p><code>ziplist</code>：元素个数&lt;=<code>zset-max-ziplist-entries</code>(<code>default</code> = 128) &amp;&amp; 元素长度&lt;=<code>zset-max-ziplist-value</code>(<code>default</code> = 64字节)</p><p><code>skiplist</code>：不满足上述条件时</p><h4 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h4><p>排行榜</p><h4 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#NX|XX 不存在才设置|存在才设置  O(K*log(n)) k是添加成员个数 n是当前成员个数</span><span class="token comment">#ch 返回此次设置修改member的个数</span><span class="token comment">#INCR socre自增 zadd zset xx ch incr 10 rank10 令rank10原来的值加10 返回加后的值</span>zadd key <span class="token punctuation">[</span>NX<span class="token operator">|</span>XX<span class="token punctuation">]</span> <span class="token punctuation">[</span>CH<span class="token punctuation">]</span> <span class="token punctuation">[</span>INCR<span class="token punctuation">]</span> score member <span class="token punctuation">[</span>score member <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token comment">#元素个数</span>zcard key<span class="token comment">#返回该元素的分数 没有返回nil</span>zscore key member<span class="token comment">#返回元素的序号 没有返回nil</span><span class="token comment">#从低到高的名次 0开始  O(log(n)) n是当前有序集合成员个数</span>zrank key member<span class="token comment">#从高到底的名次 0开始</span>zrevrank key member<span class="token comment">#删除元素 返回删除的个数 O(k*log(n)) k删除的个数 n当前的元素总数</span>zrem key member <span class="token punctuation">[</span>member<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#加分 不存在的元素就会自动添加 O(log(n)) 当前元素总数</span>zincrby key socre member<span class="token comment">#返回指定角标范围元素 option withscores 是否返回分数 </span><span class="token comment">#O(k+log(n)) k是返回的个数 n是元素总数</span>zrange key start end <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>zrevrange key start end <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span><span class="token comment">#返回指定分数范围的元素 offset指定角标 count指定返回个数 </span><span class="token comment">#默认闭区间 开区间左边加(    -inf +inf表示负正无穷大</span><span class="token comment">#O(k+log(n)) k是返回的个数 n是元素总数</span>zrangebyscore key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT OFFSET COUNT<span class="token punctuation">]</span>zrevrangebyscore key max min <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT OFFSET COUNT<span class="token punctuation">]</span><span class="token comment">#返回指定分数范围内成员个数 同样可指定开闭区间 O(log(n))</span>zcount key min max<span class="token comment">#删除指定排名范围内元素 返回成功的个数</span><span class="token comment">#O(k+log(n)) k是删除的个数 n是元素总数</span>zremrangebyrank key start end<span class="token comment">#删除指定分数范围内的元素 返回成功的个数</span><span class="token comment">#O(k+log(n)) k是删除的个数 n是元素总数</span>zremrangebyscore key min max<span class="token comment">#交集 destination结果存储键 numkeys计算的总键数 key键 weights每个键的权重 默认1</span><span class="token comment">#aggregate规定交集的分值如何汇总 默认sum</span><span class="token comment">#O(n*k) + O(m*log(m)) n是成员数最小的集合的成员个数 k是集合的个数 m是结果集中成员的个数</span>zinterstore destination numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>WEIGHTS weight<span class="token punctuation">]</span> <span class="token punctuation">[</span>AGGREGATE SUM<span class="token operator">|</span>MIN<span class="token operator">|</span>MAX<span class="token punctuation">]</span><span class="token comment">#并集 O(n) + O(m*log(m)) n是所有集合成员个数总数 m是结果集中成员的个数</span>zunionstore destination numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>WEIGHTS weight<span class="token punctuation">]</span> <span class="token punctuation">[</span>AGGREGATE SUM<span class="token operator">|</span>MIN<span class="token operator">|</span>MAX<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bitmpas"><a href="#Bitmpas" class="headerlink" title="Bitmpas"></a>Bitmpas</h3><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><p>实际上就是字符串，只是可以对字符串进行位操作。大小限制同<code>String</code>。</p><h4 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h4><p>独立用户访问计数。</p><p><code>setbit unique:users:20200405 166 1</code></p><p>即2020年4月5日这天，用户ID为166的用户访问了网站。</p><p>为避免setbit操作初始化较慢造成阻塞，用户id建议减去一定数字（比如10000）再存。</p><p><code>set</code>和<code>bitmap</code>都可以存独立用户访问，需要根据实际情况评估占用空间大小。</p><h4 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#设置值setbit key 0 0|1</span>setbit key offset value<span class="token comment">#获取值 返回0|1</span>getbit key offset<span class="token comment">#获取范围内为1的个数 不设置start&amp;end 就返回所有为1的个数</span>bitcount key <span class="token punctuation">[</span>start end<span class="token punctuation">]</span><span class="token comment">#operation = and|or|not|xor 与或非异或</span>bitop operation destkey key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>  <span class="token comment">#计算值中第一个值为bit的角标 start end可限制范围</span>bitpos key bit <span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><p>实际上就是字符串，key最大512M，不论多少数据value固定12k。</p><p>采用了基数算法，官方误差在0.81%。</p><p>笔记本尝试存100万和1000万数据后<code>info memory</code>变化均约为<code>16.1k</code>，应该是<code>key</code>的大小和维护其他有关数据。</p><blockquote><p>The HyperLogLog data structure can be used in order to count <strong>unique</strong> elements in a set using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog.</p><p>p.plus a few bytes for the key itself.</p><p>The returned cardinality of the observed set is not exact, but approximated with a standard error of <strong>0.81%</strong>.</p><p><strong>p.s. 该数据结构的是对unique element进行计算。</strong></p></blockquote><p>test:hll:01 存100万数据</p><p>test:hll:11 存1000万数据</p><p><strong>在我的机器上看到存100万数据误差率&gt;0.81%。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> keys *<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"test:hll:11"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"test:hll:01"</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> pfcount test:hll:01 test:hll:11<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9972088</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> pfcount test:hll:01<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1009838</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> pfcount test:hll:11<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9972088</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#添加</span>pfadd key element <span class="token punctuation">[</span>element<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#计算一个或多个key的中不重复元素的总数</span>pfcount key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#多个key合并后再计算</span>pfmerage key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#重命名键 nx防止newKey存在 如果不加nx，重命名用了已有的键，键对应的值就丢失了。</span><span class="token comment">#若旧键对应的值比较大 重名名时会删除旧键 可能阻塞Redis</span><span class="token function">rename</span> key newKeyrenamenx key newKey<span class="token comment">#随机返回一个key</span>randomkey<span class="token comment">#键过期 键不存在返回0 时间负数键立即被删除 时间戳小于现在立即被删除</span><span class="token comment">#秒级时间戳后过期 pxpireat key 1469980800</span>exprieat key timestamp<span class="token comment">#毫秒级过期</span>pexpire key millsecondspexpireat key millseconds-timestamp<span class="token comment">#清除键的过期时间</span>persist key<span class="token comment">#set key value会清除过期时间</span><span class="token comment">#键迁移到不同的数据库</span>move key db--------------------------------------------------------------------------------------<span class="token comment">#键迁移到不同数据库实例</span><span class="token comment">#键被序列化 RDB格式</span>dump key<span class="token comment">#在目标redis实例上恢复 ttl key过期时间,0即不过期 value 序列化值</span>restore key ttl value<span class="token comment">#示例</span>sourceRedis:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> dump key<span class="token string">"<span class="token entity" title="\x00">\x00</span><span class="token entity" title="\x03">\x03</span>key<span class="token entity" title="\a">\a</span><span class="token entity" title="\x00">\x00</span><span class="token entity" title="\x1a">\x1a</span>g<span class="token entity" title="\xe1">\xe1</span><span class="token entity" title="\xfe">\xfe</span><span class="token entity" title="\x95">\x95</span><span class="token entity" title="\x01">\x01</span><span class="token entity" title="\x17">\x17</span><span class="token entity" title="\x99">\x99</span>"</span>targetRedis:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> resore key <span class="token number">0</span> <span class="token string">"<span class="token entity" title="\x00">\x00</span><span class="token entity" title="\x03">\x03</span>key<span class="token entity" title="\a">\a</span><span class="token entity" title="\x00">\x00</span><span class="token entity" title="\x1a">\x1a</span>g<span class="token entity" title="\xe1">\xe1</span><span class="token entity" title="\xfe">\xfe</span><span class="token entity" title="\x95">\x95</span><span class="token entity" title="\x01">\x01</span><span class="token entity" title="\x17">\x17</span><span class="token entity" title="\x99">\x99</span>"</span>--------------------------------------------------------------------------------------<span class="token comment">#用来进行数据迁移 结合了dump restore del命令，是原子操作</span><span class="token comment">#host目标Redis port目标Redis端口 destination-db目标数据库号 COPY源数据不删除</span><span class="token comment">#REPLACE覆盖目标Redis 若源Reids与目标Redis有相同键，但没加REPLACE会报错</span><span class="token comment">#timeout迁移的超时时间</span>migrate <span class="token function">host</span> port key<span class="token operator">|</span> destination-db <span class="token function">timeout</span> <span class="token punctuation">[</span>COPY<span class="token punctuation">]</span> <span class="token punctuation">[</span>REPLACE<span class="token punctuation">]</span> <span class="token punctuation">[</span>KEYS key<span class="token punctuation">]</span><span class="token comment">#示例</span>sourceRedis:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> migrate <span class="token number">127.0</span>.0.1 <span class="token number">6380</span> <span class="token string">""</span> <span class="token number">0</span> <span class="token number">5000</span> keys key1 key2 key3sourceRedis:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> migrate <span class="token number">127.0</span>.0.1 <span class="token number">6380</span> key4 <span class="token number">0</span> <span class="token number">5000</span><span class="token comment">#遍历键 pattern比如 * ? []各种匹配符</span><span class="token comment">#键太多不建议这样使用</span>keys pattern<span class="token comment">#渐进式遍历</span><span class="token comment">#MATCH pattern匹配模式</span><span class="token comment">#COUNT count每次遍历的个数</span><span class="token comment">#hscan sscan zscan可以遍历值中的字段</span><span class="token comment">#cursor知道cursor再次为0 即遍历完毕</span>scan cursor <span class="token punctuation">[</span>MATCH pattern<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span><span class="token comment">#示例</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> mset a a b b c c d d e e f f g g h h i i j j k k l l m m n n o o p p q q r r s s t t u u <span class="token function">v</span> <span class="token function">v</span> w w x x y y z zOK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> scan <span class="token number">0</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"22"</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"x"</span>    <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"l"</span>    <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"h"</span>    <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"g"</span>    <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"m"</span>    <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"o"</span>    <span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"k"</span>    <span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">"v"</span>    <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">"j"</span>   <span class="token number">10</span><span class="token punctuation">)</span> <span class="token string">"e"</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> scan <span class="token number">22</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"19"</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"w"</span>    <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"d"</span>    <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"b"</span>    <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"p"</span>    <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"z"</span>    <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"a"</span>    <span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"i"</span>    <span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">"r"</span>    <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">"q"</span>   <span class="token number">10</span><span class="token punctuation">)</span> <span class="token string">"u"</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">></span> scan <span class="token number">19</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"0"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"n"</span>   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"f"</span>   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"c"</span>   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"t"</span>   <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"s"</span>   <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"y"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><ul><li>对有过期时间的键重新执行<code>set key value</code>会清除过期时间，见源码：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">setKey</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">,</span> robj <span class="token operator">*</span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">lookUpKeyWrite</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">dbAdd</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">dbOverWrite</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">incrRefCount</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//清除了过期时间    </span><span class="token function">removeExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">signalModifiedKey</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>不建议一个Redis实例中使用多个数据库，影响性能。而应使用多个Redis实例配置多个端口。</p></li><li><p>惰性删除：<code>del key</code>不会立即删除，会放在一个独立字典维护，在下次<code>get key</code>时删除，造成内存浪费。</p></li><li><p>定期扫描：配置<code>hz</code>项，Redis后台每X秒进行扫描。</p><p>  从过期字典中随机选择20个key；</p><p>  删除20key中已过期的key；</p><p>  如果删除比例超过25%，重复执行。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket实现简单聊天程序</title>
      <link href="2016/06/08/socket-shi-xian-jian-dan-liao-tian-cheng-xu/"/>
      <url>2016/06/08/socket-shi-xian-jian-dan-liao-tian-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Client</code>作为客户端启动，每个客户端单独开启<code>Send</code>&amp;<code>Receive</code>线程负责接收和发送消息。</p><p><code>Server</code>作为服务器端启动，每连接上一个客户端，新建一个<code>Channel</code>线程负责接收客户端的消息并广播。</p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Socket</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">7777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用户 "</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">getLocalPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 已连接..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClientSend</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClientReceive</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ClientSend"><a href="#ClientSend" class="headerlink" title="ClientSend"></a>ClientSend</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientSend</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Socket</span> client<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PrintStream</span> sendStream<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BufferedReader</span> systemIn<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> errorOccurred <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ClientSend</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> client<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>client <span class="token operator">=</span> client<span class="token punctuation">;</span>        sendStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        systemIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>msg <span class="token operator">=</span> systemIn<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sendStream<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">getLocalPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 说 "</span><span class="token operator">+</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">CloseIOUtil</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>sendStream<span class="token punctuation">,</span> systemIn<span class="token punctuation">)</span><span class="token punctuation">;</span>            errorOccurred <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>errorOccurred<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CliendReceive"><a href="#CliendReceive" class="headerlink" title="CliendReceive"></a>CliendReceive</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientReceive</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Socket</span> client<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BufferedReader</span> receiveReader<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> errorOccurred <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ClientReceive</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> client<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>client <span class="token operator">=</span> client<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiveReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>msg <span class="token operator">=</span> receiveReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">CloseIOUtil</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>receiveReader<span class="token punctuation">)</span><span class="token punctuation">;</span>            errorOccurred <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>errorOccurred<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Server</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Socket</span><span class="token punctuation">></span></span> SOCKETS <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ServerSocket</span> server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">7777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Socket</span> s <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用户 "</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 已连接..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            SOCKETS<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServerChannel</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ServerChannel"><a href="#ServerChannel" class="headerlink" title="ServerChannel"></a>ServerChannel</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerChannel</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Socket</span> msgSocket<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BufferedReader</span> receive<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">PrintStream</span> send<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> errorOccurred <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ServerChannel</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> msgSocket<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msgSocket <span class="token operator">=</span> msgSocket<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receive <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>msgSocket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>send <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span>msgSocket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> receive<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">CloseIOUtil</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>receive<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Server</span><span class="token punctuation">.</span>SOCKETS<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>msgSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>            errorOccurred <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"收到消息--> "</span><span class="token operator">+</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Socket</span> s <span class="token operator">:</span> <span class="token class-name">Server</span><span class="token punctuation">.</span>SOCKETS<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    send <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    send<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发出消息--> "</span><span class="token operator">+</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">CloseIOUtil</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>send<span class="token punctuation">,</span>receive<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Server</span><span class="token punctuation">.</span>SOCKETS<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                    errorOccurred <span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>errorOccurred<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">send</span><span class="token punctuation">(</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
